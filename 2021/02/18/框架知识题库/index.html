<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="make more time">
    <meta name="author" content="notfornothing">
    
    <title>
        
            框架知识题库题 |
        
        Sparrow
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.png">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#FF0033","avatar":"/images/avatar.png","favicon":"/images/logo.png","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"make more time."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Sparrow
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">框架知识题库题</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">notfornothing</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-02-18 15:20:16
    </span>
    
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>9.7k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>35 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>%s/[1].\d/### &amp;</p>
<p> 框架知识题库</p>
<h3 id="1-何为-Spring-Bean-容器？Spring-Bean-容器与-Spring-IOC-容器有什么不同吗？"><a href="#1-何为-Spring-Bean-容器？Spring-Bean-容器与-Spring-IOC-容器有什么不同吗？" class="headerlink" title="1    何为 Spring Bean 容器？Spring Bean 容器与 Spring IOC 容器有什么不同吗？"></a>1    何为 Spring Bean 容器？Spring Bean 容器与 Spring IOC 容器有什么不同吗？</h3><p>答：用于创建 bean 对象，管理 bean 对象的那个容器<br>Spring IOC 容器本质上指的的就是 Spring Bean 容器，<br>Spring Bean 容器中最核心一个机制是 IOC 机制 (<br>控制反转）, 所以有时候又将 springbean 容器称之为<br>Spring IOC 容器。</p>
<h3 id="2-Spring-IOC-如何理解？"><a href="#2-Spring-IOC-如何理解？" class="headerlink" title="2    Spring IOC 如何理解？"></a>2    Spring IOC 如何理解？</h3><p>答：IOC 是 Spring 中提供一种控制反转机制，目的是将我们<br>项目中对象的依赖管理交给 Spring 实现，这样可以更好<br>实现对象关系的解耦，提高程序的可扩展性。</p>
<h3 id="3-Spring-DI-如何理解？"><a href="#3-Spring-DI-如何理解？" class="headerlink" title="3    Spring DI 如何理解？"></a>3    Spring DI 如何理解？</h3><p>答：DI 是 Spring 中的依赖注入机制，IOC 的实现需要借助<br>这种机制。我们通常会这样理解，Spring Bean 容器中的<br>IOC 思想一种目标，DI 是实现这种思想的目标的手段。</p>
<h3 id="4-Spring-中基于注解如何配置对象作用域？以及如何配置延迟加载机制？"><a href="#4-Spring-中基于注解如何配置对象作用域？以及如何配置延迟加载机制？" class="headerlink" title="4    Spring 中基于注解如何配置对象作用域？以及如何配置延迟加载机制？"></a>4    Spring 中基于注解如何配置对象作用域？以及如何配置延迟加载机制？</h3><p>答：@Scope(“singleton”)<br>@Scope(“prototype”)<br>@Lazy(value=true)</p>
<h3 id="5-Spring-工厂底层构建-Bean-对象借助什么机制？当对象不使用了要释放资源，目的是什么？何为内存泄漏？"><a href="#5-Spring-工厂底层构建-Bean-对象借助什么机制？当对象不使用了要释放资源，目的是什么？何为内存泄漏？" class="headerlink" title="5    Spring 工厂底层构建 Bean 对象借助什么机制？当对象不使用了要释放资源，目的是什么？何为内存泄漏？"></a>5    Spring 工厂底层构建 Bean 对象借助什么机制？当对象不使用了要释放资源，目的是什么？何为内存泄漏？</h3><p>答：借助反射机制，防止内存泄漏，对象已经不使用了但占用着内存，这种现    象称之为内存泄漏，内存泄漏不是内存溢出，但是它是内存溢出的一个导火索。内存溢出直接就导致系统崩溃了。</p>
<h3 id="6-描述-Spring-MVC-处理流程及应用优势"><a href="#6-描述-Spring-MVC-处理流程及应用优势" class="headerlink" title="6    描述 Spring MVC 处理流程及应用优势"></a>6    描述 Spring MVC 处理流程及应用优势</h3><p>答：<br>1、客户端发出一个 http 请求给 web 服务器，web 服务器对 http 请求进    行    解析，如果匹配前端控制器（或分发器 /DispatcherServlet) 的请求映射路径，    web 容器将请求转交给 DispatcherServlet.<br>2、DipatcherServlet 接收到这个请求之后将根据请求的信息以及处理器映射    器 (HandlerMapping) 的配置找到处理请求的处理器（Handler）。<br>3、由具体的处理器适配器（HandlerAdapter）对 Handler 进行具体的调用。<br>4、Handler 对数据处理完成以后将返回一个 ModelAndView() 对象给    DispatcherServlet。<br>5、DispatcherSevlet 通过视图解析器（ViewResolver）将 ModelAndView() 转    化为真正的视图 View。<br>6、Dispatcher 通过 model 解析出 ModelAndView() 中的参数进行解析最终展    现出完整的 view 并返回给客户端。</p>
<h3 id="7-Spring-中的事务处理方式及优缺点"><a href="#7-Spring-中的事务处理方式及优缺点" class="headerlink" title="7    Spring 中的事务处理方式及优缺点"></a>7    Spring 中的事务处理方式及优缺点</h3><p>   答：优点在于：<br>1：能够实现全局事务的控制，通过 EJB CMT 进行事物的管理。<br>2：能够保证项目模块在系统中完成的功能是可可控制的的操作（AOP）<br>缺点在于：<br>1：Spring 中的事物声明有编程式事物和申明是事物</p>
<h3 id="8-MyBatis-应用中-与-有什么异同点"><a href="#8-MyBatis-应用中-与-有什么异同点" class="headerlink" title="8    MyBatis 应用中#与 $ 有什么异同点"></a>8    MyBatis 应用中#与 $ 有什么异同点</h3><p>答：<br>      相同点：都是通过 get 来获取值的<br>      不同点：$ 传进去的字符串不带引号 #号带引号</p>
<h3 id="9-MyBatis-应用动态-SQL-解决了什么问题"><a href="#9-MyBatis-应用动态-SQL-解决了什么问题" class="headerlink" title="9    MyBatis 应用动态 SQL 解决了什么问题"></a>9    MyBatis 应用动态 SQL 解决了什么问题</h3><p>答：有时候，固定的 sql 语句不能够满足我们的应用需求。这个时候需要在    标准的基础上建立动态的查询语句。<br>Mybatis 提供了多种注解，可以提供动态查询语言。<br>比如说在开发的时候，遇到这样的场景，界面提供了多种查询，但是都是非    必填写，在选择查询条件时可以选中任意几种组合作为查询条件，如果在使    用 jdbc 的时候，需要判断参数为空，自己组装 sql，<br>但是 mybatis 提供动态 sql 机制，依靠标签。</p>
<h3 id="10-Shiro-框架权限管理时的认证和授权流程描述。"><a href="#10-Shiro-框架权限管理时的认证和授权流程描述。" class="headerlink" title="10    Shiro 框架权限管理时的认证和授权流程描述。"></a>10    Shiro 框架权限管理时的认证和授权流程描述。</h3><p>答：Shiro 权限控制流程的原理：<br>应用代码 —- 调用 Subject （shiro 的 Subject 就代表当前登陆用户） 控制权限 —- Subject 在 shiro 框架内部 调用 Shiro SecurityManager 安全管理器 —– 安全管理器调用 Realm （程序和安全数据连接器 ）。<br>Subject 要进行任何操作，都必须要调用安全管理器（对我们来说是自动的）。<br>而安全管理器会调用指定的 Realms 对象，来连接安全数据。<br>Realms 用来编写安全代码逻辑和访问安全数据，是连接程序和安全数据的桥梁。</p>
<h3 id="11-BeanFactory-和-ApplicationContext-有什么区别？"><a href="#11-BeanFactory-和-ApplicationContext-有什么区别？" class="headerlink" title="11    BeanFactory 和 ApplicationContext 有什么区别？"></a>11    BeanFactory 和 ApplicationContext 有什么区别？</h3><pre><code>     BeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义，以便在接收到客户端请求时将对应的 bean 实例化。
      BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的配置中解放出来。BeanFactory 还包含了 bean 生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。
</code></pre>
<p>从表面上看，application context 如同 bean factory 一样具有 bean 定义、bean 关联关系的设置，根据请求分发 bean 的功能。但 application context 在此基础上还提供了其他的功能。</p>
<h3 id="12-请解释-Spring-Bean-的生命周期？"><a href="#12-请解释-Spring-Bean-的生命周期？" class="headerlink" title="12    请解释 Spring Bean 的生命周期？"></a>12    请解释 Spring Bean 的生命周期？</h3><pre><code>Spring Bean 的生命周期简单易懂。在一个 bean 实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个 bean 不在被调用时需要进行相关的析构操作，并从 bean 容器中移除。
Spring bean factory 负责管理在 spring 容器中被创建的 bean 的生命周期。Bean 的生命周期由两组回调（call back）方法组成。
</code></pre>
<p>   初始化之后调用的回调方法。<br>   销毁之前调用的回调方法。<br>  Spring 框架提供了以下四种方式来管理 bean 的生命周期事件：<br> InitializingBean 和 DisposableBean 回调接口<br> 针对特殊行为的其他 Aware 接口<br> Bean 配置文件中的 Custom init() 方法和 destroy() 方法<br> @PostConstruct 和 @PreDestroy 注解方式<br> 使用 customInit() 和 customDestroy() 方法管理 bean 生命周期的代码样例如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;demoBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.howtodoinjava.task.DemoBean&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">init-method</span>=<span class="string">&quot;customInit&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;customDestroy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="13-Spring-Bean-的作用域之间有什么区别？"><a href="#13-Spring-Bean-的作用域之间有什么区别？" class="headerlink" title="13    Spring Bean 的作用域之间有什么区别？"></a>13    Spring Bean 的作用域之间有什么区别？</h3><p>Spring 容器中的 bean 可以分为 5 个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下：<br>singleton：这种 bean 范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个 bean 的实例，单例的模式由 bean factory 自身来维护。<br>prototype：原形范围与单例范围相反，为每一个 bean 请求提供一个实例。<br>request：在请求 bean 范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean 会失效并被垃圾回收器回收。<br>Session：与请求范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后，bean 会随之失效。<br>global-session：global-session 和 Portlet 应用相关。当你的应用部署在 Portlet 容器中工作时，它包含很多 portlet。如果你想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局变量需要存储在 global-session 中。<br>全局作用域与 Servlet 中的 session 作用域效果相同。</p>
<h3 id="14-在-Spring-AOP-中，关注点和横切关注的区别是什么？"><a href="#14-在-Spring-AOP-中，关注点和横切关注的区别是什么？" class="headerlink" title="14    在 Spring AOP 中，关注点和横切关注的区别是什么？"></a>14    在 Spring AOP 中，关注点和横切关注的区别是什么？</h3><p>关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。<br>横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p>
<h3 id="15-使用-Spring-框架的好处是什么？"><a href="#15-使用-Spring-框架的好处是什么？" class="headerlink" title="15    使用 Spring 框架的好处是什么？"></a>15    使用 Spring 框架的好处是什么？</h3><p>•    轻量：Spring 是轻量的，基本的版本大约 2MB。<br>•    控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。<br>•    面向切面的编程 (AOP)：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务分开。<br>•    容器：Spring 包含并管理应用中对象的生命周期和配置。<br>•    MVC 框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的替代品。<br>•    事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。<br>•    异常处理：Spring 提供方便的 API 把具体技术相关的异常（比如由 JDBC，Hibernate or JDO 抛出的）转化为一致的 unchecked 异常。、</p>
<h3 id="16-Spring-中用到了那些设计模式？"><a href="#16-Spring-中用到了那些设计模式？" class="headerlink" title="16    Spring 中用到了那些设计模式？"></a>16    Spring 中用到了那些设计模式？</h3><p>•    Spring 框架中使用到了大量的设计模式，下面列举了比较有代表性的：<br>•    代理模式—在 AOP 和 remoting 中被用的比较多。<br>•    单例模式—在 spring 配置文件中定义的 bean 默认为单例模式。<br>•    模板方法—用来解决代码重复的问题。比如。RestTemplate, JmsTemplate, JpaTemplate。<br>•    工厂模式—BeanFactory 用来创建对象的实例。<br>•    适配器–spring aop<br>•    装饰器–spring data hashmapper<br>•    观察者– spring 时间驱动模型<br>•    回调–Spring ResourceLoaderAware 回调接口</p>
<h3 id="17-Spring-如何保证-Controller-并发的安全？"><a href="#17-Spring-如何保证-Controller-并发的安全？" class="headerlink" title="17    Spring 如何保证 Controller 并发的安全？"></a>17    Spring 如何保证 Controller 并发的安全？</h3><p>Spring 多线程请求过来调用的 Controller 对象都是一个，而不是一个请求过来就创建一个 Controller 对象。<br>并发的安全？ 原因就在于 Controller 对象是单例的，那么如果不小心在类中定义了类变量，那么这个类变量是被所有请求共享的，这可能会造成多个请求修改该变量的值，出现与预期结果不符合的异常<br>那有没有办法让 Controller 不以单例而以每次请求都重新创建的形式存在呢？<br>答案是当然可以，只需要在类上添加注解 @Scope(“prototype”) 即可，这样每次请求调用的类都是重新生成的（每次生成会影响效率）<br>虽然这样可以解决问题，但增加了时间成本，总让人不爽，还有其他方法么？答案是肯定的！<br>使用 ThreadLocal 来保存类变量，将类变量保存在线程的变量域中，让不同的请求隔离开来。</p>
<h3 id="18-使用-Spring-框架的好处是什么？"><a href="#18-使用-Spring-框架的好处是什么？" class="headerlink" title="18    使用 Spring 框架的好处是什么？"></a>18    使用 Spring 框架的好处是什么？</h3><p>轻量：Spring 是轻量的，基本的版本大约 2MB。<br>控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。<br>面向切面的编程 (AOP)：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务分开。<br>容器：Spring 包含并管理应用中对象的生命周期和配置。<br>MVC 框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的替代品。<br>事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。<br>异常处理：Spring 提供方便的 API 把具体技术相关的异常（比如由 JDBC，Hibernate or JDO 抛出的）转化为一致的 unchecked 异常。</p>
<h3 id="19-在-Spring-中如何注入一个-java-集合？"><a href="#19-在-Spring-中如何注入一个-java-集合？" class="headerlink" title="19    在 Spring 中如何注入一个 java 集合？"></a>19    在 Spring 中如何注入一个 java 集合？</h3><p>Spring 提供以下几种集合的配置元素：<br><list>类型用于注入一列值，允许有相同的值。<br>•    <set> 类型用于注入一组值，不允许有相同的值。<br>•    <map> 类型用于注入一组键值对，键和值都可以为任意类型。<br>•    <props>类型用于注入一组键值对，键和值都只能为 String 类型</props></map></set></list></p>
<h3 id="20-Spring-支持的事务管理类型"><a href="#20-Spring-支持的事务管理类型" class="headerlink" title="20    Spring 支持的事务管理类型"></a>20    Spring 支持的事务管理类型</h3><p>Spring 支持如下两种方式的事务管理：<br>编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。<br>声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者 XML 配置管理事务。</p>
<h3 id="21-Spring-框架的事务管理有哪些优点？"><a href="#21-Spring-框架的事务管理有哪些优点？" class="headerlink" title="21    Spring 框架的事务管理有哪些优点？"></a>21    Spring 框架的事务管理有哪些优点？</h3><p>它为不同的事务 API（如 JTA, JDBC, Hibernate, JPA, 和 JDO) 提供了统一的编程模型。<br>它为编程式事务管理提供了一个简单的 API 而非一系列复杂的事务 API（如 JTA).<br>它支持声明式事务管理。<br>它可以和 Spring 的多种数据访问技术很好的融合。</p>
<h3 id="22-Spring-MVC-的主要组件？"><a href="#22-Spring-MVC-的主要组件？" class="headerlink" title="22    Spring MVC 的主要组件？"></a>22    Spring MVC 的主要组件？</h3><p>（1）前端控制器 DispatcherServlet（不需要程序员开发）<br>作用：接收请求、响应结果，相当于转发器，有了 DispatcherServlet 就减少了其它组件之间的耦合度。<br>（2）处理器映射器 HandlerMapping（不需要程序员开发）<br>作用：根据请求的 URL 来查找 Handler<br>（3）处理器适配器 HandlerAdapter<br>注意：在编写 Handler 的时候要按照 HandlerAdapter 要求的规则去编写，这样适配器 HandlerAdapter 才可以正确的去执行 Handler。<br>（4）处理器 Handler（需要程序员开发）<br>（5）视图解析器 ViewResolver（不需要程序员开发）<br>作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）<br>（6）视图 View（需要程序员开发 jsp）<br>View 是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf 等等）</p>
<h3 id="23-SpringMvc-怎么和-AJAX-相互调用的？"><a href="#23-SpringMvc-怎么和-AJAX-相互调用的？" class="headerlink" title="23    SpringMvc 怎么和 AJAX 相互调用的？"></a>23    SpringMvc 怎么和 AJAX 相互调用的？</h3><p>通过 Jackson 框架就可以把 Java 里面的对象直接转化成 Js 可以识别的 Json 对象。具体步骤如下 ：<br>（1）加入 Jackson.jar<br>（2）在配置文件中配置 json 的映射<br>（3）在接受 Ajax 方法里面可以直接返回 Object,List 等，但方法前面要加上</p>
<h3 id="24-Mybatis-中-和-的区别？"><a href="#24-Mybatis-中-和-的区别？" class="headerlink" title="24    Mybatis 中#和 $ 的区别？"></a>24    Mybatis 中#和 $ 的区别？</h3><pre><code>  #&#123;&#125;是预编译处理，$&#123;&#125;是字符串替换。
  2. Mybatis 在处理#&#123;&#125;时，会将 sql 中的#&#123;&#125;替换为？号，调用 PreparedStatement 的 set 方法来赋值；
  3. Mybatis 在处理 $&#123;&#125;时，就是把 $&#123;&#125;替换成变量的值，相当于字符串拼接
  4. 使用#&#123;&#125;可以有效的防止 SQL 注入，提高系统安全性。
</code></pre>
<h3 id="25-mybatis-的缓存机制，一级，二级介绍一下"><a href="#25-mybatis-的缓存机制，一级，二级介绍一下" class="headerlink" title="25    mybatis 的缓存机制，一级，二级介绍一下"></a>25    mybatis 的缓存机制，一级，二级介绍一下</h3><p>   一级缓存<br>      默认开启<br>      SqlSession 级别的缓存，实现在同一个会话中数据的共享<br>      一级缓存的生命周期和 SqlSession 一致<br>      当有多个 SqlSession 或者分布式环境下，数据库写操作会引起脏数据。<br>二级缓存<br>      默认不开启，需手动开启<br>      SqlSessionFactory 级别的缓存，实现不同会话中数据的共享，是一个全局变量<br>      可自定义存储源，如 Ehcache<br>      当开启缓存后，数据查询的执行的流程是：二级缓存》一级缓存》数据库<br>      不同于一级缓存，二级缓存可设置是否允许刷新和刷新频率实现<br>实体类实现序列化，在 mapper 文件中开启<cache><br>在配置文件中设置 cacheEnabled 为 true</cache></p>
<h3 id="26-pringMVC-与-Struts2-的区别"><a href="#26-pringMVC-与-Struts2-的区别" class="headerlink" title="26    pringMVC 与 Struts2 的区别"></a>26    pringMVC 与 Struts2 的区别</h3><p> pringmvc 的入口是一个 servlet 即前端控制器，而 struts2 入口是一个 filter 过虑器。<br> pringmvc 是基于方法开发，传递参数是通过方法形参，可以设计为单例或多例（建议单例），struts2 是基于类开发，传递参数是通过类的属性，只能设计为多例。</p>
<h3 id="27-mybatis-的基本工作流程"><a href="#27-mybatis-的基本工作流程" class="headerlink" title="27    mybatis 的基本工作流程"></a>27    mybatis 的基本工作流程</h3><p> 读取配置文件，配置文件包含数据库连接信息和 Mapper 映射文件或者 Mapper 包路径。<br>2. 有了这些信息就能创建 SqlSessionFactory，SqlSessionFactory 的生命周期是程序级，程序运行的时候建立起来，程序结束的时候消亡<br>3.SqlSessionFactory 建立 SqlSession, 目的执行 sql 语句，SqlSession 是过程级，一个方法中建立，方法结束应该关闭<br>4. 当用户使用 mapper.xml 文件中配置的的方法时，mybatis 首先会解析 sql 动态标签为对应数据库 sql 语句的形式，并将其封装进 MapperStatement 对象，然后通过 executor 将 sql 注入数据库执行，并返回结果。<br>5. 将返回的结果通过映射，包装成 java 对象。</p>
<h3 id="28-什么是-MyBatis-的接口绑定，有什么好处"><a href="#28-什么是-MyBatis-的接口绑定，有什么好处" class="headerlink" title="28    什么是 MyBatis 的接口绑定，有什么好处"></a>28    什么是 MyBatis 的接口绑定，有什么好处</h3><p>接口映射就是在 IBatis 中任意定义接口，然后把接口里面的方法和 SQL 语句绑定，我们通过直接调用接口方法 例如：<br>UserMapper  userMapper=sqlSession.getMapper  (UserMapper.class) 就可以，这样比起原来了 SqlSession 提供的方法，例如 List<Country> countryList = sqlSession.selectList(“selectAll”); 我们可以有更加灵活的选择和设置.。</Country></p>
<p>注意：（1）Mapper .xml 文件的 namespace 属性必须配置为接口的全限定名称，接口方法名与 Mapper.xml 中的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;select&gt;&lt;insert&gt;</span><br></pre></td></tr></table></figure>
<p>id 值必须相同，且接口方法的返回值类型必须与 Mapper.xml 配置的 resultType 一致，这里后者起到决定作用。<br>（2）select 查询通过在 Mapper.xml 中配置 ResultMap 标签，将查询结果的列名与字段名对应。<br>insert 语句通过#{属性名}从接口参数获取值放到 sql 语句中。<br>（3）Mapper.xml 接口绑定本质是动态代理。</p>
<h3 id="29-MyBatis-的编程步骤"><a href="#29-MyBatis-的编程步骤" class="headerlink" title="29    MyBatis 的编程步骤"></a>29    MyBatis 的编程步骤</h3><p>创建 SqlSessionFactory<br>通过 SqlSessionFactory 创建 SqlSession<br>通过 SqlSession 执行数据库操作<br>调用 session.commit() 提交事务<br>调用 session.close() 关闭事务</p>
<h3 id="30-JDBC-编程有哪些不足之处，MyBatis-是如何解决这些问题的？"><a href="#30-JDBC-编程有哪些不足之处，MyBatis-是如何解决这些问题的？" class="headerlink" title="30    JDBC 编程有哪些不足之处，MyBatis 是如何解决这些问题的？"></a>30    JDBC 编程有哪些不足之处，MyBatis 是如何解决这些问题的？</h3><p>JDBC 编程的不足之处<br>数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。<br>Sql 语句写在代码中造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java 代码。<br>向 sql 语句传参数麻烦，因为 sql 语句的 where 条件不一定，可能多也可能少，占位符需要和参数一一对应。<br>对结果集解析麻烦，sql 变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成 pojo 对象解析比较方便。<br>MyBatis 的解决方案<br>在 SqlMapConfig.xml 中配置数据链接池，使用连接池管理数据库链接。<br>将 Sql 语句配置在 XXXXmapper.xml 文件中与 java 代码分离。<br>Mybatis 自动将 java 对象映射至 sql 语句。<br>Mybatis 自动将 sql 执行结果映射至 java 对象。</p>
<h3 id="31-MyBatis-的优缺点"><a href="#31-MyBatis-的优缺点" class="headerlink" title="31    MyBatis 的优缺点"></a>31    MyBatis 的优缺点</h3><p>优点<br>易于上手和掌握<br>Sql 写在 xml 里面，便于统一管理和优化<br>减少 Sql 与程序代码的耦合<br>提供 xml 标签，支持动态 Sql 编写<br>缺点<br>Sql 工作量大，尤其是字段多，关联表多时，更是如此<br>Sql 依赖于数据库，导致数据库移植性差<br>由于 xml 里面标签 id 必须唯一，导致 DAO 中方法不支持方法重载。所以 dao 层必须是接口</p>
<h3 id="32-使用-MyBatis-的-mapper-接口调用时有哪些要求？"><a href="#32-使用-MyBatis-的-mapper-接口调用时有哪些要求？" class="headerlink" title="32    使用 MyBatis 的 mapper 接口调用时有哪些要求？"></a>32    使用 MyBatis 的 mapper 接口调用时有哪些要求？</h3><p>Mapper 接口方法名和 mapper.xml 中定义的每个 sql 的 id 相同<br>Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个 sql 的 parameterType 的类型相同<br>Mapper 接口方法的输出参数类型和 mapper.xml 中定义的每个 sql 的 resultType 的类型相同<br>Mapper.xml 文件中的 namespace 即是 mapper 接口的类路径</p>
<h3 id="33-谈谈你对-SpringMVC-的理解"><a href="#33-谈谈你对-SpringMVC-的理解" class="headerlink" title="33    谈谈你对 SpringMVC 的理解"></a>33    谈谈你对 SpringMVC 的理解</h3><p> 是一个基于 MVC 的 web 框架</p>
<ol start="2">
<li><p>SpringMVC 是 Spring 的一个模块，是 Spring 的子容器，子容器可以拿父容器的东西，但是父容器不能拿子容器的东西</p>
</li>
<li><p>SpringMVC 的前端控制器 DispatcherServlet，用于分发请求，使开发变得简单</p>
</li>
<li><p>SpringMVC 流程（重点）. SpringMVC 三大组件</p>
<p>   1）HandlerMapping：处理器映射器</p>
<pre><code>     用户请求路径到 Controller 方法的映射
</code></pre>
<p>   2）HandlerAdapter：处理器适配器</p>
<pre><code>     根据 handler(controlelr 类）的开发方式（注解开发 / 其他开发） 方式的不同去寻找不同的处理器适配器
</code></pre>
<p>   3）ViewResolver：视图解析器</p>
<pre><code>     可以解析 JSP/freemarkerr/pdf 等
</code></pre>
<h3 id="34-简述-Mybatis-的插件运行原理，以及如何编写一个插件？"><a href="#34-简述-Mybatis-的插件运行原理，以及如何编写一个插件？" class="headerlink" title="34    简述 Mybatis 的插件运行原理，以及如何编写一个插件？"></a>34    简述 Mybatis 的插件运行原理，以及如何编写一个插件？</h3><p>答：1）Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这 4 种接口的插件，Mybatis 通过动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke() 方法，当然，只会拦截那些你指定需要拦截的方法。<br>2）实现 Mybatis 的 Interceptor 接口并复写 intercept() 方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p>
<h3 id="35-Mybatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？"><a href="#35-Mybatis-动态-sql-是做什么的？都有哪些动态-sql？能简述一下动态-sql-的执行原理不？" class="headerlink" title="35    Mybatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？"></a>35    Mybatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</h3><p>答：1）Mybatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能。2）Mybatis 提供了 9 种动态 sql 标签：trim|where|set|foreach|if|choose|when|otherwise|bind。<br>3）其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。</p>
<h3 id="36-Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#36-Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="36    Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>36    Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h3><p>答：1）Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled=true|false。</p>
</li>
</ol>
<p>2）它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke() 方法发现 a.getB() 是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName() 方法的调用。这就是延迟加载的基本原理。</p>
<h3 id="37-Mybatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？"><a href="#37-Mybatis-能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？" class="headerlink" title="37    Mybatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？"></a>37    Mybatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？</h3><p>答：能，Mybatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 selectOne() 修改为 selectList() 即可；多对多查询，其实就是一对多查询，只需要把 selectOne() 修改为 selectList() 即可。<br>关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。</p>
<h3 id="38-Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#38-Mybatis-是如何将-sql-执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="38    Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？"></a>38    Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</h3><p>答：第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。<br>第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，Mybatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，Mybatis 一样可以正常工作。</resultMap></p>
<h3 id="39-Mybatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？"><a href="#39-Mybatis-映射文件中，如果-A-标签通过-include-引用了-B-标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在-A-标签的前面？" class="headerlink" title="39    Mybatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？"></a>39    Mybatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？</h3><p>答：虽然 Mybatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。</p>
<h3 id="40-MyBatis-里面的动态-Sql-是怎么设定的？用什么语法？"><a href="#40-MyBatis-里面的动态-Sql-是怎么设定的？用什么语法？" class="headerlink" title="40    MyBatis 里面的动态 Sql 是怎么设定的？用什么语法？"></a>40    MyBatis 里面的动态 Sql 是怎么设定的？用什么语法？</h3><p>答：MyBatis 里面的动态 Sql 一般是通过 if 节点来实现，通过 OGNL 语法来实现，但是如果要写的完整，必须配合 where、trim 节点，where 节点是判断包含节点有内容就插入 where，否则不插入，trim 节点是用来判断如果动态语句是以 and 或 or 开始，那么会自动把这个 and 或者 or 取掉 。</p>
<h3 id="41-Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#41-Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="41    Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>41    Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h3><p>答：Mybatis 有三种基本的 Executor 执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。<br>SimpleExecutor：每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。<br>ReuseExecutor：执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。<br>BatchExecutor：执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch() 完毕后，等待逐一执行 executeBatch() 批处理。与 JDBC 批处理相同。<br>作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。</p>
<h3 id="42-为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？"><a href="#42-为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？" class="headerlink" title="42    为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？"></a>42    为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</h3><p>答：Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。<br>面试题看似都很简单，但是想要能正确回答上来，必定是研究过源码且深入的人，而不是仅会使用的人或者用的很熟的人，以上所有面试题及其答案所涉及的内容，在我的 Mybatis 系列博客中都有详细讲解和原理分析。</p>
<h3 id="43-简单介绍下你对-mybatis-的理解？"><a href="#43-简单介绍下你对-mybatis-的理解？" class="headerlink" title="43    简单介绍下你对 mybatis 的理解？"></a>43    简单介绍下你对 mybatis 的理解？</h3><pre><code> mybatis 配置
</code></pre>
<ol start="2">
<li>SqlMapConfig.xml，此文件作为 mybatis 的全局配置文件，配置了 mybatis 的运行环境等信息。</li>
<li>mapper.xml 文件即 sql 映射文件，文件中配置了操作数据库的 sql 语句。此文件需要在 SqlMapConfig.xml 中加载。</li>
<li>通过 mybatis 环境等配置信息构造 SqlSessionFactory 即会话工厂</li>
<li>由会话工厂创建 sqlSession 即会话，操作数据库需要通过 sqlSession 进行。</li>
<li>mybatis 底层自定义了 Executor 执行器接口操作数据库，Executor 接口有两个实现，一个是基本执行器、一个是缓存执行器。</li>
<li>Mapped Statement 也是 mybatis 一个底层封装对象，它包装了 mybatis 配置信息及 sql 映射信息等。mapper.xml 文件中一个 sql 对应一个 Mapped Statement 对象，sql 的 id 即是 Mapped statement 的 id。</li>
<li>Mapped Statement 对 sql 执行输入参数进行定义，包括 HashMap、基本类型、pojo，Executor 通过 Mapped Statement 在执行 sql 前将输入的 java 对象映射至 sql 中，输入参数映射就是 jdbc 编程中对 preparedStatement 设置参数。</li>
<li>Mapped Statement 对 sql 执行输出结果进行定义，包括 HashMap、基本类型、pojo，Executor 通过 Mapped Statement 在执行 sql 后将输出结果映射至 java 对象中，输出结果映射过程相当于 jdbc 编程中对结果的解析处理过程。<h3 id="44-介绍一下-Spring-的事物管理"><a href="#44-介绍一下-Spring-的事物管理" class="headerlink" title="44    介绍一下 Spring 的事物管理"></a>44    介绍一下 Spring 的事物管理</h3> 事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。</li>
</ol>
<p>开发中为了避免这种情况一般都会进行事务管理。Spring 中也有自己的事务管理机制，一般是使用 TransactionMananger 进行管 理，可以通过 Spring 的注入来完成此功能。<br>Spring 支持如下两种方式的事务管理：<br>编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。<br>声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者 XML 配置管理事务。<br>一般选择声明式事务管理，因为这种方式和应用程序的关联较少。</p>
<h3 id="45-SSM-优缺点、使用场景？"><a href="#45-SSM-优缺点、使用场景？" class="headerlink" title="45    SSM 优缺点、使用场景？"></a>45    SSM 优缺点、使用场景？</h3><p> Mybatis 和 hibernate 不同，它不完全是一个 ORM 框架，因为 MyBatis 需要程序员自己编写 Sql 语句，不过 mybatis 可以通过 XML 或注解方式灵活配置要运行的 sql 语句，并将 java 对象和 sql 语句映射生成最终执行的 sql，最后将 sql 执行的结果再映射生成 java 对象。</p>
<ol start="2">
<li><p>Mybatis 学习门槛低，简单易学，程序员直接编写原生态 sql，可严格控制 sql 执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是 mybatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套 sql 映射文件，工作量大。</p>
</li>
<li><p>Hibernate 对象 / 关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用 hibernate 开发可以节省很多代码，提高效率。但是 Hibernate 的学习门槛高，要精通门槛更高，而且怎么设计 O/R 映射，在性能和对象模型之间如何权衡，以及怎样用好 Hibernate 需要具有很强的经验和能力才行。</p>
</li>
<li><p>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。</p>
<h3 id="46-SpringMVC-的工作流程？"><a href="#46-SpringMVC-的工作流程？" class="headerlink" title="46    SpringMVC 的工作流程？"></a>46    SpringMVC 的工作流程？</h3><p>用户发送请求至前端控制器 DispatcherServlet<br>DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。<br>处理器映射器根据请求 url 找到具体的处理器，生成处理器对象及处理器拦截器（如果有则生成）一并返回给 DispatcherServlet。<br>DispatcherServlet 通过 HandlerAdapter 处理器适配器调用处理器<br>执行处理器 (Controller，也叫后端控制器）。<br>Controller 执行完成返回 ModelAndView<br>HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet<br>DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器<br>ViewReslover 解析后返回具体 View<br>DispatcherServlet 对 View 进行渲染视图（即将模型数据填充至视图中）。<br>DispatcherServlet 响应用户</p>
</li>
</ol>
<h3 id="47-如果你也用过-struts2-简单介绍下-springMVC-和-struts2-的区别有哪些？"><a href="#47-如果你也用过-struts2-简单介绍下-springMVC-和-struts2-的区别有哪些？" class="headerlink" title="47    如果你也用过 struts2. 简单介绍下 springMVC 和 struts2 的区别有哪些？"></a>47    如果你也用过 struts2. 简单介绍下 springMVC 和 struts2 的区别有哪些？</h3><p>springmvc 的入口是一个 servlet 即前端控制器，而 struts2 入口是一个 filter 过虑器。<br>springmvc 是基于方法开发（一个 url 对应一个方法），请求参数传递到方法的形参，可以设计为单例或多例（建议单例），struts2 是基于类开发，传递参数是通过类的属性，只能设计为多例。<br>Struts 采用值栈存储请求和响应的数据，通过 OGNL 存取数据， springmvc 通过参数解析器是将 request 请求内容解析，并给方法形参赋值，将数据和视图封装成 ModelAndView 对象，最后又将 ModelAndView 中的模型数据通过 reques 域传输到页面。Jsp 视图解析器默认使用 jstl。</p>
<h3 id="48-怎么样把数据放入-Session-里面"><a href="#48-怎么样把数据放入-Session-里面" class="headerlink" title="48    怎么样把数据放入 Session 里面"></a>48    怎么样把数据放入 Session 里面</h3><p>可以声明一个 request, 或者 session 先拿到 session, 然后就可以放入数据，或者可以在类上面加上 @SessionAttributes 注解，里面包含的字符串就是要放入 session 里面的 key</p>
<h3 id="49-讲下-SpringMvc-的执行流程"><a href="#49-讲下-SpringMvc-的执行流程" class="headerlink" title="49    讲下 SpringMvc 的执行流程"></a>49    讲下 SpringMvc 的执行流程</h3><p>系统启动的时候根据配置文件创建 spring 的容器，首先是发送 http 请求到核心控制器 DispatcherServlet，spring 容器通过映射器去寻找业务控制器，<br>使用适配器找到相应的业务类，在进业务类时进行数据封装，在封装前可能会涉及到类型转换，执行完业务类后使用 ModelAndView 进行视图转发，<br>数据放在 model 中，用 map 传递数据进行页面显示。</p>
<h3 id="50-MyBatis-IBatis-的好处是什么"><a href="#50-MyBatis-IBatis-的好处是什么" class="headerlink" title="50    MyBatis(IBatis) 的好处是什么"></a>50    MyBatis(IBatis) 的好处是什么</h3><p>ibatis 把 sql 语句从 Java 源程序中独立出来，放在单独的 XML 文件中编写，给程序的<br>维护带来了很大便利。<br>ibatis 封装了底层 JDBC API 的调用细节，并能自动将结果集转换成 JavaBean 对象，大大简化了 Java 数据库编程的重复工作。<br>因为 Ibatis 需要程序员自己去编写 sql 语句，程序员可以结合数据库自身的特点灵活控制 sql 语句，<br>因此能够实现比 hibernate 等全自动 orm 框架更高的查询效率，能够完成复杂查询。</p>
<h3 id="51-Bean-工厂和-Application-contexts-有什么区别？"><a href="#51-Bean-工厂和-Application-contexts-有什么区别？" class="headerlink" title="51    Bean 工厂和 Application contexts 有什么区别？"></a>51    Bean 工厂和 Application contexts 有什么区别？</h3><p>Application contexts 提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如镜像），它们可以向注册为监听器的 bean 发布事件。另外，在容器或容器内的对象上执行的那些不得不由 bean 工厂以程序化方式处理的操作，可以在 Application contexts 中以声明的方式处理。Application contexts 实现了 MessageSource 接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。</p>
<h3 id="52-解释-Spring-支持的几种-bean-的作用域"><a href="#52-解释-Spring-支持的几种-bean-的作用域" class="headerlink" title="52    解释 Spring 支持的几种 bean 的作用域"></a>52    解释 Spring 支持的几种 bean 的作用域</h3><p>Spring 框架支持以下五种 bean 的作用域：<br>singleton : bean 在每个 Spring ioc 容器中只有一个实例。<br>prototype：一个 bean 的定义可以有多个实例。<br>request：每次 http 请求都会创建一个 bean，该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。<br>session：在一个 HTTP Session 中，一个 bean 定义对应一个实例。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。<br>global-session：在一个全局的 HTTP Session 中，一个 bean 定义对应一个实例。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。<br>缺省的 Spring bean 的作用域是 Singleton。</p>
<h3 id="53-什么是-bean-的自动装配？"><a href="#53-什么是-bean-的自动装配？" class="headerlink" title="53    什么是 bean 的自动装配？"></a>53    什么是 bean 的自动装配？</h3><p>Spring 容器能够自动装配相互合作的 bean，这意味着容器不需要<constructor-arg>和<property>配置，能通过 Bean 工厂自动处理 bean 之间的协作。</property></constructor-arg></p>
<h3 id="54-什么是基于-Java-的-Spring-注解配置？给一些注解的例子。"><a href="#54-什么是基于-Java-的-Spring-注解配置？给一些注解的例子。" class="headerlink" title="54    什么是基于 Java 的 Spring 注解配置？给一些注解的例子。"></a>54    什么是基于 Java 的 Spring 注解配置？给一些注解的例子。</h3><p>基于 Java 的配置，允许你在少量的 Java 注解的帮助下，进行你的大部分 Spring 配置而非通过 XML 文件。<br>以 @Configuration 注解为例，它用来标记类可以当做一个 bean 的定义，被 Spring IOC 容器使用。另一个例子是 @Bean 注解，它表示此方法将要返回一个对象，作为一个 bean 注册进 Spring 应用上下文。</p>
<h3 id="55-使用-Spring-通过什么方式访问-Hibernate"><a href="#55-使用-Spring-通过什么方式访问-Hibernate" class="headerlink" title="55    使用 Spring 通过什么方式访问 Hibernate?"></a>55    使用 Spring 通过什么方式访问 Hibernate?</h3><p>在 Spring 中有两种方式访问 Hibernate：<br>控制反转 Hibernate Template 和 Callback。<br>继承 HibernateDAOSupport 提供一个 AOP 拦截器。</p>
<h3 id="56-如何通过-HibernateDaoSupport-将-Spring-和-Hibernate-结合起来？"><a href="#56-如何通过-HibernateDaoSupport-将-Spring-和-Hibernate-结合起来？" class="headerlink" title="56    如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？"></a>56    如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？</h3><p>用 Spring 的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：<br>配置 the Hibernate SessionFactory。<br>继承 HibernateDaoSupport 实现一个 DAO。<br>在 AOP 支持的事务中装配。</p>
<h3 id="57-Spring-框架的事务管理有哪些优点？"><a href="#57-Spring-框架的事务管理有哪些优点？" class="headerlink" title="57    Spring 框架的事务管理有哪些优点？"></a>57    Spring 框架的事务管理有哪些优点？</h3><p>它为不同的事务 API 如 JTA，JDBC，Hibernate，JPA 和 JDO，提供一个不变的编程模式。<br>它为编程式事务管理提供了一套简单的 API 而不是一些复杂的事务 API 如<br>它支持声明式事务管理。<br>它和 Spring 各种数据访问抽象层很好得集成。</p>
<h3 id="58-在-Spring-AOP-中，关注点和横切关注的区别是什么？"><a href="#58-在-Spring-AOP-中，关注点和横切关注的区别是什么？" class="headerlink" title="58    在 Spring AOP 中，关注点和横切关注的区别是什么？"></a>58    在 Spring AOP 中，关注点和横切关注的区别是什么？</h3><p>关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。<br>横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。</p>
<h3 id="59-AOP-作用是什么，底层如何实现在哪些地方会用到，分别简述切面，切入点和通知。"><a href="#59-AOP-作用是什么，底层如何实现在哪些地方会用到，分别简述切面，切入点和通知。" class="headerlink" title="59    AOP 作用是什么，底层如何实现在哪些地方会用到，分别简述切面，切入点和通知。"></a>59    AOP 作用是什么，底层如何实现在哪些地方会用到，分别简述切面，切入点和通知。</h3><p>AOP: 面向切面编程：将一个系统中共同的业务逻辑提取出来，进行单独的封装成一个组件（切面）, 然后以配置的方式作用于系统中，实现程序的可插拔性，提高代码的复用性，提升系统的灵活性和性能<br>底层实现：JDK 动态代理，只支持接口注入 CGLIB: 可以支持普通类的注入<br>那些地方会用到：事物开启，日志记录，安全验证，权限验证<br>切面：系统中共通的业务提取出来，在某个时刻或者某个阶段共同调用<br>切入点：找到目标方法，给它追加共通的业务逻辑，在 spring 中提供了切入点表达式帮助我们找到目标方法 execution<br>通知：什么时候调用这个共通的业务逻辑，用于指定切面方法作用到系统中的时机。前置通知，后置通知，环绕通知，异常通知，最终通知。</p>
<h3 id="60-Spring-中-AutoWired-和，Resource-之间区别是什么"><a href="#60-Spring-中-AutoWired-和，Resource-之间区别是什么" class="headerlink" title="60    Spring 中 AutoWired 和，Resource 之间区别是什么"></a>60    Spring 中 AutoWired 和，Resource 之间区别是什么</h3><p>AutoWried: 按照类型进行匹配—spring 框架自带的，查看当前 Spring 容器中那个 bean 类型和引用类型一致，就进行注入，如果有多个匹配类型就会报错。<br>Resource: 默认按照名称进行注入，如果找不到对应的名称按照 bean 类型进行注入</p>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/04/25/MySQL%E6%80%BB%E7%BB%931/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">MySQL 总结 (一)</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;评论</i>
    </div>
    

        
            
    <div class="valine-container">
        <script 
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
        <div id="vcomments"></div>
        <script >
            function loadValine() {
                new Valine({
                    el: '#vcomments',
                    appId: 'uusoui6cQCYvyLH6xdT2qgrO-gzGzoHsz',
                    appKey: 'UgHn5ltJEnt4uqclo2p9OkUM',
                    meta: ['nick', 'mail', 'link'],
                    avatar: 'wavatar',
                    enableQQ: true,
                    placeholder: 'welcome 评论~~~',
                    lang: 'zh-CN'.toLowerCase()
                });

                function getAuthor(language) {
                    switch (language) {
                        case 'en':
                            return 'Author';
                        case 'zh-CN':
                            return '博主';
                        default:
                            return 'Master';
                    }
                }

                // Add "Author" identify
                const getValineDomTimer = setInterval(() => {
                    const vcards = document.querySelectorAll('#vcomments .vcards .vcard');
                    if (vcards.length > 0) {
                        let author = 'notfornothing';

                        if (author) {
                            for (let vcard of vcards) {
                                const vnick_dom = vcard.querySelector('.vhead .vnick');
                                const vnick = vnick_dom.innerHTML;
                                if (vnick === author) {
                                    vnick_dom.innerHTML = `${vnick} <span class="author">${getAuthor(KEEP.hexo_config.language)}</span>`
                                }
                            }
                        }
                        clearInterval(getValineDomTimer);
                    } else {
                        clearInterval(getValineDomTimer);
                    }
                }, 2000);
            }

            if ('false') {
                const loadValineTimeout = setTimeout(() => {
                    loadValine();
                    clearTimeout(loadValineTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadValine);
            }
        </script>
    </div>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>1999</span>&nbsp;-&nbsp;
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">notfornothing</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
            <div class="icp-info info-item"><a target="_blank" rel="nofollow" href="https://beian.miit.gov.cn">湘 ICP 备 2022016732 号 - 1</a></div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%95%E4%B8%BA-Spring-Bean-%E5%AE%B9%E5%99%A8%EF%BC%9FSpring-Bean-%E5%AE%B9%E5%99%A8%E4%B8%8E-Spring-IOC-%E5%AE%B9%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%E5%90%97%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">1    何为 Spring Bean 容器？Spring Bean 容器与 Spring IOC 容器有什么不同吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Spring-IOC-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">2    Spring IOC 如何理解？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Spring-DI-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">3    Spring DI 如何理解？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Spring-%E4%B8%AD%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%AF%B9%E8%B1%A1%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">4    Spring 中基于注解如何配置对象作用域？以及如何配置延迟加载机制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Spring-%E5%B7%A5%E5%8E%82%E5%BA%95%E5%B1%82%E6%9E%84%E5%BB%BA-Bean-%E5%AF%B9%E8%B1%A1%E5%80%9F%E5%8A%A9%E4%BB%80%E4%B9%88%E6%9C%BA%E5%88%B6%EF%BC%9F%E5%BD%93%E5%AF%B9%E8%B1%A1%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%BA%86%E8%A6%81%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90%EF%BC%8C%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BD%95%E4%B8%BA%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">5    Spring 工厂底层构建 Bean 对象借助什么机制？当对象不使用了要释放资源，目的是什么？何为内存泄漏？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%8F%8F%E8%BF%B0-Spring-MVC-%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%BA%94%E7%94%A8%E4%BC%98%E5%8A%BF"><span class="nav-number">6.</span> <span class="nav-text">6    描述 Spring MVC 处理流程及应用优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Spring-%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">7.</span> <span class="nav-text">7    Spring 中的事务处理方式及优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-MyBatis-%E5%BA%94%E7%94%A8%E4%B8%AD-%E4%B8%8E-%E6%9C%89%E4%BB%80%E4%B9%88%E5%BC%82%E5%90%8C%E7%82%B9"><span class="nav-number">8.</span> <span class="nav-text">8    MyBatis 应用中#与 $ 有什么异同点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-MyBatis-%E5%BA%94%E7%94%A8%E5%8A%A8%E6%80%81-SQL-%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">9.</span> <span class="nav-text">9    MyBatis 应用动态 SQL 解决了什么问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-Shiro-%E6%A1%86%E6%9E%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E6%97%B6%E7%9A%84%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83%E6%B5%81%E7%A8%8B%E6%8F%8F%E8%BF%B0%E3%80%82"><span class="nav-number">10.</span> <span class="nav-text">10    Shiro 框架权限管理时的认证和授权流程描述。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-BeanFactory-%E5%92%8C-ApplicationContext-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">11.</span> <span class="nav-text">11    BeanFactory 和 ApplicationContext 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E8%AF%B7%E8%A7%A3%E9%87%8A-Spring-Bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">12    请解释 Spring Bean 的生命周期？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-Spring-Bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">13    Spring Bean 的作用域之间有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E5%9C%A8-Spring-AOP-%E4%B8%AD%EF%BC%8C%E5%85%B3%E6%B3%A8%E7%82%B9%E5%92%8C%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">14    在 Spring AOP 中，关注点和横切关注的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-%E4%BD%BF%E7%94%A8-Spring-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">15.</span> <span class="nav-text">15    使用 Spring 框架的好处是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-Spring-%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E9%82%A3%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">16    Spring 中用到了那些设计模式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-Spring-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81-Controller-%E5%B9%B6%E5%8F%91%E7%9A%84%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="nav-number">17.</span> <span class="nav-text">17    Spring 如何保证 Controller 并发的安全？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-%E4%BD%BF%E7%94%A8-Spring-%E6%A1%86%E6%9E%B6%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">18.</span> <span class="nav-text">18    使用 Spring 框架的好处是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-%E5%9C%A8-Spring-%E4%B8%AD%E5%A6%82%E4%BD%95%E6%B3%A8%E5%85%A5%E4%B8%80%E4%B8%AA-java-%E9%9B%86%E5%90%88%EF%BC%9F"><span class="nav-number">19.</span> <span class="nav-text">19    在 Spring 中如何注入一个 java 集合？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-Spring-%E6%94%AF%E6%8C%81%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E7%B1%BB%E5%9E%8B"><span class="nav-number">20.</span> <span class="nav-text">20    Spring 支持的事务管理类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-Spring-%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="nav-number">21.</span> <span class="nav-text">21    Spring 框架的事务管理有哪些优点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-Spring-MVC-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="nav-number">22.</span> <span class="nav-text">22    Spring MVC 的主要组件？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-SpringMvc-%E6%80%8E%E4%B9%88%E5%92%8C-AJAX-%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="nav-number">23.</span> <span class="nav-text">23    SpringMvc 怎么和 AJAX 相互调用的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-Mybatis-%E4%B8%AD-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">24.</span> <span class="nav-text">24    Mybatis 中#和 $ 的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-mybatis-%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%EF%BC%8C%E4%B8%80%E7%BA%A7%EF%BC%8C%E4%BA%8C%E7%BA%A7%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B"><span class="nav-number">25.</span> <span class="nav-text">25    mybatis 的缓存机制，一级，二级介绍一下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-pringMVC-%E4%B8%8E-Struts2-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">26.</span> <span class="nav-text">26    pringMVC 与 Struts2 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-mybatis-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">27.</span> <span class="nav-text">27    mybatis 的基本工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-%E4%BB%80%E4%B9%88%E6%98%AF-MyBatis-%E7%9A%84%E6%8E%A5%E5%8F%A3%E7%BB%91%E5%AE%9A%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84"><span class="nav-number">28.</span> <span class="nav-text">28    什么是 MyBatis 的接口绑定，有什么好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29-MyBatis-%E7%9A%84%E7%BC%96%E7%A8%8B%E6%AD%A5%E9%AA%A4"><span class="nav-number">29.</span> <span class="nav-text">29    MyBatis 的编程步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30-JDBC-%E7%BC%96%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84%EF%BC%8CMyBatis-%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98%E7%9A%84%EF%BC%9F"><span class="nav-number">30.</span> <span class="nav-text">30    JDBC 编程有哪些不足之处，MyBatis 是如何解决这些问题的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31-MyBatis-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">31.</span> <span class="nav-text">31    MyBatis 的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-%E4%BD%BF%E7%94%A8-MyBatis-%E7%9A%84-mapper-%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A6%81%E6%B1%82%EF%BC%9F"><span class="nav-number">32.</span> <span class="nav-text">32    使用 MyBatis 的 mapper 接口调用时有哪些要求？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-SpringMVC-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">33.</span> <span class="nav-text">33    谈谈你对 SpringMVC 的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34-%E7%AE%80%E8%BF%B0-Mybatis-%E7%9A%84%E6%8F%92%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6%EF%BC%9F"><span class="nav-number">34.</span> <span class="nav-text">34    简述 Mybatis 的插件运行原理，以及如何编写一个插件？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35-Mybatis-%E5%8A%A8%E6%80%81-sql-%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8A%A8%E6%80%81-sql%EF%BC%9F%E8%83%BD%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%8A%A8%E6%80%81-sql-%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86%E4%B8%8D%EF%BC%9F"><span class="nav-number">35.</span> <span class="nav-text">35    Mybatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#36-Mybatis-%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%94%AF%E6%8C%81%EF%BC%8C%E5%AE%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">36.</span> <span class="nav-text">36    Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#37-Mybatis-%E8%83%BD%E6%89%A7%E8%A1%8C%E4%B8%80%E5%AF%B9%E4%B8%80%E3%80%81%E4%B8%80%E5%AF%B9%E5%A4%9A%E7%9A%84%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E5%90%97%EF%BC%9F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">37.</span> <span class="nav-text">37    Mybatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#38-Mybatis-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B0%86-sql-%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%B0%81%E8%A3%85%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%9A%84%EF%BC%9F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%98%A0%E5%B0%84%E5%BD%A2%E5%BC%8F%EF%BC%9F"><span class="nav-number">38.</span> <span class="nav-text">38    Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39-Mybatis-%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C-A-%E6%A0%87%E7%AD%BE%E9%80%9A%E8%BF%87-include-%E5%BC%95%E7%94%A8%E4%BA%86-B-%E6%A0%87%E7%AD%BE%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E8%AF%B7%E9%97%AE%EF%BC%8CB-%E6%A0%87%E7%AD%BE%E8%83%BD%E5%90%A6%E5%AE%9A%E4%B9%89%E5%9C%A8-A-%E6%A0%87%E7%AD%BE%E7%9A%84%E5%90%8E%E9%9D%A2%EF%BC%8C%E8%BF%98%E6%98%AF%E8%AF%B4%E5%BF%85%E9%A1%BB%E5%AE%9A%E4%B9%89%E5%9C%A8-A-%E6%A0%87%E7%AD%BE%E7%9A%84%E5%89%8D%E9%9D%A2%EF%BC%9F"><span class="nav-number">39.</span> <span class="nav-text">39    Mybatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40-MyBatis-%E9%87%8C%E9%9D%A2%E7%9A%84%E5%8A%A8%E6%80%81-Sql-%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%BE%E5%AE%9A%E7%9A%84%EF%BC%9F%E7%94%A8%E4%BB%80%E4%B9%88%E8%AF%AD%E6%B3%95%EF%BC%9F"><span class="nav-number">40.</span> <span class="nav-text">40    MyBatis 里面的动态 Sql 是怎么设定的？用什么语法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#41-Mybatis-%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B-Executor-%E6%89%A7%E8%A1%8C%E5%99%A8%EF%BC%9F%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">41.</span> <span class="nav-text">41    Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4-Mybatis-%E6%98%AF%E5%8D%8A%E8%87%AA%E5%8A%A8-ORM-%E6%98%A0%E5%B0%84%E5%B7%A5%E5%85%B7%EF%BC%9F%E5%AE%83%E4%B8%8E%E5%85%A8%E8%87%AA%E5%8A%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="nav-number">42.</span> <span class="nav-text">42    为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8B%E4%BD%A0%E5%AF%B9-mybatis-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-number">43.</span> <span class="nav-text">43    简单介绍下你对 mybatis 的理解？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-Spring-%E7%9A%84%E4%BA%8B%E7%89%A9%E7%AE%A1%E7%90%86"><span class="nav-number">44.</span> <span class="nav-text">44    介绍一下 Spring 的事物管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#45-SSM-%E4%BC%98%E7%BC%BA%E7%82%B9%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-number">45.</span> <span class="nav-text">45    SSM 优缺点、使用场景？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#46-SpringMVC-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="nav-number">46.</span> <span class="nav-text">46    SpringMVC 的工作流程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#47-%E5%A6%82%E6%9E%9C%E4%BD%A0%E4%B9%9F%E7%94%A8%E8%BF%87-struts2-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8B-springMVC-%E5%92%8C-struts2-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">47.</span> <span class="nav-text">47    如果你也用过 struts2. 简单介绍下 springMVC 和 struts2 的区别有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#48-%E6%80%8E%E4%B9%88%E6%A0%B7%E6%8A%8A%E6%95%B0%E6%8D%AE%E6%94%BE%E5%85%A5-Session-%E9%87%8C%E9%9D%A2"><span class="nav-number">48.</span> <span class="nav-text">48    怎么样把数据放入 Session 里面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#49-%E8%AE%B2%E4%B8%8B-SpringMvc-%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">49.</span> <span class="nav-text">49    讲下 SpringMvc 的执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#50-MyBatis-IBatis-%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">50.</span> <span class="nav-text">50    MyBatis(IBatis) 的好处是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#51-Bean-%E5%B7%A5%E5%8E%82%E5%92%8C-Application-contexts-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">51.</span> <span class="nav-text">51    Bean 工厂和 Application contexts 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#52-%E8%A7%A3%E9%87%8A-Spring-%E6%94%AF%E6%8C%81%E7%9A%84%E5%87%A0%E7%A7%8D-bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">52.</span> <span class="nav-text">52    解释 Spring 支持的几种 bean 的作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#53-%E4%BB%80%E4%B9%88%E6%98%AF-bean-%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%EF%BC%9F"><span class="nav-number">53.</span> <span class="nav-text">53    什么是 bean 的自动装配？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#54-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%BA%E4%BA%8E-Java-%E7%9A%84-Spring-%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%EF%BC%9F%E7%BB%99%E4%B8%80%E4%BA%9B%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BE%8B%E5%AD%90%E3%80%82"><span class="nav-number">54.</span> <span class="nav-text">54    什么是基于 Java 的 Spring 注解配置？给一些注解的例子。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#55-%E4%BD%BF%E7%94%A8-Spring-%E9%80%9A%E8%BF%87%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E8%AE%BF%E9%97%AE-Hibernate"><span class="nav-number">55.</span> <span class="nav-text">55    使用 Spring 通过什么方式访问 Hibernate?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#56-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-HibernateDaoSupport-%E5%B0%86-Spring-%E5%92%8C-Hibernate-%E7%BB%93%E5%90%88%E8%B5%B7%E6%9D%A5%EF%BC%9F"><span class="nav-number">56.</span> <span class="nav-text">56    如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#57-Spring-%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="nav-number">57.</span> <span class="nav-text">57    Spring 框架的事务管理有哪些优点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#58-%E5%9C%A8-Spring-AOP-%E4%B8%AD%EF%BC%8C%E5%85%B3%E6%B3%A8%E7%82%B9%E5%92%8C%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">58.</span> <span class="nav-text">58    在 Spring AOP 中，关注点和横切关注的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#59-AOP-%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E4%BC%9A%E7%94%A8%E5%88%B0%EF%BC%8C%E5%88%86%E5%88%AB%E7%AE%80%E8%BF%B0%E5%88%87%E9%9D%A2%EF%BC%8C%E5%88%87%E5%85%A5%E7%82%B9%E5%92%8C%E9%80%9A%E7%9F%A5%E3%80%82"><span class="nav-number">59.</span> <span class="nav-text">59    AOP 作用是什么，底层如何实现在哪些地方会用到，分别简述切面，切入点和通知。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#60-Spring-%E4%B8%AD-AutoWired-%E5%92%8C%EF%BC%8CResource-%E4%B9%8B%E9%97%B4%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">60.</span> <span class="nav-text">60    Spring 中 AutoWired 和，Resource 之间区别是什么</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":180,"vOffset":35},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body>
</html>
