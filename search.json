[{"title":"Git冲突处理","url":"/2021/09/15/Git%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/","content":"Git 冲突处理缘故\n最开始经历过学 Git，玩着玩着把代码弄丢了的事情。然后当时也没深究。也知道一些大概：遇事别急，只要你 commit 了，代码就不会跑，所以没事就 git add ./ , git commit -m &quot;like a shit&quot;。\n以前也是一个人玩，很少遇到冲突基本上没有，也只是了解过冲突的部分概念。后面了解到 gitflow 工作流。也逐渐明白：别在主分支上乱搞，自己拉的分支随便你怎么处理。体会到了 git 的魅力，C 语言指针思想深入人心。Linus 看起来很酷。\n\n\ngitlab 叫 merge request\ngithub 叫 pull request\n\n\n在此之前，我所知道的就是：\n拉分支 ==&gt; 做需求 ==&gt; 本地自测没问题 ==&gt; 把本地推到远程分支 ==&gt; 提交发起合并请求\n\n\n经过一次在和长沙的技术组长：黄哥！在一起写一个项目的代码的时候。因为我们都是修改的同一个文件。然后过来问我进度怎么样了。\n由于我采用最保守的方式。从本地拉分支再进行修改。BTW，我知道 commit 很多会在 git 历史上很丑，一条线几个节点，巨丑无比。因为刚入手这个项目组，然后他过来看我改了哪些地方。我说我还没 commit（我怕还要改，因为 commit 太多了很丑）。\n\n然后他让我切到主分支上去。然后我就跟他争论说，我担心 checkout 后代码会丢了。\n他说不会：不 commit 的话，切换分支你修改的是会跟着你走的，commit 相当于绑定上这个分支了。\n\n结果经过组长的讲解，我觉得他这种方法特别的好。\n\n先在主分支上做代码开发\n（如果有急事要到另一个分支可以 git stash 存储修改的代码快照到当前分支，git pop 弹出修改的代码）\n\n\n假如需求自测没问题了。拉一下主分支的最新代码，如果有冲突会在本地解决掉。\n解决冲突后，按照提交规范，新建需求分支并 checkout.\ncommit，推送远程仓库。\n最后在远程合并。\n\n\n通过上述步骤，冲突基本上能在本地解决。\n但是聪明的我脑洞大开：如果我在上述第四步：\n\n新建分支 commit 后，别人同一时间也 commit 了同一文件并比我早一步合并远程分支。那我推送远程的代码照样会冲突禁止合并。\n\n接下来我们可以在本地主分支拉取最新的代码，就是导致你冲突的代码。\n\n然后在 checkout 到当前需求分支\n\n在需求分支 git merge --on-ff 主分支 。把最新的主分支合并到开发分支。此时会提示冲突，就可以在本地解决冲突了。\n\ngit merge –on-ff 是 no fast-forward，即禁止快速合并关闭 fast-forward 模式，在提交的时候，会创建一个 merge 的 commit 信息，能更清晰显示冲突的问题。\n\n\n解决冲突后推送代码\n\n\n活到老学到老！奥利给！"},{"title":"JQuery动态获取input值","url":"/2021/04/29/JQuery%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96input%E5%80%BC/","content":"JQ 如何实现动态获取 input value 值$(RiskCode[0]).bind(&quot;input propertychange&quot;, () =&gt; &#123;    if ($(RiskCode[0]).val().length === 4) &#123;        btn_submit[0].click();    &#125;&#125;);\n\n\nJS 如何实现动态获取 input value 值\n\n\n\n"},{"title":"Java 泛型擦除","url":"/2022/08/16/Java-%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4/","content":""},{"title":"JavaSE 总结","url":"/2021/06/20/JavaSE%E6%80%BB%E7%BB%93/","content":"面试总结：Java 内存分区图解（点击展开）\n\n\n\n\n\njava jvm 内存模型\n\nJVM 分区？根据上一个问题得，堆区是用来存放创建对象的地方，堆区的清理需要 JVM 的垃圾收集器清理。\nGCRoot– 栈 / 本地方法栈 / 方法区域\n被 GCRoot 直接或者间接引用的对象是不能被删除的\n\n\n孤立存在的对象，没有和 GCRoot 有直接的关系。这些对象可以被删除\n\n垃圾回收算法\n标记清理 – 标记存活的对象，清理未被标记的对象\n缺点：会产生内存碎片，如果你删除了两个连续的 1KB 的对象。来一个 2KB 的对象放不下那个地方，所以会有内存碎片。\n\n\n标记整理 – 在上面基础上把清理之后。后面的对象补上来，紧凑。\n缺点：代价大，所有对象会前移，补空缺的内存碎片。\n\n\n复制算法 – 将整个内存一分为二，不需要删除的复制到另一边。\n缺点：需要内存空间大。\n\n\n\nJVM 分区young 区 – 也叫新生代\n内部又分为 Eden 区域，作为对象初始分配的区域还有两个 Survivor（也叫幸存区），有时候也叫 from、to 区域，被用来放置从 young GC（也叫 Minor GC ,Eden 区满了就会触发） 中保留下来的对象。young GC 采用的是复制算法。\n\n每一次 young GC 后，对象的年龄就会加一，然后超过 6 次。就会到 old 区 , 然后大的对象 (Integer.maxValue) 也会直接存到 old 区，因为前面不容易啊！\nold 区 – 也叫老年代\n标记清理和标记整理主要用于 old GC .\nold GC 一般会同时伴随 young GC. 称为 Full GC.\nFull GC 会引起 Java 程序暂停，应该尽量减少次数。\n\nPermanent 区 – 永久代？\n永久代在 JDK 7 中逐渐变化，到 JDK 8 之后完全消失，合并到了 Native 堆中\n\n图解（点击展开）\n\n\n\n\n\nGC 过程\nJava 中的 ==, equals 与 hashCode 的区别与联系\nequals()一般把常量写 前面 即 “常量”.equals() 防止空指针异常\n\n初衷：就是判断两个对象的 content 是否相同。\n\n\nObjects 类：\n\npublic boolean equals(Object obj) &#123;        return (this == obj);    &#125;\n\n\nObjects 的意思是判断两个对象是否相同\n很显然，在 Object 类中，equals 方法是用来比较两个对象的引用是否相等，即是否指向同一个对象。\n\n\n但是我们知道：\nString str1 = new String(&quot;hello&quot;);// 这里指向不同的 helloString str2 = new String(&quot;hello&quot;);// 这里指向不同的 hello 却是 trueSystem.out.println(str1.equals(str2));//ture\n\n这是因为 String 重写了 equals() 方法：\n\nString 类：（重写了 equals 方法） 不需要看懂\n\n// 源码：public boolean equals(Object anObject) &#123;        if (this == anObject) &#123;// 先比较引用类型是否相同（即是佛为同一对象）            return true;        &#125;        if (anObject instanceof String) &#123;// 在判断类型是否一致            String anotherString = (String)anObject;            int n = value.length;            if (n == anotherString.value.length) &#123;                char v1[] = value;                char v2[] = anotherString.value;                int i = 0;                while (n-- != 0) &#123;                    if (v1[i] != v2[i])// 最后比较内容是否一致                        return false;                    i++;                &#125;                return true;            &#125;        &#125;        return false;    &#125;\n\nJava 中所有内置的类的 equals 方法的实现步骤均是如此，特别是诸如 Integer，Double 等包装器类。\n\n一般分为三个步骤：\n先比较引用类型是否相同（即是佛为同一对象）\n在判断类型是否一致\n最后比较内容是否一致\n\n\n\n\n\n\n判断数组是不是对象\npublic static void main(String[] args) &#123;    System.out.println(&quot;判断数组是否是对象？&quot;);    char[] chars = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;&#125;;    System.out.println(chars);// 这是字符数组的特性    // 可以理解为指向的第一个数组的地址    int[] ints = &#123;1, 2, 3, 4, 5, 6, 7&#125;;    System.out.println(ints);// 这样就不行了，没有重写 toString 方法    if (chars instanceof Object) &#123;        System.out.println(&quot;数组是对象&quot;);// 输出为这个    &#125; else &#123;        System.out.println(&quot;数组不是对象&quot;);    &#125;&#125;\n\n关于 toString() 方法\nObject 类：\n\npublic String toString() &#123;       return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());   &#125;\n\n这样比较 hashCode() 没有意义。因为我们要的是比较里面的 String 或者说是实质性的东西\n\nString 类：\n\npublic String toString() &#123;    return this;&#125;\n\nString 类重写了 toString 方法\n\n数组类：\nint[] ints =new int[10]\nchar[] chars=new char[10]\n\nchar[] chars = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;&#125;;System.out.println(chars);//abcdefg// 这是字符数组的特性// 可以理解为指向的第一个数组的地址int[] ints = &#123;1, 2, 3, 4, 5, 6, 7&#125;;System.out.println(ints);// 这样就不行了，没有重写 toString 方法\n\n数组类没有重写 toString( )  chars 数组可以打印是因为 chars 指向第一个数组的地址\n\n包装类\nInteger 的两种构造方法：\n\n\n\n\n\nConstructor and Description\n\n\n\nInteger(int value)  构造一个新分配的 Integer对象，该对象表示指定的 int值。\n\n\nInteger(String s)  构造一个新分配 Integer对象，表示 int由指示值  String参数。\n\n\n\n\n\n\n\nInteger 在给 -128 到 127 用高效的效果 相同的数据存一次\n但是在其他范围内存的是两个对象 (只要 Integer 有这个高效)\n\n\nInteger i=1;等价于Integer i=Integer.valueOf(1);\n\n关于 Integer 的高效：了解即可 ==&gt;由此去源代码\n\n```java\nprivate static void integerTest2() &#123;\n    Integer i1 = Integer.valueOf((int)666);\n    Integer i2 = Integer.valueOf((int)666);\n    Integer i3 = new Integer((int) 666);\n    Integer i4 = new Integer((int) 666);\n    System.out.println(i1==i2);//false\n    System.out.println(i3==i4);//false\n&#125;\n\nprivate static void integerTestEqual() &#123;\n    Integer i1 = Integer.valueOf((int)6);\n    Integer i2 = Integer.valueOf((int)6);\n    Integer i3 = new Integer((int) 6);\n    Integer i4 = new Integer((int) 6);\n    System.out.println(i1==i2);//true\n    System.out.println(i3==i4);//false\n&#125;\n\npublic static void integerTest() &#123;\n    Integer i1=  6;\n    Integer i2 = 6;\n    Integer i3 = new Integer(6);\n    Integer i4 = new Integer(6);\n    System.out.println(i1 == i2);//true\n    System.out.println(i3 == i4);//false\n&#125;\n\n   public static void main(String[] args) {\n    integerTest();\n    integerTest2();\n    System.out.println(&quot;=========|&quot;);\n    // 为什么会输出 true  false\n    // 下面的是反编译，这是\n    integerTestEqual();\n    // 可以看到 i1 i2 以自动装箱的方式创建\n    //i3  i4 以构造方法的方式创建\n\n    // 那为啥会有 true 返回呢？\n    // 因为 Integer 在 valueOf() 第一次 调用时。会创建 -128~127 直接的实例\n    // 加到缓存，后续调用 valueOf 方法时，会返回缓存中的实例。\n    // 所以指向同一内存地址 为 true.\n    // 所以 integerTest2 超过了 127 的最大值。你自己可以进 valueOf 方法里看。\n&#125;\n\n### String重写了 equals 方法和 toString 方法sout 默认打印的是他的 toString 方法---String =&quot; &quot;  和 String str=new String(&quot; &quot;) 的区别 ==&gt;[StringTest.java](https://github.com/notfornothing/JavaSE/blob/main/JavaSE_Basic_Basic/src/cn/leijiba/day11/StringTest.java)&gt; [基于 == 判断的，因为 == 是比较的地址值.](https://blog.csdn.net/justloveyou_/article/details/52464440)```javapublic static void main(String[] args) &#123;    /** String=&quot;&quot;  和 String s=new String(&quot;string&quot;) 的区别*/    String str1 = &quot;abcd&quot;;    String str2 = &quot;abcd&quot;;    System.out.println(str1==str2);//true    // 因为 String str1 = &quot;abcd&quot;的实现过程：    // 首先栈区创建 str 引用，然后在 String 池（独立于栈和堆而存在，存储不可变量）    // 中寻找其指向的内容为&quot;abcd&quot;的对象，如果 String 池中没有，则创建一个，    // 然后 str 指向 String 池中的对象，如果有，则直接将 str1 指向&quot;abcd&quot;&quot;；   // 如果后来又定义了字符串变量 str2 = &quot;abcd&quot;,    // 则直接将 str2 引用指向 String 池中已经存在的“abcd”，不再重新创建对象；    System.out.println(&quot;============&quot;);    str1 = &quot;abc&quot;;    String str3 = &quot;abc&quot;;    System.out.println(str1 == str3);//true    // 当 str1 进行了赋值（str1=“abc”），则 str1 将不再指向&quot;abcd&quot;，    // 而是重新指 String 池中的&quot;abc&quot;，此时如果定义 String str3 = &quot;abc&quot;,    // 进行 str1 == str3 操作，返回值为 true，因为他们的值一样，地址一样    System.out.println(&quot;============&quot;);    str1 = str3 + &quot;d&quot;;    System.out.println(str2 == str1);//false    System.out.println(str2.equals(str1));//true    // 内容为&quot;abc&quot;的 str1 进行了字符串的 + 连接 str1 = str1+&quot;d&quot;；    // 此时 str1 指向的是在堆中新建的内容为&quot;abcd&quot;的对象，*************这是重点    // 即此时进行 str1==str2，返回值 false，因为地址不一样。但是值一样    System.out.println(&quot;=================&quot;);    System.out.println(&quot;以下是区别&quot;);    String str4 = new String(&quot;abcd&quot;);    String str5 = new String(&quot;abcd&quot;);    System.out.println(str4 == str5);//false    System.out.println(str4.equals(str5));//true    //String str4 = new String(&quot;abcd&quot;) 的实现过程：    // 直接在堆中创建对象。如果后来又有 String str5 = new String(&quot;abcd&quot;)，    // str5 不会指向之前的对象，而是重新创建一个对象并指向它，    // 所以如果此时进行 str3==str4 返回值是 false，因为两个对象的地址不一样，    // 如果是 str3.equals(str4)，返回 true, 因为内容相同。&#125;\n\nString 常用 API—————– 不用记下来，有印象就行\n\n\ncharAt\nconcat – 拼接，但不改变原字符串\nendsWith\nstartsWith\nequals\nindexOf\nlastIndexOf\nlength\ntoUpperCase\ntoLowerCase\nsplit – 切割\nvalueOf – int 转 String\ntrim – 去掉头尾空格\ngetBytes – 转成 byte[]\nsubString – 截取子串 左闭右开 [)\n\n对于 String 的这些方法：\n可以用字符串常量来解释：所以他返回的值是变的\n&quot;abcdefg&quot;.substring(2, 6);\n\nString 和 StringBuffer 和 String\n目前只知道 String 拼接字符串 比其他两个很耗时间和内存\n用 System.currentTimeMillis() 两个相减得到的\n思考 成员变量为自定义的类型，那么 equals 是否调用该成员变量的 equals 方法呢？toString 呢？\n是的，所以应该重写 equals 和 toString\n\n其中 toString 调用的是 hashCode 的默认。所以应该重写才好\n\n重写的 equals 调用的是基本数据类型的是用 ==. 引用数据类型调用的是 Objects.equals(a,b)\n\n我看了一下他的实现，就是去调用 a 的 equals 方法。所以说要重写才好。免得到时候 equals 判断半天还不等于。免得踩坑\n\n\n\n下面有关于 Objects 的 quals 方法\nStringbuffer 是线程安全的：\n他是从 JDK1.0 版本就有的，他是线程安全StringBuffer 源码有:\n@Overridepublic synchronized int length() &#123;    return count;&#125;@Overridepublic synchronized int capacity() &#123;    return value.length;&#125;@Overridepublic synchronized void ensureCapacity(int minimumCapacity) &#123;    if (minimumCapacity &gt; value.length) &#123;        expandCapacity(minimumCapacity);    &#125;&#125;\n\n\nStringbuilder 不是线程安全的\n\n从版本 JDK 5 开始，这个类别已经被一个等级类补充了，这个类被设计为使用一个线程 Stringbuilder 类，Stringbuilder 应该使用 Stringbuilder 类，因为它支持所有相同的操作，但它更快，因为它不执行同步。\n\nStringbuilder 没有 synchronized 锁 ,所以他不是线程安全的.\n\n好像还有一个 Objects 类\n主要用到的是 Objects 类的 Objects.equals\npublic static boolean equals(Object a, Object b) &#123;    return (a == b) || (a != null &amp;&amp; a.equals(b));&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSpring AOP 几种通知？MySQL 四种特性？MySQL 赃读，幻读那些Spring 的注解有哪些（注意不是 SpringBoot 的）业务：SpringBoot 中返回一个 JSON, 和重定向应该怎么使用？String , StringBuffer , StringBuilder 区别SpringMVC 流程多线程状态图解（点击展开）\n\n\n\n\nhashMap 底层原理DEBUG 代码探究其原理（点击展开） \n\n//DEBUG 代码探究其原理：package cn.leijiba.hashTest;import java.util.HashMap;import java.util.Map;import java.util.UUID;public class Test1 &#123;    public static void main(String[] args) &#123;        test();    &#125;    private static void test() &#123;        Map&lt;SimpleBO, String&gt; stringMap = new HashMap&lt;&gt;();        for (int i = 0; i &lt; Integer.MAX_VALUE; i++) &#123;            if (i &lt; 7) &#123;                stringMap.put(new SimpleBO(&quot;test&quot; + i), &quot;test&quot; + i);            &#125; else if (i &lt;= 45) &#123;                stringMap.put(new SimpleBO(&quot;test&quot; + i), &quot;test&quot; + i);            &#125; else &#123;                stringMap.put(new SimpleBO(&quot;test&quot; + i), &quot;test&quot; + i);            &#125;        &#125;    &#125;&#125;class SimpleBO &#123;    private String name;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public SimpleBO(String name) &#123;        this.name = name;    &#125;    @Override    public boolean equals(Object o) &#123;        if (this == o) return true;        if (o == null || getClass() != o.getClass()) &#123;            return false;        &#125; else &#123;            return false;        &#125;    &#125;    public int hashCode() &#123;        String replace = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);        char[] chars = replace.toCharArray();        StringBuilder stringBuilder = new StringBuilder();        for (char aChar : chars) &#123;            if (aChar &gt; &#x27;0&#x27; &amp;&amp; aChar &lt; &#x27;9&#x27;) &#123;                stringBuilder.append(aChar);            &#125;        &#125;        String s = stringBuilder.toString();        if (s.length() &gt; 6) &#123;            s = s.substring(0, 5);        &#125;        System.out.println(s);        return Integer.parseInt(s);    &#125;&#125;\n\n\n\n\nhashMap 树化得同时满足：\n\n链接长度 &gt; 8\n数组长度为 64\n\n\nhashMap  当总元素个数 &gt; 数组长度*0.75 会扩容 rehash(), 但是下面还有一种情况。\n\nhashMap 当总元素没有达到 当前数组长度*0.75 且 数组长度 &lt; 64 时 ，有一个数组地址哈希冲突了，形成链表。在这前提下如果哈希冲突的元素达到 8，在插入第 9 个哈希冲突的元素时。数组会扩容到两倍（即长度向左移一位），而且不会形成红黑树，而是扩容 rehash(). 当第一种情况满足才会红黑树。\n\nhashMap 扩容源码讲解\n\nhashMap 变红黑树必须同时满足链表》8 和数组 ==64 才会变红黑树\n\n\n"},{"title":"MySQL 总结 (一)","url":"/2021/04/25/MySQL%E6%80%BB%E7%BB%931/","content":"MySQL 相关desc 表名describe– 描述\ndescend– 下降\n\n\ndescibe 是查看表的结构，例：\ndescribe tablename;\n\ndesc 是 describe 的简写，例：\ndesc tablename;\n\n\n\n另外 desc 在排序中的意义是降续排列（和 describe 的简写不是同一个），例：\nselect * from table order by id  desc ;\n\n关于 where\n\nupdate stu set score=22 [where id=1]\n\n如果不加 where 那么修改的是全局的\n\n\ndelete from stu [where id =1]\n\n如果不加 where 那么删除的是全部的 所以要注意\n\nselect 中的 distinct–distinct  adj.  清晰的；清楚的；明白的；明显的；截然不同的；有区别的；不同种类的；确定无疑的；确实的；确切的；\n\nselect distinct  gender from emp\n\n\n\nNull 和仍和数据运算结果都是 null, 以及有关 null 的运算\nSELECT NAME\t,\tsal + bonusFROM\tempWHERE\tsal + bonus &gt; 3500\n\n\n问题: 其中有一条数据 A 的 bonus 为 null, 但是他的 sal &gt;3500 了已经。我们要求能把 null=0 最好，而且查出来。\n\n方法 1: 将所有的奖金为 null 的列更新为 0\nupdate emp set bonus =0 where bonus is null;update emp set bonus =0 where bonus is not null;\n\nSELECT * from emp WHERE dept is not nullSELECT * from emp WHERE not (dept is  null)\n\n\n\n方法 2: 在查询时将 null 值 看做 0 来处理（这种方式不会对表中的数据产生仍和影响）\nifnull（列名，值） 函数：判断指定的列是否包含 null, 若果有 null 就用第二个值 替换。ifnull(bonus,0)\nSELECT NAME\t,\tIFNULL(bonus,0) + salFROM\tempWHEREIFNULL(bonus,0) + sal &gt; 3500\n\n\n取别名的问题\n模糊查询 LIKE\nlike 操作符 用在 WHERE 子句中搜索列中的指定模式。\n\n可以和 % _ 使用。\n其中 % 代表0 个或者多个任意字符，_代表一个任意字符。\n\n多行函数查询– 多行函数也叫聚合函数，也叫聚集函数\n多行函数会默认过滤 null 值 , 即不统计 null 值\n\ncount（列名 | *):                  | 是或的意思\n\ncount（列名）: 表示统计当前列有多少个值count(*): 以行为单位，统计查询结果中有多少行记录\n\nmax（列名）:min（列名）:sum（列名）: 统计这一列中所有值的和 (会过滤 null 值) 参考上面的avg（列名）: 会过滤 null 值（所有值的和 / 不是 null 值的个数）\n\n在统计时，不要加格外的列，因为没有任何意义\n\nSELECT\tCOUNT( * ),\t`name`FROM\tEMPWHERE\tEMP.sal &gt; 3000-- 如果没有分组 在进行统计时，不要添加格外的列，因为没有任何意义（这里的 name 只会将第一行的 name 显示出来）\n\nSELECT\tmax( sal ),\t`name`FROM\tEMPWHERE\tEMP.sal &gt; 3000-- 所以这里的 name 不能认为是最高薪资的那一个人，-- 如果没有分组，那么最高薪资和姓名没有任何关系，薪资是所有薪资的最大值，但是 name 就是结果中的第一行的 name\n\nSELECT\tsum( bonus )FROM\temp-- 如果 bonus 是里面有 null 的话会过滤掉。前面说了的。不会参与统计\n\n\navg 是剔除了为 null 的 count 的那条记录的平均值，那一行不算在内\n\n分组查询group by\n\nselect count(*) from emp;– 如果没有分组，\n升序和降序\nDESC 是 descend 降序意思ASC 是 ascend 升序的意思 默认是 ASC\n分页查询limit\n\n删除的区别\ndelete，drop，truncate 都有删除表的作用，区别在于：\n\ndelete 和 truncate 仅仅删除表数据，所以会保存字段名，drop 连表数据和表结构一起删除，打个比方，delete 是单杀，truncate 是团灭，drop 是把电脑摔了。\ndelete 是 DML 语句，操作完以后如果没有不想提交事务还可以回滚，truncate 和 drop 是 DDL 语句，操作完马上生效，不能回滚，打个比方，delete 是发微信说分手，后悔还可以撤回，truncate 和 drop 是直接扇耳光说滚，不能反悔。\n执行的速度上，drop&gt;truncate&gt;delete，打个比方，drop 是神舟火箭，truncate 是和谐号动车，delete 是自行车。\n\nvarchar 和 char\n区别一，定长和变长\n\nchar 表示定长，长度固定，varch ar 表示变长，即长度可变。char 如果插入的长度小于定义长度时，则用空格填充；varchar 小于定义长度时，还是按实际长度存储，插入多长就存多长。\n\n\n 因为其长度固定，char 的存取速度还是要比 varchar 要快得多，方便程序的存储与查找；但是 char 也为此付出的是空间的代价，因为其长度固定，所以会占据多余的空间，可谓是以空间换取时间效率。varchar 则刚好相反，以时间换空间。\n\n区别之二，存储的容量不同\n\n对 char 来说，最多能存放的字符个数 255，和 编码无关。而 varchar 呢，最多能存放 65532 个字符。varchar 的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是 65,532 字节。\n\n区别之三，空格\nchar 在存储的时候会将右侧空格进行剔除，保留左侧空格。varchar 在存储的时候保留所有空格，不进行任何删除\nvarchar 和 char 在查询的时候都只会根据 where 条件中的左侧空格进行判断，右侧末尾的空格会忽略\n自增auto_increment\n\n可以用 show create  table emp\n\n 设置完主键自增后，表中会维护一个 AUTO_INCREMENT 的值，这个值从1开始。如果插入的那一列没有给主键赋值。那就是从 AUTO_INCREMENT 获取值。用完后自加 1.  所以查看具体的最下面有一个 auto_increment= 多少；\n\n注意：\n\nauto_increment 会安照 最大 的去自增。\n\n主键约束\n唯一，非空。一般和 auto_increment 一起用\n非空约束\n非空，但是可以重复\n唯一约束 –unique\n不能重复，可以为 null\n连接查询\nSELECT *  from emp,dept\n\n以上有笛卡尔积。\n消除笛卡尔积 用inner join 内连接. 把逗号，改成 inner join where 改成 on\nSELECT  * from emp INNER JOIN dept on emp.dept_id=dept.idSELECT  * from dept INNER JOIN emp on emp.dept_id=dept.id\n\n以上两种都可以。但是 null 值不会显示出来\n可以用左外连接和右外连接：\n\n左外连接。查询左边的所以值\n右外连接：查询右边所有的值\n\n显示所有部门对应的员工值\nSELECT  * from dept left JOIN emp on emp.dept_id=dept.idSELECT  * from emp right JOIN dept on emp.dept_id=dept.id\n\n显示所有员工对应的部门值\nSELECT  * from dept right JOIN emp on emp.dept_id=dept.idSELECT  * from emp LEFT  JOIN dept on emp.dept_id=dept.id\n\n这样不能查询所以的对应的 null 值\n而且 mysql 没有全外连接查询。\n可以通过 union 模拟这种查询\nwhere 比 having 先执行\nhaving 和 where 区别：\n\n\nwhere 放在 from 之后，group by 之前\nwhere 不能使用多行函数（聚集函数）, 列别名也不能用在 where 中\nwhere 是在分组之前之前。先过滤一些记录，再基于剩余的记录进行返祖。\n要先分组再过滤，基于剩下的记录进行分组，就用 having\n\n\nwhere 和 having 的区别：\n\n\nwhere 和 having 都是对于表记录中的记录进行过滤筛选\n\nwhere 用于在分组之前对记录进行过滤筛选，而 having 是对分组之后的记录进行过滤筛选\n\nwhere 子句中不能使用多行函数（聚集函数）, 和列别名。但是可以用表别名\n\nselect name as 姓名，sal as 薪资 from emp e;\n– 其中上面的’姓名’,’薪资’都是列别名，而 e 是表别名\n\n\nhaving 子句中可以使用多行函数（聚集函数）, 列别名，表别名\n\n\n\n插入数据时，数值类型的数据可以用单引号括起来这样也会识别成数值，一般来说。没人这么闲。不过导出的 sql 一般会自带  ‘Mybatis\n写 sql 片段时 小于号会被识别为 xml 的标签，大于不会，因为大于没开始的标志\n大于：&gt;\n\n可以用\n&amp;gt; // 记得加分号 great than\n\n小于：&lt;\n\n 必须用\n&amp;lt; // 记得加分号 less than\n\n好像有一个万能的转义字符\n\n\n&lt;![CDATA『这里输入你要展示的仍何内容』]&gt;\n\nMybatis\n写 sql 片段时 小于号会被识别为 xml 的标签，大于不会，因为大于没开始的标志\n大于：&gt;\n\n可以用\n&amp;gt; // 记得加分号 great than\n\n小于：&lt;\n\n 必须用\n&amp;lt; // 记得加分号 less than\n\n好像有一个万能的转义字符\n\n\n&lt;![CDATA『这里输入你要展示的仍何内容』]&gt;\n\n"},{"title":"Map 中引用遇到的问题","url":"/2021/12/08/Map-%E4%B8%AD%E5%BC%95%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","content":"Map 中引用遇到的问题场景：1、有 List&lt;String&gt; nameList 值为『张三，李四，王五』2、把 nameList 的每个值都存到 key 为&quot;name&quot; 的 map&lt;String,Object&gt; 中3、并把 map 放到 List&lt;Map&lt;String, Object&gt;&gt; 里面\n等于说是：\n『张三，李四，王五』==&gt; 『{name= 张三}, {name= 李四}, {name= 王五}』\nBUG\nBUG : 一直都是最后一个人的姓名\n\nBUG 代码：\npublic static void main(String[PANGU_DISABLE] args) &#123;    List&lt;String&gt; nameList = new ArrayList&lt;&gt;(Arrays.asList(&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;));    System.out.println(nameList);    System.out.println(&quot;================================&quot;);    // BUG 一直都是最后一个人的姓名    List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;();    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16);    for (String name : nameList) &#123;        map.put(&quot;name&quot;, name);        list.add(map);        System.out.println(list);    &#125;&#125;\n\n\n原因\n由输出可见：存进 list 的值都是最后一个的 name.\n因为 list 存的都是这个 map 的同一个引用。类似于 C 语言的指针。也就是list  存的都是同一个地址，这个地址所指向的东西改变，其他存这个地址的里面的值也会改变。所以该 list 下面的值都会变，也就是 name 都是一样的。\n然后 map 的 put 有去重的效果，以最后一个 key 所 put 进去的值为准。所以存的是最后一个 name.\n\n解决\n由原因的第 2 点，我们只需不让 list 存同一个地址。即让 map 重新指向新的地址。即重新 new 一个 HashMap.\n\npublic static void main(String[] args) &#123;    List&lt;String&gt; nameList = new ArrayList&lt;&gt;(Arrays.asList(&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;));    System.out.println(nameList);    System.out.println(&quot;================================&quot;);    // 把 map 放到循环里面，避免重复引用    List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;&gt;();    for (String name : nameList) &#123;        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(16);        map.put(&quot;name&quot;, name);        list.add(map);        System.out.println(list);    &#125;&#125;\n\n"},{"title":"MySQL 总结（二）","url":"/2021/11/25/MySQL%E6%80%BB%E7%BB%932/","content":"MySQL 注意的点：\n写代码的时候突然觉得自己 SQL 方面有点弱，于是有了这篇文章\n\n\n为什么 where 不能用字段别名。因为 mysql 执行顺序：-- 错误：select last_name as namefrom employeeswhere name like &#x27;%shit%&#x27;;-- 正确：select last_name as name        -- 最后再 select 生成字段from employees                  -- 先执行 from 哪个表where last_name like &#x27;%shit%&#x27;;  -- 再执行 where 条件\n\n\nlimit 使用方法-- 这条语句意思是 从第 51 条数据（包括 51) 开始数，数 10 条数据出来select *from employeeslimit 50,10;-- 前端传第几页可以这样给：select *from employeeslimit (currentPage-1)*pageSize,pageSize;---------------------------------select *from employeeslimit 0,1;-- 等价于select *from employeeslimit 1;\n\n\n从 sql 优化来说，多表查询的字段最好都指明表名。减少 sql 找字段的时间。当然如果有同样的字段那肯定得指定的。\nE-R 图\n\n-- 正确：select employees.department_id, departments.department_id, employees.employee_idfrom employees,     departmentswhere employees.department_id = departments.department_id;-- 正确（但是不高效）：select employees.department_id, departments.department_id, employee_idfrom employees,     departmentswhere employees.department_id = departments.department_id;\n\n\n如果给表起了别名，在 select 或者 where 中使用表名的话，必须用别名，否则报错。因为 mysql 的执行顺序，表的别名会覆盖表名-- 正确select employee_id, dept.department_id, employee_idfrom employees emp,     departments deptwhere emp.department_id = dept.department_id;-- 错误select employee_id, departments.department_id, employee_idfrom employees emp,     departments deptwhere employees.department_id = departments.department_id;\n\n\nUNION 操作会返回两个查询结果的并集，会去除相同的记录，而 UNION ALL 不会去重，可以不去重就不去重的写法，去重是 mysql 去重的，所以 UNION  ALL 效率高。\nCOUNT() 是计算不包括 null 的个数\n酷COUNT(*),COUNT(1),COUNT（字段）哪个效率更高？如果是 MyISAM 存储引擎，三者效率都一样，因为这个引擎有一个字段专门存多少行的。如果是 InnoDB 存储引擎，则效率：COUNT(1)=COUNT(*)&gt;COUNT（字段）, 因为这个引擎会自动找 len 最短的去 count, 指定了字段没法优化。\n\n这是结论：GROUP BY 语句中，select 字段中只能存在除聚合函数的 GROUP BY 字段。否则查出来的数据没有意义。正确select job_id j,count(*)from employeesgroup by j;也正确select count(*)from employeesgroup by job_id;错误：select employee_id,count(*)from employeesgroup by job_id;\n\n\nHAVING 必须在 GROUP BY 的后面，使用 HAVING 的前提是有 GROUP BY\nwhere 和 having 效率区别，以及使用区别没有聚合函数的情况下最好用 where 先判断条件。然后再分组再用 having 去操作条件，不然会 把没用的数据也给分组，浪费性能。where 后面不能跟聚合函数，因为你就一组你没分组聚合按照条件没有意义啊。但是 HAVING 可以因为你分了很多个组所以就可以筛选。\n\nmysql 执行顺序SELECT FROM 这里后执行------------JOIN        这里先执行，且按顺序执行ONWHEREGROUP BY    很奇怪的是这里可以用 SELECT 字段的别名HAVING      HAVING 也能用，按道理执行顺序是不可以的            这是 MYSQL 可以的，特例这是。----------ORDER BY    这里最后执行LIMIT\n\n\nGROUP BY 和 HAVING 可以使用 select 字段的别名，这是 MySQL 特殊的，按道理来说也就是执行顺序来说是不可以使用别名的。这是 MySQL 为了偷懒，我认为。\nMYSQL 中不能聚合套聚合，这是他的缺陷，但是 ORACLE 可以\n子查询和自连接相对来说，自连接好一些，因为子查询是通过未知表进行查询的条件判断，而自连接是通过已知的自身数据进行条件判断。因此大部分 DBMS 在自连接处理了优化\nmysql 创建表没指明 charset 就用数据库的charset。数据库是可以charset的哦(charset 是 character set 的简写)\nmysql 创建表有两种方式-- 一个一个创建create table t1(    id   int,    name varchar(20));insert t1values (1, &#x27;2&#x27;),       (2, &#x27;3&#x27;);create table t2 asselect *from t1;\n\n\nDDL,DML,DCL,TCL\nDDL:Data Definition Language (DDL)数据库定义语句\n\n用来创建数据库中的表、索引、视图、存储过程、触发器等CREATE,ALTER,DROP,TRUNCATE,COMMENT,RENAME\n\n\nDML:Data Manipulation Language (DML)数据操纵语句\n\n用来查询、添加、更新、删除等SELECT,INSERT,UPDATE,DELETE,MERGE,CALL,EXPLAIN PLAN,LOCK TABLE\n\n\nDCL:Data Control Language (DCL)数据控制语句\n\n用于授权/撤销数据库及其字段的权限GRANT,REVOKE。\n\n\nTCL:Transaction Control Language (TCL)事务控制语句\n\n用于控制事务COMMIT,ROLLBACK,SAVEPOINT,SET TRANSACTION\n\n\n\n\nDROP 表结构和表数据都会删除，释放表空间\nTRUNCATE 只会清空表数据，但是保留表结构\nTRANCATE 是DDL语句,DDL语句是没有ROLLBACK指令的，\nROLLBACK 只可以回滚到上一次的提交。仅仅是上一次次。DDL 没有ROLLBACK指令，你可以理解为DDL会自带一个commit，他执行完后会立刻马上会自动提交，所以你下面的ROLLBACK就到他下面的commit就打止了。\nTRUNCATE 和 DELETE FROM 异同点\n相同：\n都可以实现对数据的删除，同时保留表结构\n\n\n不同:\nDELETE FROM 是DML，TRUNCATE是DDL\nTRUNCATE TABLE 不能回滚！！！\n注意：COMMIT 在DML中是默认开启的，即set autocommit=true，这是默认开启的，所以delete默认也不能回滚，只能设置为false才能回滚。\n但是TRUNCATE不会触发TRIGGER（日志记录）所以是个危险操作尽量不用，虽然效率高。\n\n\n\n\nMySQL 8.0 有DDL的原子性，但是5.7没有。即：-- mysql8.0CREATE TABLE table1();DROP table1,table2;-- 因为table2不存在，所以不会成功。\n\n\nMyBatis 用${}的情况，用到表名做参数的时候就用这个。\nINSERT 添加可以添加查询结果：\n但是要注意添加的字段要和查询的字段对应。\n字段的范围也要对应,对应或者大于。如果里面的数据没有那么长，那可以。但是最好还是大于等于。INSERT into emp(id,name)select id,name from emp2;\n\n\nUPDATE 要接条件，不然会更新整个表，DELETE FROM TABLE 也是，要注意了。\n小数类型建议为DECIMAL，如果字段为非负数，建议为UNSIGNED\nCHAR 是固定长度的,VARCHAR 是可变长度的。超过varchar最大值，用TEXT，但是TEXT 很大，所以建议独立一张表出来\n约束\nnot null\nunique\ncheck 5.7没有,8.0有，create table test01(id int,last_name varchar(15)，salary decimal(10,2) check(salary&gt;2000))\nDEFAULT\n\n\n行级约束，表级约束create table test1(id INT UNIQUE, -- 行级约束last_name VARCHAR(15),email VARCHAR(15),CONSTRAINT uk_test1_email UNIQUE(emial) -- 表级约束-- NOT NULL 没有表级约束)-- 这里给约束命名了，默认不给的话是和列名相同的\n\n\nUNIQUE 可以有null，但是可以有多个null，\nmysql 可以对表指定不同的存储引擎，你可以在show create table XXX 看到后面，engin=XXX；外键约束不能跨引擎，btw，基本不用外键约束。在代码应用层解决\nUTF8mb4和UTF8mb3\nutf8mb3:1~3个字节表示字符\nutf8mb4:1~4个字节表示字符mysql utf8 默认是utf8mb3。utf8mb4用于emoji表情一般；\n\n\nSQL执行顺序\nSQL语句-&gt;查询缓存-&gt;解析器-&gt;优化器-&gt;执行器-&gt;找存储引擎API看用的哪个engine\n\n\nInnoDB 的好处\n你可以show engines看到，支持事物和分布式\n\n\nMyISAM 和 InnoDB\n\n\n对比项\nMyISAM\nInnoDB\n\n\n\n外键\nNo\nYes\n\n\n事物\nNo\nYes\n\n\n行表锁\n表锁，即使操作一条记录会锁住整个表，不适合高并发\n行锁\n\n\n缓存\n只缓存索引，不缓存真实数据,增加查询很多优选选\n缓存和数据都是真实数据，都是 .idb 结尾的文件,使用的时候会更占据内存 ,\n\n\n关注点\n性能：节省资源，消耗少，简单业务\n事物：并发写，事物，更大资源\n\n\n默认安装\nYes\nYes\n\n\n默认使用\nNo(MySQL 5.5 之前 Yes)\nYes\n\n\n选择\n增加查询多用MyISAM\n更新删除多优选选InnoDB\n\n\n"},{"title":"Oracle 中 substr 和 instr 函数简单用法","url":"/2021/08/07/Oracle-%E4%B8%AD-substr-%E5%92%8C-instr-%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/","content":"\n\n\nOracle 的 substr 和 instr 函数简单用法\nsubstr 函数简单用法\nsubstr 介绍\n测试代码\n测试图片\n\n\ninstr 函数的简单用法\ninstr 函数介绍：\n测试代码\n测试图片\n\n\n总结\n实例图片\n\n\n\n\n\n\n\nOracle 的 substr 和 instr 函数简单用法substr 函数简单用法substr 介绍\n/*\n* 截取字符串（字符串位置从 1 开始，而不是从 0 开始）\n* @param string 源字符串\n* @param position 检索位置，参数为正时，从左向右检索，参数为负时，从右向左检索\n* @param substring_length 要截取的长度，可省略（默认从 position 位开始截取全部）, 值小于 1 时返回空字符串\n* @return 返回截取的字符串\n*/\n\nsubstr(string, position, substring_length);\n测试代码select substr(&#x27;Hello World&#x27;, 0, 1)  c1-- 返回结果为 &#x27;H&#x27;  * 从字符串第一个字符开始截取长度为 1 的字符串     , substr(&#x27;Hello World&#x27;, 1, 1)  c2-- 返回结果为 &#x27;H&#x27;  *0 和 1 都是表示截取的开始位置为第一个字符     , substr(&#x27;Hello World&#x27;, 2, 4)  c3-- 返回结果为 &#x27;ello&#x27;     , substr(&#x27;Hello World&#x27;, -3, 3) c4-- 返回结果为 &#x27;rld&#x27; * 负数 (-i) 表示截取的开始位置为字符串右端向左数第 i 个from PRPDKIND;\n\n测试图片\n\ninstr 函数的简单用法instr 函数介绍：\n/*\n* 返回子字符串在源字符串中的位置（字符串位置从 1 开始，而不是从 0 开始）\n* @param string 源字符串\n* @param substring 子字符串\n* @param position 检索位置，可省略（默认为 1), 参数为正时，从左向右检索，参数为负时，从右向左检索\n* @param occurrence 检索子字符串出现的次数，可省略（默认为 1), 值只能为正整数，否则会报错\n* @return 返回子字符串在源字符串中出现的位置（没找到返回 0）\n*/\n\ninstr(string, substring, position, occurrence)\n测试代码SELECT INSTR(&#x27;hello world&#x27;, &#x27;l&#x27;) FROM DUAL;           -- 结果：3SELECT INSTR(&#x27;hello world&#x27;, &#x27;l&#x27;, 5) FROM DUAL;        -- 结果：10SELECT INSTR(&#x27;hello world&#x27;, &#x27;l&#x27;, -1) FROM DUAL;       -- 结果：10SELECT INSTR(&#x27;hello world&#x27;, &#x27;l&#x27;, 2, 2) FROM DUAL;     -- 结果：4SELECT INSTR(&#x27;hello world&#x27;, &#x27;l&#x27;, -3, 3) FROM DUAL;    -- 结果：0\n\n测试图片\n总结\n可以将 SUBSTR 和 INSTR 结合使用来实现截取字符串中特定字符前后的字符串-- 截取“hello,world”字符串中“,”分隔符之前的字符串SELECT SUBSTR(&#x27;hello,world&#x27;, 1, INSTR(&#x27;hello,world&#x27;, &#x27;,&#x27;)-1) FROM DUAL;SELECT SUBSTR(&#x27;hello,world&#x27;, 0, INSTR(&#x27;hello,world&#x27;, &#x27;,&#x27;)-1) FROM DUAL;-- 结果：hello-- 截取“hello,world”字符串中“,”分隔符之后的字符串SELECT SUBSTR(&#x27;hello,world&#x27;, INSTR(&#x27;hello,world&#x27;, &#x27;,&#x27;)+1) FROM DUAL;-- 结果：world-- 截取“hello,world,HH”字符串中第 1 次出现的“,”字符和第 2 次出现的“,”字符之间的字符串SELECT SUBSTR(&#x27;hello,world,HH&#x27;, INSTR(&#x27;hello,world,HH&#x27;, &#x27;,&#x27;,1)+1, INSTR(&#x27;hello,world,HH&#x27;, &#x27;,&#x27;, 2)-1) FROM DUAL;-- 结果：worldSELECT SUBSTR(&#x27;hello,world&#x27;, 1, INSTR(&#x27;hello,world&#x27;, &#x27;,&#x27;) - 1) C1,-- 结果：hello       SUBSTR(&#x27;hello,world&#x27;, 0, INSTR(&#x27;hello,world&#x27;, &#x27;,&#x27;) - 1) C2,-- 结果：hello       SUBSTR(&#x27;hello,world&#x27;, INSTR(&#x27;hello,world&#x27;, &#x27;,&#x27;) + 1)    C3,-- 结果：world       SUBSTR(&#x27;hello,world,HH&#x27;, INSTR(&#x27;hello,world,HH&#x27;, &#x27;,&#x27;, 1) + 1, INSTR(&#x27;hello,world,HH&#x27;, &#x27;,&#x27;, 2) - 1) C4       -- 截取“hello,world,HH”字符串中第 1 次出现的“,”字符和第 2 次出现的“,”字符之间的字符串 -- 结果：worldFROM DUAL;\n\n实例图片\n"},{"title":"lombok 注解，绝中绝，顶上顶！","url":"/2021/12/20/lombok-%E6%B3%A8%E8%A7%A3%EF%BC%8C%E7%BB%9D%E4%B8%AD%E7%BB%9D%EF%BC%8C%E9%A1%B6%E4%B8%8A%E9%A1%B6%EF%BC%81/","content":"lombok 注解，绝中绝，顶上顶！\n可以在编译后的 class 文件来看出不同。不过有时候修改注解后，项目并不会自动编译，此时在 maven 手动编译即可看出效果。\n\n\n本文主要记录 lombok 可能会遇到的一些坑和一些注解解释\n\n\n@Data@Data\n = @Getter + @Setter + @ToString + @EqualsAndHashCode\n注意\n@Data 里面没有构造函数。即如果没有写自定义的构造函数那就是 Java 自带的无参构造函数。如果有自定义的构造函数那就是只有写了的构造函数，没有无参的了\n由上一点，所以一般如果加了 @AllArgsConstructor, 那应该加个 @NoArgsConstructor.\n\n@EqualsAndHashCode@EqualsAndHashCode , 该注解是按照整个对象去重写 Equals 和 HashCode. 有时候业务场景是根据 ID 去判断是否重复，所以可以使用 @EqualsAndHashCode(of = {“id”})\n注意\n\n没加 @EqualsAndHashCode(of = {“id”})\n加了 @EqualsAndHashCode(of = {“id”})\n\n\n@Accessors\n@Accessors 有两个属性\n\n@Accessors(chain = true)\nchain : 链\n\n现在链式编程很酷也很方便，å 上该注解后，所有的 set 命令返回的都是 this 即调用对象本身。不加 @Accessors 默认 setXxx() 返回是 void\n\n因此你可以像这样创建对象：\nStudent student = new Student().setId(1).setName(&quot;lucy&quot;).setAge(18);\n\n\n@Accessors(fluent = true)\nfluent : 流利的\n\n这个命令更牛逼，set get 都给你整没了。直接就是首字母小写的变量名。有参数的就是 set，没参数的就是 get\n因此你可以像这样使用：\nStudent student = new Student().id(1).name(&quot;lucy&quot;).age(18);System.out.println(student.id() + student.name() + student.age());\n\n@Builder\n一种设计模式：建造者模式\n\n注意\n@Builder 会增加全参构造函数，那他就没有默认的无参构造了，得注意。所以得加上 @NoArgsConstructor，但是加上后 @Builder 默认的全参构造就没了，会报错，所以都得加上 @NoArgsConstructor,@AllArgsConstructor.\n并且内部类那个成员变量会覆盖掉他父类的成员变量的默认值，所以默认值会失效。\n\n总结之前在 OkHttps 里面看到过 builder() 这玩意，现在知道了是一种设计模式。lombok 也有用到。但是 @Builder 会更消耗内存吧，静态内部类还没用就直接整上内存里了，好处应该是更直观一点。还是推荐如果喜欢流式的就用 @Accessors(fluent = true) , 喜欢链式编程 setXxx() 就用 @Accessors(chain = true)\n"},{"title":"querySelector 和 getElementById  的区别","url":"/2021/05/06/querySelector%E5%92%8CgetElementById%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"querySelector 和 getElementById  的区别\n\ngetElementsByTagName() 速度比 querySelectorAll() 快的根本原因在于动态 NodeList 和静态 NodeList 对象的不同。\n\ngetElementsByTagName:&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;o&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt;  &lt;li&gt;111&lt;/li&gt;  &lt;li&gt;222&lt;/li&gt;  &lt;li&gt;333&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;script&gt;  var ul=document.getElementsByTagName(&#x27;ul&#x27;)[0];  var list=ul.getElementsByTagName(&#x27;li&#x27;);  for(var i=0;i&lt;5;i++)&#123;    ul.appendChild(document.createElement(&#x27;li&#x27;));  &#125;  console.log(list.length)// 此时输出的结果就是 3+5=8&lt;/script&gt;&lt;/html&gt;\n\n\nquerySelectorAll:&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;o&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt;  &lt;li&gt;111&lt;/li&gt;  &lt;li&gt;222&lt;/li&gt;  &lt;li&gt;333&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;script&gt;  var ul=document.querySelector(&#x27;ul&#x27;);  var list=ul.querySelectorAll(&#x27;li&#x27;);  for(var i=0;i&lt;list.length;i++)&#123;    ul.appendChild(document.createElement(&#x27;li&#x27;));  &#125;// 这个时候就创建了 3 个新的 li，添加在 ul 列表上。  console.log(list.length) // 输出的结果仍然是 3，不是此时 li 的数量 6&lt;/script&gt;&lt;/html&gt;\n\n总结 (摘抄自网上的)\ngetElementsByTagName() 速度比 querySelectorAll() 快的根本原因在于动态 NodeList 和静态 NodeList 对象的不同。\n哪个方法更好用主要还是看你的需求，如果只是要根据 tag name 来查找元素，也不需要获取此一个快照，那就应该使用 getElementsByTagName() 方法；如果需要快照结果（静态）, 或者需要使用复杂的 CSS 查询，则可以考虑 querySelectorAll()。\n\n题外话\n我想学 jQuery,\n\nvanimate.css 好帅，我也想学\n\n\n"},{"title":"toDoList","url":"/2021/06/22/toDoList/","content":"toDoList\n近期要做的事\n\n\n分页查询\n\nlimit\n\n\ndate:4.13AM\n---------------------------------------------\nselect min(sal),group_concat(distinct job)\nfrom emp  group by job;\n-- 查询每个最低薪资大于 1500 的\n-- 思路：先查最低薪资，在查薪资大于 1500 的\n-- 不能这样 because `where` is first go!\n-- so you will search the min&gt;1500 before you search\n-- so, you will filter the job which  is low than 1500 before you group by\n-- solution：use `having`\nselect min(sal),group_concat(distinct job)\nfrom emp where sal&gt;1500 group by job;\n\nselect min(sal),group_concat(distinct job)\nfrom emp group by job having min(sal)&gt;1500;\n\n总结：\nwhere 应该放在 from 后面 group by 之前\nwhere 不能使用多行函数（也就是聚合函数）（列别名也不能用在 where 中？？？）\nwhere 是在分组之前之前，先过滤掉一些数据，再局域剩余的记录进行分组，\n  而本地是先分组，再过滤。所以不能使用 where 应该使用 having\n-- ------------------------------------\n\n\n\n\n\n\n以后要做的事\n\n\n学点正则（有想法可以把 Java 类里面的大括号里面每个方法空一行，每个方法里面空行消失）\n\nvisual 模式切换英文输入法\n\n学会五笔，因为你分不清 ing 和 in\n\njt_web 需求文档要求写商品修改的\n\n有朝一日希望能学习 Vim 的脚本编写，autocmd 之类的\n\nvim sneak 试试\n\nNREDTree 插件按键映射\n\nhexo 的自动部署和自动测试，我有 tomcat 可以用执行 shell 命令吗？然后用 nginx 轮巡机制，请求一次上传，请求第二次 hexo server 之类的。\n\n\n\n\n","tags":["代办"]},{"title":"五笔","url":"/2021/09/10/%E4%BA%94%E7%AC%94/","content":"五笔\n口诀字根\n横区 \n\n11(G) 王旁青头戋（兼）五一，\n\n\n\n12(F) 土士二干十寸雨。二一还有革字底\n\n\n\n13(D) 大犬三羊古石厂，\n\n\n\n14(S) 木丁西，\n\n\n\n15(A) 工戈草头右框七。（“右框”即“匚”）o\n\n\n\n"},{"title":"五笔学习之路","url":"/2021/09/01/%E4%BA%94%E7%AC%94%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/","content":"五笔学习之路缘故\n起因：最开始由于全拼的击键次数过多，以后工作上经常会用到电脑，遂学习双拼（小鹤双拼）只由声母和韵母组成，任何一个字只需要击键两次，上手容易，熟悉后输入速度上有所提升。但是无法避免的拼音的重码率很高，还是要去候选框去选字。\n本质：由于本人在拼音中 in ing 分不清，而且拼音重码率高，五笔基本上四个键确定一个字，选字的情况比较少，空格就完事，为提高 聊天摸鱼 工作效率，故克服重重困难学习五笔 86 版本。\n情感升华：了解过五笔，对于中国汉字的结构以及五笔的渊源，其博大精深，被五笔输入的魅力所折服。\n这篇文章是用双拼打的\n\n\n\n五笔易错集合\n女vvvv 键名汉子\n\n最后一笔为 横\n"},{"title":"Java实现天气预报","url":"/2021/11/10/%E5%AE%9E%E7%8E%B0%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5/","content":"用 Java 实现天气预报起因\n因每次去上班都不知道今天下不下雨。要是下雨鞋子就会湿的。\n然后逛 github 发现有一个 QQ 机器人。可以用 Java 调用。遂想到实时预报下雨的天气。\n所以设置每天早上 6 点发消息提醒今天的降水概率。\n\nStep\n使用 simbot QQ 机器人  (github 开源的）\n使用和风天气和阿里云的易源数据作为天气 API\n\n核心代码图片：\nRestFul 风格调用，接口见名知意\n\nOKHttps 访问 API 获取实时数据\n\nQQ 机器人代码参考github\n效果图：\n\n\n"},{"title":"懒汉式为什么要加 volatile 关键字","url":"/2022/08/16/%E6%87%92%E6%B1%89%E5%BC%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%8A%A0-volatile-%E5%85%B3%E9%94%AE%E5%AD%97/","content":"正常的懒汉式：public class Singleton &#123;    private static Singleton instance;    private Singleton ()&#123;&#125;    public static synchronized Singleton getInstance() &#123;        if (instance == null) &#123;            instance = new Singleton();        &#125;        return instance;    &#125;&#125;\n缺点 :每次调用 getInstance 都会锁住该对象，很慢\n\n双检锁/双重校验锁（DCL，即 double-checked locking）public class Single &#123;    // 为什么要加 volatile 关键字？    private static volatile Single INSTANCE;    public static Single getInstance() &#123;        if (INSTANCE == null) &#123;            //=========line 1=============            synchronized (Single.class) &#123;            //=========line 2=============                if (INSTANCE == null) &#123;                    INSTANCE = new Single();                &#125;            &#125;        &#125;        return INSTANCE;    &#125;    private Single() &#123;    &#125;&#125;\n\n为什么加锁后还要进行 第二次 IF 判空操作？\n调用 getInstance()\n线程 A,B 都执行到 line 1\n线程 A 获取锁后，开始实例化对象返回\n此时线程 B 会进入锁的代码块里。line 2\n\n此时如果不加第二个 if 判断，那么 B 线程就会重复实例化对象了\n\n\n\n所以有第二个 if 判断，线程 B 就会判断不为空，不走实例化逻辑，直接返回，之前线程 A 创建好的\n\n\n\n为什么要加 volatile 关键字？\n网络上说的原子性，可见性不是很理解。\n\n找到一个说服力较大的\n有些编译器为了性能的原因会在创建对象是进行重排序\n\n原来是：分配内存空间初始化对象将对象指向刚分配的内存空间\n重排序后分配内存空间将对象指向刚分配的内存空间初始化对象\n即第二步第三步会交换位置；\n\n总结我理解：在单线程模式下，他这样重排序优化是没问题的。但是问题会发生在多线程的情况\n\n在线程 A 实例化返回后\nSingle 对象如果是重排序后的，他可能在进行改变指针指向，还没进行到初始化对象\n所以导致线程 B 判断不为空（他可能只是根据指针判断为不为空，只能这么猜下去了）\n但是线程 B 返回一个为空的值。\n线程 B 返回对象的状态：有一个指向有意义的对象，所以判断不为空，但是这个对象还没被创建，所以其内部是空的，所以你用到这个对象的时候就会报错；\n加了 volatile 关键字就会禁止重排序.就不会出现上述问题\n\n"},{"title":"懒汉式获取静态成员变量Niubility","url":"/2022/08/16/%E6%87%92%E6%B1%89%E5%BC%8F%E8%8E%B7%E5%8F%96%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8FNiubility/","content":"懒汉式获取静态成员变量Niubility缘故起因: 工作遇到个需求大概是：\n\n写一个接口，供 MQ 调用，大概会有几十万的请求总量丢 MQ 里.（也应用了一下 MQ 场景，用来堆任务缓解服务器内存压力，削峰，异步切入日志）.\n需要对每次请求带过来的数据做一次校验，其中有的校验数据是查数据库写死的类似于字典基本不会改变，但要拿出来做校验\n\n过程 :\n\n顺手一想，弄个静态变量查出来就好了嘛，少一次查库，提升效率。\n反手一想，为啥不用单例模式？而且用静态变量显得我好捞哦，类名.静态变量我理解是用来表示常量的.而且不直观。我是一个查库的过程调用，应该用方法。\n于是有了这篇文章\n\n\n\n搞起我在 Single 类里，加上全局共享的变量MAP,所以对懒汉式有了如下变种：\npublic class Single &#123;    private static volatile Single INSTANCE;    public static Single getInstance() &#123;        if (INSTANCE == null) &#123;            synchronized (Single.class) &#123;                if (INSTANCE == null) &#123;                    INSTANCE = new Single();                &#125;            &#125;        &#125;        return INSTANCE;    &#125;    private Single() &#123;    &#125;    private static volatile Map&lt;Integer, String&gt; MAP;    public Map&lt;Integer, String&gt; getMap() &#123;        if (MAP == null) &#123;            synchronized (Single.class) &#123;                if (MAP == null) &#123;                    MAP = mapInit();                &#125;            &#125;        &#125;        return MAP;    &#125;    private Map&lt;Integer, String&gt; mapInit() &#123;        HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;(16);        map.put(1, &quot;one&quot;);        map.put(2, &quot;two&quot;);        map.put(3, &quot;three&quot;);        return map;    &#125;    public static void main(String[] args) &#123;        Single instance = Single.getInstance();        Map&lt;Integer, String&gt; map = instance.getMap();        System.out.println(map);    &#125;&#125;\n\n题内话最开始，我其实是用静态变量的,想法是这个值不会被修改，所以用的 static final 修饰变量.\n\n其实被final修饰还是会被引用赋值改变的其内部数据的\n\n发现 final 修饰的静态变量不能用于懒汉式,因为他只能被初始化一次.于是改用饿汉式.\n\n大吃一惊的是 在声明静态final变量后,除了可以在声明的时候初始化,还可以在静态代码块初始化,所以就可以加一些逻辑在里面.但是记住只能初始化一次.\n\n奇怪的是 :不能在静态方法初始化StaticSingle.getInstance()这是和静态变量和静态方法的加载顺序有关.\n\n\npublic class StaticSingle &#123;    private static final Map&lt;Integer, String&gt; INSTANCE;    static &#123;        HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;(16);        map.put(1, &quot;one&quot;);        map.put(2, &quot;two&quot;);        map.put(3, &quot;three&quot;);        INSTANCE = map;    &#125;    public static Map&lt;Integer, String&gt; getInstance() &#123;    //不能在这里初始化INSTANCE        return INSTANCE;    &#125;    private StaticSingle() &#123;    &#125;&#125;\nPANGU_DISABLE\n"},{"title":"摸鱼神器 scrcpy","url":"/2021/11/01/%E6%91%B8%E9%B1%BC%E7%A5%9E%E5%99%A8scrcpy/","content":"电脑操作手机的摸鱼神器 scrcpy\n无线控制需要在同一局域网下，并获取手机静态 IP\n\n\n下载 scrcpy.\n多次点击版本号，把手机的 usb 调试打开。usb 连接上电脑。\n查看手机在当前 wifi 的 ip 地址。如果是 DHCP 模式，应当切换到静态模式\n电脑命令行输入adb tcpip 6666\n电脑输入 adb connect IP:6666\n现在可以拔掉数据线，输入命令scrcpy即可进行连接\n\nTips\n在手机熄屏下操作手机\nscrcpy -S\nscrcpy --turn-screen-off\n\n\n操作屏幕点击鼠标右键即可解锁，也可以执行返回操作\n\n图例\n"},{"title":"框架知识题库题","url":"/2021/02/18/%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E9%A2%98%E5%BA%93/","content":"%s/[1].\\d/### &amp;\n 框架知识题库\n1    何为 Spring Bean 容器？Spring Bean 容器与 Spring IOC 容器有什么不同吗？答：用于创建 bean 对象，管理 bean 对象的那个容器Spring IOC 容器本质上指的的就是 Spring Bean 容器，Spring Bean 容器中最核心一个机制是 IOC 机制 (控制反转）, 所以有时候又将 springbean 容器称之为Spring IOC 容器。\n2    Spring IOC 如何理解？答：IOC 是 Spring 中提供一种控制反转机制，目的是将我们项目中对象的依赖管理交给 Spring 实现，这样可以更好实现对象关系的解耦，提高程序的可扩展性。\n3    Spring DI 如何理解？答：DI 是 Spring 中的依赖注入机制，IOC 的实现需要借助这种机制。我们通常会这样理解，Spring Bean 容器中的IOC 思想一种目标，DI 是实现这种思想的目标的手段。\n4    Spring 中基于注解如何配置对象作用域？以及如何配置延迟加载机制？答：@Scope(“singleton”)@Scope(“prototype”)@Lazy(value=true)\n5    Spring 工厂底层构建 Bean 对象借助什么机制？当对象不使用了要释放资源，目的是什么？何为内存泄漏？答：借助反射机制，防止内存泄漏，对象已经不使用了但占用着内存，这种现    象称之为内存泄漏，内存泄漏不是内存溢出，但是它是内存溢出的一个导火索。内存溢出直接就导致系统崩溃了。\n6    描述 Spring MVC 处理流程及应用优势答：1、客户端发出一个 http 请求给 web 服务器，web 服务器对 http 请求进    行    解析，如果匹配前端控制器（或分发器 /DispatcherServlet) 的请求映射路径，    web 容器将请求转交给 DispatcherServlet.2、DipatcherServlet 接收到这个请求之后将根据请求的信息以及处理器映射    器 (HandlerMapping) 的配置找到处理请求的处理器（Handler）。3、由具体的处理器适配器（HandlerAdapter）对 Handler 进行具体的调用。4、Handler 对数据处理完成以后将返回一个 ModelAndView() 对象给    DispatcherServlet。5、DispatcherSevlet 通过视图解析器（ViewResolver）将 ModelAndView() 转    化为真正的视图 View。6、Dispatcher 通过 model 解析出 ModelAndView() 中的参数进行解析最终展    现出完整的 view 并返回给客户端。\n7    Spring 中的事务处理方式及优缺点   答：优点在于：1：能够实现全局事务的控制，通过 EJB CMT 进行事物的管理。2：能够保证项目模块在系统中完成的功能是可可控制的的操作（AOP）缺点在于：1：Spring 中的事物声明有编程式事物和申明是事物\n8    MyBatis 应用中#与 $ 有什么异同点答：      相同点：都是通过 get 来获取值的      不同点：$ 传进去的字符串不带引号 #号带引号\n9    MyBatis 应用动态 SQL 解决了什么问题答：有时候，固定的 sql 语句不能够满足我们的应用需求。这个时候需要在    标准的基础上建立动态的查询语句。Mybatis 提供了多种注解，可以提供动态查询语言。比如说在开发的时候，遇到这样的场景，界面提供了多种查询，但是都是非    必填写，在选择查询条件时可以选中任意几种组合作为查询条件，如果在使    用 jdbc 的时候，需要判断参数为空，自己组装 sql，但是 mybatis 提供动态 sql 机制，依靠标签。\n10    Shiro 框架权限管理时的认证和授权流程描述。答：Shiro 权限控制流程的原理：应用代码 —- 调用 Subject （shiro 的 Subject 就代表当前登陆用户） 控制权限 —- Subject 在 shiro 框架内部 调用 Shiro SecurityManager 安全管理器 —– 安全管理器调用 Realm （程序和安全数据连接器 ）。Subject 要进行任何操作，都必须要调用安全管理器（对我们来说是自动的）。而安全管理器会调用指定的 Realms 对象，来连接安全数据。Realms 用来编写安全代码逻辑和访问安全数据，是连接程序和安全数据的桥梁。\n11    BeanFactory 和 ApplicationContext 有什么区别？     BeanFactory 可以理解为含有 bean 集合的工厂类。BeanFactory 包含了种 bean 的定义，以便在接收到客户端请求时将对应的 bean 实例化。\n      BeanFactory 还能在实例化对象的时生成协作类之间的关系。此举将 bean 自身与 bean 客户端的配置中解放出来。BeanFactory 还包含了 bean 生命周期的控制，调用客户端的初始化方法（initialization methods）和销毁方法（destruction methods）。\n\n从表面上看，application context 如同 bean factory 一样具有 bean 定义、bean 关联关系的设置，根据请求分发 bean 的功能。但 application context 在此基础上还提供了其他的功能。\n12    请解释 Spring Bean 的生命周期？Spring Bean 的生命周期简单易懂。在一个 bean 实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个 bean 不在被调用时需要进行相关的析构操作，并从 bean 容器中移除。\nSpring bean factory 负责管理在 spring 容器中被创建的 bean 的生命周期。Bean 的生命周期由两组回调（call back）方法组成。\n\n   初始化之后调用的回调方法。   销毁之前调用的回调方法。  Spring 框架提供了以下四种方式来管理 bean 的生命周期事件： InitializingBean 和 DisposableBean 回调接口 针对特殊行为的其他 Aware 接口 Bean 配置文件中的 Custom init() 方法和 destroy() 方法 @PostConstruct 和 @PreDestroy 注解方式 使用 customInit() 和 customDestroy() 方法管理 bean 生命周期的代码样例如下：\n&lt;beans&gt;    &lt;bean id=&quot;demoBean&quot; class=&quot;com.howtodoinjava.task.DemoBean&quot;            init-method=&quot;customInit&quot; destroy-method=&quot;customDestroy&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;\n13    Spring Bean 的作用域之间有什么区别？Spring 容器中的 bean 可以分为 5 个范围。所有范围的名称都是自说明的，但是为了避免混淆，还是让我们来解释一下：singleton：这种 bean 范围是默认的，这种范围确保不管接受到多少个请求，每个容器中只有一个 bean 的实例，单例的模式由 bean factory 自身来维护。prototype：原形范围与单例范围相反，为每一个 bean 请求提供一个实例。request：在请求 bean 范围内会每一个来自客户端的网络请求创建一个实例，在请求完成以后，bean 会失效并被垃圾回收器回收。Session：与请求范围类似，确保每个 session 中有一个 bean 的实例，在 session 过期后，bean 会随之失效。global-session：global-session 和 Portlet 应用相关。当你的应用部署在 Portlet 容器中工作时，它包含很多 portlet。如果你想要声明让所有的 portlet 共用全局的存储变量的话，那么这全局变量需要存储在 global-session 中。全局作用域与 Servlet 中的 session 作用域效果相同。\n14    在 Spring AOP 中，关注点和横切关注的区别是什么？关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。\n15    使用 Spring 框架的好处是什么？•    轻量：Spring 是轻量的，基本的版本大约 2MB。•    控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。•    面向切面的编程 (AOP)：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务分开。•    容器：Spring 包含并管理应用中对象的生命周期和配置。•    MVC 框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的替代品。•    事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。•    异常处理：Spring 提供方便的 API 把具体技术相关的异常（比如由 JDBC，Hibernate or JDO 抛出的）转化为一致的 unchecked 异常。、\n16    Spring 中用到了那些设计模式？•    Spring 框架中使用到了大量的设计模式，下面列举了比较有代表性的：•    代理模式—在 AOP 和 remoting 中被用的比较多。•    单例模式—在 spring 配置文件中定义的 bean 默认为单例模式。•    模板方法—用来解决代码重复的问题。比如。RestTemplate, JmsTemplate, JpaTemplate。•    工厂模式—BeanFactory 用来创建对象的实例。•    适配器–spring aop•    装饰器–spring data hashmapper•    观察者– spring 时间驱动模型•    回调–Spring ResourceLoaderAware 回调接口\n17    Spring 如何保证 Controller 并发的安全？Spring 多线程请求过来调用的 Controller 对象都是一个，而不是一个请求过来就创建一个 Controller 对象。并发的安全？ 原因就在于 Controller 对象是单例的，那么如果不小心在类中定义了类变量，那么这个类变量是被所有请求共享的，这可能会造成多个请求修改该变量的值，出现与预期结果不符合的异常那有没有办法让 Controller 不以单例而以每次请求都重新创建的形式存在呢？答案是当然可以，只需要在类上添加注解 @Scope(“prototype”) 即可，这样每次请求调用的类都是重新生成的（每次生成会影响效率）虽然这样可以解决问题，但增加了时间成本，总让人不爽，还有其他方法么？答案是肯定的！使用 ThreadLocal 来保存类变量，将类变量保存在线程的变量域中，让不同的请求隔离开来。\n18    使用 Spring 框架的好处是什么？轻量：Spring 是轻量的，基本的版本大约 2MB。控制反转：Spring 通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。面向切面的编程 (AOP)：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务分开。容器：Spring 包含并管理应用中对象的生命周期和配置。MVC 框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的替代品。事务管理：Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。异常处理：Spring 提供方便的 API 把具体技术相关的异常（比如由 JDBC，Hibernate or JDO 抛出的）转化为一致的 unchecked 异常。\n19    在 Spring 中如何注入一个 java 集合？Spring 提供以下几种集合的配置元素：类型用于注入一列值，允许有相同的值。•     类型用于注入一组值，不允许有相同的值。•     类型用于注入一组键值对，键和值都可以为任意类型。•    类型用于注入一组键值对，键和值都只能为 String 类型\n20    Spring 支持的事务管理类型Spring 支持如下两种方式的事务管理：编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者 XML 配置管理事务。\n21    Spring 框架的事务管理有哪些优点？它为不同的事务 API（如 JTA, JDBC, Hibernate, JPA, 和 JDO) 提供了统一的编程模型。它为编程式事务管理提供了一个简单的 API 而非一系列复杂的事务 API（如 JTA).它支持声明式事务管理。它可以和 Spring 的多种数据访问技术很好的融合。\n22    Spring MVC 的主要组件？（1）前端控制器 DispatcherServlet（不需要程序员开发）作用：接收请求、响应结果，相当于转发器，有了 DispatcherServlet 就减少了其它组件之间的耦合度。（2）处理器映射器 HandlerMapping（不需要程序员开发）作用：根据请求的 URL 来查找 Handler（3）处理器适配器 HandlerAdapter注意：在编写 Handler 的时候要按照 HandlerAdapter 要求的规则去编写，这样适配器 HandlerAdapter 才可以正确的去执行 Handler。（4）处理器 Handler（需要程序员开发）（5）视图解析器 ViewResolver（不需要程序员开发）作用：进行视图的解析，根据视图逻辑名解析成真正的视图（view）（6）视图 View（需要程序员开发 jsp）View 是一个接口， 它的实现类支持不同的视图类型（jsp，freemarker，pdf 等等）\n23    SpringMvc 怎么和 AJAX 相互调用的？通过 Jackson 框架就可以把 Java 里面的对象直接转化成 Js 可以识别的 Json 对象。具体步骤如下 ：（1）加入 Jackson.jar（2）在配置文件中配置 json 的映射（3）在接受 Ajax 方法里面可以直接返回 Object,List 等，但方法前面要加上\n24    Mybatis 中#和 $ 的区别？  #&#123;&#125;是预编译处理，$&#123;&#125;是字符串替换。\n  2. Mybatis 在处理#&#123;&#125;时，会将 sql 中的#&#123;&#125;替换为？号，调用 PreparedStatement 的 set 方法来赋值；\n  3. Mybatis 在处理 $&#123;&#125;时，就是把 $&#123;&#125;替换成变量的值，相当于字符串拼接\n  4. 使用#&#123;&#125;可以有效的防止 SQL 注入，提高系统安全性。\n\n25    mybatis 的缓存机制，一级，二级介绍一下   一级缓存      默认开启      SqlSession 级别的缓存，实现在同一个会话中数据的共享      一级缓存的生命周期和 SqlSession 一致      当有多个 SqlSession 或者分布式环境下，数据库写操作会引起脏数据。二级缓存      默认不开启，需手动开启      SqlSessionFactory 级别的缓存，实现不同会话中数据的共享，是一个全局变量      可自定义存储源，如 Ehcache      当开启缓存后，数据查询的执行的流程是：二级缓存》一级缓存》数据库      不同于一级缓存，二级缓存可设置是否允许刷新和刷新频率实现实体类实现序列化，在 mapper 文件中开启在配置文件中设置 cacheEnabled 为 true\n26    pringMVC 与 Struts2 的区别 pringmvc 的入口是一个 servlet 即前端控制器，而 struts2 入口是一个 filter 过虑器。 pringmvc 是基于方法开发，传递参数是通过方法形参，可以设计为单例或多例（建议单例），struts2 是基于类开发，传递参数是通过类的属性，只能设计为多例。\n27    mybatis 的基本工作流程 读取配置文件，配置文件包含数据库连接信息和 Mapper 映射文件或者 Mapper 包路径。2. 有了这些信息就能创建 SqlSessionFactory，SqlSessionFactory 的生命周期是程序级，程序运行的时候建立起来，程序结束的时候消亡3.SqlSessionFactory 建立 SqlSession, 目的执行 sql 语句，SqlSession 是过程级，一个方法中建立，方法结束应该关闭4. 当用户使用 mapper.xml 文件中配置的的方法时，mybatis 首先会解析 sql 动态标签为对应数据库 sql 语句的形式，并将其封装进 MapperStatement 对象，然后通过 executor 将 sql 注入数据库执行，并返回结果。5. 将返回的结果通过映射，包装成 java 对象。\n28    什么是 MyBatis 的接口绑定，有什么好处接口映射就是在 IBatis 中任意定义接口，然后把接口里面的方法和 SQL 语句绑定，我们通过直接调用接口方法 例如：UserMapper  userMapper=sqlSession.getMapper  (UserMapper.class) 就可以，这样比起原来了 SqlSession 提供的方法，例如 List countryList = sqlSession.selectList(“selectAll”); 我们可以有更加灵活的选择和设置.。\n注意：（1）Mapper .xml 文件的 namespace 属性必须配置为接口的全限定名称，接口方法名与 Mapper.xml 中的\n&lt;select&gt;&lt;insert&gt;\nid 值必须相同，且接口方法的返回值类型必须与 Mapper.xml 配置的 resultType 一致，这里后者起到决定作用。（2）select 查询通过在 Mapper.xml 中配置 ResultMap 标签，将查询结果的列名与字段名对应。insert 语句通过#{属性名}从接口参数获取值放到 sql 语句中。（3）Mapper.xml 接口绑定本质是动态代理。\n29    MyBatis 的编程步骤创建 SqlSessionFactory通过 SqlSessionFactory 创建 SqlSession通过 SqlSession 执行数据库操作调用 session.commit() 提交事务调用 session.close() 关闭事务\n30    JDBC 编程有哪些不足之处，MyBatis 是如何解决这些问题的？JDBC 编程的不足之处数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。Sql 语句写在代码中造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变 java 代码。向 sql 语句传参数麻烦，因为 sql 语句的 where 条件不一定，可能多也可能少，占位符需要和参数一一对应。对结果集解析麻烦，sql 变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成 pojo 对象解析比较方便。MyBatis 的解决方案在 SqlMapConfig.xml 中配置数据链接池，使用连接池管理数据库链接。将 Sql 语句配置在 XXXXmapper.xml 文件中与 java 代码分离。Mybatis 自动将 java 对象映射至 sql 语句。Mybatis 自动将 sql 执行结果映射至 java 对象。\n31    MyBatis 的优缺点优点易于上手和掌握Sql 写在 xml 里面，便于统一管理和优化减少 Sql 与程序代码的耦合提供 xml 标签，支持动态 Sql 编写缺点Sql 工作量大，尤其是字段多，关联表多时，更是如此Sql 依赖于数据库，导致数据库移植性差由于 xml 里面标签 id 必须唯一，导致 DAO 中方法不支持方法重载。所以 dao 层必须是接口\n32    使用 MyBatis 的 mapper 接口调用时有哪些要求？Mapper 接口方法名和 mapper.xml 中定义的每个 sql 的 id 相同Mapper 接口方法的输入参数类型和 mapper.xml 中定义的每个 sql 的 parameterType 的类型相同Mapper 接口方法的输出参数类型和 mapper.xml 中定义的每个 sql 的 resultType 的类型相同Mapper.xml 文件中的 namespace 即是 mapper 接口的类路径\n33    谈谈你对 SpringMVC 的理解 是一个基于 MVC 的 web 框架\n\nSpringMVC 是 Spring 的一个模块，是 Spring 的子容器，子容器可以拿父容器的东西，但是父容器不能拿子容器的东西\n\nSpringMVC 的前端控制器 DispatcherServlet，用于分发请求，使开发变得简单\n\nSpringMVC 流程（重点）. SpringMVC 三大组件\n   1）HandlerMapping：处理器映射器\n     用户请求路径到 Controller 方法的映射\n\n   2）HandlerAdapter：处理器适配器\n     根据 handler(controlelr 类）的开发方式（注解开发 / 其他开发） 方式的不同去寻找不同的处理器适配器\n\n   3）ViewResolver：视图解析器\n     可以解析 JSP/freemarkerr/pdf 等\n\n34    简述 Mybatis 的插件运行原理，以及如何编写一个插件？答：1）Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这 4 种接口的插件，Mybatis 通过动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 invoke() 方法，当然，只会拦截那些你指定需要拦截的方法。2）实现 Mybatis 的 Interceptor 接口并复写 intercept() 方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。\n35    Mybatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？答：1）Mybatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能。2）Mybatis 提供了 9 种动态 sql 标签：trim|where|set|foreach|if|choose|when|otherwise|bind。3）其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。\n36    Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？答：1）Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled=true|false。\n\n\n2）它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke() 方法发现 a.getB() 是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName() 方法的调用。这就是延迟加载的基本原理。\n37    Mybatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？答：能，Mybatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 selectOne() 修改为 selectList() 即可；多对多查询，其实就是一对多查询，只需要把 selectOne() 修改为 selectList() 即可。关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。\n38    Mybatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？答：第一种是使用标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用 sql 列的别名功能，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，Mybatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，Mybatis 一样可以正常工作。\n39    Mybatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？答：虽然 Mybatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。\n40    MyBatis 里面的动态 Sql 是怎么设定的？用什么语法？答：MyBatis 里面的动态 Sql 一般是通过 if 节点来实现，通过 OGNL 语法来实现，但是如果要写的完整，必须配合 where、trim 节点，where 节点是判断包含节点有内容就插入 where，否则不插入，trim 节点是用来判断如果动态语句是以 and 或 or 开始，那么会自动把这个 and 或者 or 取掉 。\n41    Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？答：Mybatis 有三种基本的 Executor 执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。SimpleExecutor：每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。ReuseExecutor：执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用 Statement 对象。BatchExecutor：执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch() 完毕后，等待逐一执行 executeBatch() 批处理。与 JDBC 批处理相同。作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。\n42    为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？答：Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。面试题看似都很简单，但是想要能正确回答上来，必定是研究过源码且深入的人，而不是仅会使用的人或者用的很熟的人，以上所有面试题及其答案所涉及的内容，在我的 Mybatis 系列博客中都有详细讲解和原理分析。\n43    简单介绍下你对 mybatis 的理解？ mybatis 配置\n\n\nSqlMapConfig.xml，此文件作为 mybatis 的全局配置文件，配置了 mybatis 的运行环境等信息。\nmapper.xml 文件即 sql 映射文件，文件中配置了操作数据库的 sql 语句。此文件需要在 SqlMapConfig.xml 中加载。\n通过 mybatis 环境等配置信息构造 SqlSessionFactory 即会话工厂\n由会话工厂创建 sqlSession 即会话，操作数据库需要通过 sqlSession 进行。\nmybatis 底层自定义了 Executor 执行器接口操作数据库，Executor 接口有两个实现，一个是基本执行器、一个是缓存执行器。\nMapped Statement 也是 mybatis 一个底层封装对象，它包装了 mybatis 配置信息及 sql 映射信息等。mapper.xml 文件中一个 sql 对应一个 Mapped Statement 对象，sql 的 id 即是 Mapped statement 的 id。\nMapped Statement 对 sql 执行输入参数进行定义，包括 HashMap、基本类型、pojo，Executor 通过 Mapped Statement 在执行 sql 前将输入的 java 对象映射至 sql 中，输入参数映射就是 jdbc 编程中对 preparedStatement 设置参数。\nMapped Statement 对 sql 执行输出结果进行定义，包括 HashMap、基本类型、pojo，Executor 通过 Mapped Statement 在执行 sql 后将输出结果映射至 java 对象中，输出结果映射过程相当于 jdbc 编程中对结果的解析处理过程。44    介绍一下 Spring 的事物管理 事务就是对一系列的数据库操作（比如插入多条数据）进行统一的提交或回滚操作，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作。这样可以防止出现脏数据，防止数据库数据出现问题。\n\n开发中为了避免这种情况一般都会进行事务管理。Spring 中也有自己的事务管理机制，一般是使用 TransactionMananger 进行管 理，可以通过 Spring 的注入来完成此功能。Spring 支持如下两种方式的事务管理：编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。声明式事务管理：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者 XML 配置管理事务。一般选择声明式事务管理，因为这种方式和应用程序的关联较少。\n45    SSM 优缺点、使用场景？ Mybatis 和 hibernate 不同，它不完全是一个 ORM 框架，因为 MyBatis 需要程序员自己编写 Sql 语句，不过 mybatis 可以通过 XML 或注解方式灵活配置要运行的 sql 语句，并将 java 对象和 sql 语句映射生成最终执行的 sql，最后将 sql 执行的结果再映射生成 java 对象。\n\nMybatis 学习门槛低，简单易学，程序员直接编写原生态 sql，可严格控制 sql 执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是 mybatis 无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套 sql 映射文件，工作量大。\n\nHibernate 对象 / 关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用 hibernate 开发可以节省很多代码，提高效率。但是 Hibernate 的学习门槛高，要精通门槛更高，而且怎么设计 O/R 映射，在性能和对象模型之间如何权衡，以及怎样用好 Hibernate 需要具有很强的经验和能力才行。\n\n总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。\n46    SpringMVC 的工作流程？用户发送请求至前端控制器 DispatcherServletDispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。处理器映射器根据请求 url 找到具体的处理器，生成处理器对象及处理器拦截器（如果有则生成）一并返回给 DispatcherServlet。DispatcherServlet 通过 HandlerAdapter 处理器适配器调用处理器执行处理器 (Controller，也叫后端控制器）。Controller 执行完成返回 ModelAndViewHandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServletDispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器ViewReslover 解析后返回具体 ViewDispatcherServlet 对 View 进行渲染视图（即将模型数据填充至视图中）。DispatcherServlet 响应用户\n\n\n47    如果你也用过 struts2. 简单介绍下 springMVC 和 struts2 的区别有哪些？springmvc 的入口是一个 servlet 即前端控制器，而 struts2 入口是一个 filter 过虑器。springmvc 是基于方法开发（一个 url 对应一个方法），请求参数传递到方法的形参，可以设计为单例或多例（建议单例），struts2 是基于类开发，传递参数是通过类的属性，只能设计为多例。Struts 采用值栈存储请求和响应的数据，通过 OGNL 存取数据， springmvc 通过参数解析器是将 request 请求内容解析，并给方法形参赋值，将数据和视图封装成 ModelAndView 对象，最后又将 ModelAndView 中的模型数据通过 reques 域传输到页面。Jsp 视图解析器默认使用 jstl。\n48    怎么样把数据放入 Session 里面可以声明一个 request, 或者 session 先拿到 session, 然后就可以放入数据，或者可以在类上面加上 @SessionAttributes 注解，里面包含的字符串就是要放入 session 里面的 key\n49    讲下 SpringMvc 的执行流程系统启动的时候根据配置文件创建 spring 的容器，首先是发送 http 请求到核心控制器 DispatcherServlet，spring 容器通过映射器去寻找业务控制器，使用适配器找到相应的业务类，在进业务类时进行数据封装，在封装前可能会涉及到类型转换，执行完业务类后使用 ModelAndView 进行视图转发，数据放在 model 中，用 map 传递数据进行页面显示。\n50    MyBatis(IBatis) 的好处是什么ibatis 把 sql 语句从 Java 源程序中独立出来，放在单独的 XML 文件中编写，给程序的维护带来了很大便利。ibatis 封装了底层 JDBC API 的调用细节，并能自动将结果集转换成 JavaBean 对象，大大简化了 Java 数据库编程的重复工作。因为 Ibatis 需要程序员自己去编写 sql 语句，程序员可以结合数据库自身的特点灵活控制 sql 语句，因此能够实现比 hibernate 等全自动 orm 框架更高的查询效率，能够完成复杂查询。\n51    Bean 工厂和 Application contexts 有什么区别？Application contexts 提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如镜像），它们可以向注册为监听器的 bean 发布事件。另外，在容器或容器内的对象上执行的那些不得不由 bean 工厂以程序化方式处理的操作，可以在 Application contexts 中以声明的方式处理。Application contexts 实现了 MessageSource 接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。\n52    解释 Spring 支持的几种 bean 的作用域Spring 框架支持以下五种 bean 的作用域：singleton : bean 在每个 Spring ioc 容器中只有一个实例。prototype：一个 bean 的定义可以有多个实例。request：每次 http 请求都会创建一个 bean，该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。session：在一个 HTTP Session 中，一个 bean 定义对应一个实例。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。global-session：在一个全局的 HTTP Session 中，一个 bean 定义对应一个实例。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。缺省的 Spring bean 的作用域是 Singleton。\n53    什么是 bean 的自动装配？Spring 容器能够自动装配相互合作的 bean，这意味着容器不需要和配置，能通过 Bean 工厂自动处理 bean 之间的协作。\n54    什么是基于 Java 的 Spring 注解配置？给一些注解的例子。基于 Java 的配置，允许你在少量的 Java 注解的帮助下，进行你的大部分 Spring 配置而非通过 XML 文件。以 @Configuration 注解为例，它用来标记类可以当做一个 bean 的定义，被 Spring IOC 容器使用。另一个例子是 @Bean 注解，它表示此方法将要返回一个对象，作为一个 bean 注册进 Spring 应用上下文。\n55    使用 Spring 通过什么方式访问 Hibernate?在 Spring 中有两种方式访问 Hibernate：控制反转 Hibernate Template 和 Callback。继承 HibernateDAOSupport 提供一个 AOP 拦截器。\n56    如何通过 HibernateDaoSupport 将 Spring 和 Hibernate 结合起来？用 Spring 的 SessionFactory 调用 LocalSessionFactory。集成过程分三步：配置 the Hibernate SessionFactory。继承 HibernateDaoSupport 实现一个 DAO。在 AOP 支持的事务中装配。\n57    Spring 框架的事务管理有哪些优点？它为不同的事务 API 如 JTA，JDBC，Hibernate，JPA 和 JDO，提供一个不变的编程模式。它为编程式事务管理提供了一套简单的 API 而不是一些复杂的事务 API 如它支持声明式事务管理。它和 Spring 各种数据访问抽象层很好得集成。\n58    在 Spring AOP 中，关注点和横切关注的区别是什么？关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。\n59    AOP 作用是什么，底层如何实现在哪些地方会用到，分别简述切面，切入点和通知。AOP: 面向切面编程：将一个系统中共同的业务逻辑提取出来，进行单独的封装成一个组件（切面）, 然后以配置的方式作用于系统中，实现程序的可插拔性，提高代码的复用性，提升系统的灵活性和性能底层实现：JDK 动态代理，只支持接口注入 CGLIB: 可以支持普通类的注入那些地方会用到：事物开启，日志记录，安全验证，权限验证切面：系统中共通的业务提取出来，在某个时刻或者某个阶段共同调用切入点：找到目标方法，给它追加共通的业务逻辑，在 spring 中提供了切入点表达式帮助我们找到目标方法 execution通知：什么时候调用这个共通的业务逻辑，用于指定切面方法作用到系统中的时机。前置通知，后置通知，环绕通知，异常通知，最终通知。\n60    Spring 中 AutoWired 和，Resource 之间区别是什么AutoWried: 按照类型进行匹配—spring 框架自带的，查看当前 Spring 容器中那个 bean 类型和引用类型一致，就进行注入，如果有多个匹配类型就会报错。Resource: 默认按照名称进行注入，如果找不到对应的名称按照 bean 类型进行注入\n"},{"title":"学习&延伸 用 Collections.unmodifiableList","url":"/2022/08/16/%E5%AD%A6%E4%B9%A0&%E5%BB%B6%E4%BC%B8-%E7%94%A8-Collections-unmodifiableList/","content":"用 final 修饰的变量，对象属性可以修改的我在想有什么方法可以限制修改吗？\n于是搜索后了解到有一个 Collections 里有一个内部类 UnmodifiableCollection ;\n\nUnmodifiableCollection 这个类重写了 Collection 的添加和修改方法，使其调用这个方法会抛 UnsupportedOperationException（不支持的操作异常）\n\n可以用 Collections.unmodifiableList(yourList) 来让你的类不能用添加修改方法\n\n\n总结\n其实本质上对于 Collections 来说里面的值存泛型是任意类型，其对象的属性都是可以修改的。\n不过这也提供了一种思路：当我们不想这个类调用某些方法时，可以重写这个类的方法。\n\n实现\n自己照抄思路实现了一下，哈哈，其是就是多态的体现。\n为什么不用继承做呢？我觉得效果是一样的.但是是继承只能继承一个，接口能实现多个。\n\npublic interface FeatureHaveMouth &#123;    /**     * 吃粑粑     */    void eatShit();&#125;\npublic class Dog implements FeatureHaveMouth &#123;    @Override    public void eatShit() &#123;        System.out.println(&quot;Dog 吃粑粑，Dog 喜欢吃粑粑&quot;);    &#125;&#125;\npublic class TrainDog implements FeatureHaveMouth &#123;    @Override    public void eatShit() &#123;        System.out.println(&quot;Dog 吃粑粑，Dog 喜欢吃粑粑，但是我是 TrainDog 就算我喜欢吃我也不吃&quot;);    &#125;    public static FeatureHaveMouth train(FeatureHaveMouth featureHaveMouth) &#123;        System.out.println(&quot;====Training====&quot;);        return new TrainDog();    &#125;&#125;\n\nTestpublic class TestFeatHaveMouth &#123;    @Test    public void testDog() &#123;        FeatureHaveMouth dog = new Dog();        dog.eatShit();        FeatureHaveMouth trainDog = TrainDog.train(dog);        trainDog.eatShit();    &#125;&#125;\n测试结果\n\n\n"},{"title":"Java 为什么要使用泛型","url":"/2022/11/01/Java-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B/","content":"Java 历史泛型是从 Java 1.5 出现的。\n为什么要使用泛型提高代码复用性\n需求：遍历集合\nJava1.5 之前的代码：\n\n\nList list = new ArrayList();list.add(&quot;Sparrow&quot;);list.add(23);for (int i = 0; i &lt; list.size(); i++) &#123;    Object obj = list.get(i);    //多态，查找父类的 toString 方法，打印出结果，    System.out.println(obj);&#125;//如果我们遍历的时候就想得到自己想要的数据类型for (int i = 0; i &lt; list.size(); i++) &#123;    //在取 Integer 的时候会报类型转换错误    String obj = (String) list.get(i);    System.out.println(obj);&#125;\n\n  输出\nSparrow23SparrowException in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String\tat cn.leijiba.config.MyConfig.Test.main(Test.java:20)\n\n\n问题\n如图抛错所示，List 存和取元素都是 Object 类型。所以存在运行时异常，编译不会报错有安全隐患，不方便写代码。\n如果我们遍历的时候就想得到自己想要的数据类型有以下解决办法\n\n解决办法 1：\n在遍历集合的时候用 instance of 去判断属于哪个类，再进行强转；现任这样不合理，类很多。\n\n解决办法 2:\n限定存入的类型，也限制取出的类型。所以会有如下代码出现：\n\n\n\n\n"},{"title":"Java 泛型详解汇总","url":"/2022/11/01/Java%20%E6%B3%9B%E5%9E%8B%E8%AF%A6%E8%A7%A3%E6%B1%87%E6%80%BB/","content":"Java 泛型\n看了 Java 的 Collection 等源码，发现泛型用处很多，不知道为什么要这样设计（extends 和 super）于是有了这篇文章。\n\n阅读顺序\nJava 为什么要使用泛型（泛型的由来历史）\n\n使用泛型目的是要在编译阶段就找出类型的错误来，而不是运行时。所以我们应该带着能在解决运行抛错的问题来了解泛型。\n\n\n协变和逆变\n\nPECS(Producer Extends, Consumer Super) 规范原则\n\nProducer Extends 设置上边界（协变）用来获取值Consumer Super 设置下边界（逆变）用来操作值如果你想都支持获取修改操作则设置 T 任意类型。\n\n\nJava 为什么不支持泛型数组（引入泛型解决了什么问题）\n\n\n"}]