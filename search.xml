<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2025-02-27 面试总结</title>
    <url>/2025/02/27/2025-02-27-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>上次面试还是两年前刚来深圳的时候。那时候一天能跑 4 趟面试，住在青年旅社，我想早点在深圳找工作然后租房子稳定下来，我记得还拿了挺多 offer ，真的挺佩服当时的自己的。</p>
<p>时隔两年，公司裁员了，现在要重新找工作，感慨万分，写下这篇文章。</p>
</blockquote>
<hr>
<h1 id="面试前"><a href="#面试前" class="headerlink" title="面试前"></a>面试前</h1><p>面试地点是深圳第一高楼：平安金融中心</p>
<p>从购物公园地铁站一出来就是高楼大厦，正好是午休时间的，楼下的咖啡亭子都坐满了人，路过的行人都很有班味儿，端着咖啡，穿着黑色行政装。我感觉自己像条土狗。</p>
<details>
<summary><strong>随手拍的平安大楼图片（点击展开）</strong></summary>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2025/02/27/2025-02-27-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/2B02D818819DACDF4DBDD6497D419B8E.jpg"
                       
                 ></p>
</details>

<details>

<summary><strong>面试走廊（点击展开）</strong></summary>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2025/02/27/2025-02-27-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/F2E812A2B6E8CED7CE1ED84B8076E2FE.jpg"
                       
                 ></p>
</details>

<h1 id="面试过程"><a href="#面试过程" class="headerlink" title="面试过程"></a>面试过程</h1><p>这次面试20多分钟就结束了，感觉上是没戏了。因为他问了很多八股文，我几乎没准备。</p>
<hr>
<ul>
<li>介绍一下你项目，你主要负责哪些功能</li>
<li>redis 几种数据类型，hash 类型应用场景，击穿，雪崩方案</li>
<li>mq 消息怎么保证不重复消费</li>
<li>数据库优化方案</li>
<li>SpringCloud 常用注解</li>
<li>Feign 超时时间，超时怎么处理</li>
<li>心跳机制</li>
</ul>
<h1 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h1><h4 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h4><p>   自我介绍很磕磕绊绊，也可能太急于介绍项目了想到哪说哪，自我介绍没说的很完美。<br>   自我介绍这块我得打个草稿提前过一遍</p>
<hr>
<h4 id="redis-几种类型，击穿，雪崩方案"><a href="#redis-几种类型，击穿，雪崩方案" class="headerlink" title="redis 几种类型，击穿，雪崩方案"></a>redis 几种类型，击穿，雪崩方案</h4><details>
<summary><b> 实际上的回答（点击展开）</b></summary>
 
<p>  redis 类型。我项目就用的 string 类型，需求是接口调用太久得缓存调用结果，key 是类名加方法名加方法入参，value 是方法返回值。关于其他类型我都没做太多了解，但是我都提了具体有哪些类型，然后他问了 hash 类型应用场景，我说可能hash算法的原因随机访问快？（现在看起来太撤蛋了）他没往下问了。。。话说我这种情形用 string 应该没毛病，可能会污染key？比如 <code>keys *</code> 会弹出很多 key。他应该是想让我用hash存… 不过这都是后知后觉了。</p>
</details>
 

<details>
<summary><b> 我觉得满意的回答（点击展开）</b></summary>

<p>主要有这些：string,hash,list,set,sorted set</p>
<hr>
<ul>
<li>string 适合一些简单单一的公共的数据，因为太复杂会污染 key 。适合的例子：计数器（网页访问量、点赞数、控制接口访问频率）；</li>
</ul>
<hr>
<ul>
<li>hash 适合结构化对象，因为可以局部更新不用整体写入，例如：<br>key:学生id-field:班级-value:一班<br>key:学生id-field:年龄-value:18</li>
</ul>
<hr>
<ul>
<li>list 支持两端操作，你可以理解为一根管子，另外有Range方法。可以适用的场景：</li>
<li><ul>
<li>用作队列：先进先出（FIFO）。队列有啥用？</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>消息队列：好处</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>异步消息：不需要等你完成，丢队列里面就行，需要延迟处理的任务放入消息队列，设置延迟时间，消费者在指定时间处理任务</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>任务调度：任务放入队列，定时调度任务，延迟消费，完成任务1才去完成任务2，按顺序处理待办任务。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><ul>
<li>解耦</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>时间轴：比如朋友圈查看，最新的放在左边开头，每次刷新就 lrange(0,页码);查看新动态。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>set 特点是无序且唯一,有 intersect 方法（求两个set的交集）。语法：<code>SADD key value</code>,<code>SMEMBERS key</code></li>
<li><ul>
<li>由唯一性会想到去重、不重复。例如，你往学生添加爱好，爱好不可以重复 <code>sadd student1 [football,baseball,basketball]</code></li>
</ul>
</li>
<li><ul>
<li>无序想到随机抽取等</li>
</ul>
</li>
<li><ul>
<li>交集方法：查找两个班级学生名字相同的人。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>sort set 有序set 语法 <code>ZADD key score1 member1 [score2 member2 ...]</code></li>
<li><ul>
<li>可以根据sort 排序这条记录。应用场景：排行榜</li>
</ul>
</li>
</ul>
<hr>
<p>redis为了缓解数据库压力，设置缓存缓存数据防止查mysql。但会出现缓存击穿（也叫穿透 Cache Breakdown）、缓存雪崩</p>
<ul>
<li>缓存击穿：出现原因：查询到了不存在的值。</li>
<li><ul>
<li>例如来了个请求查询id为 -999 的数据，mysql没得，导致redis缓存的是 -999 的查不到的数据。来多个-998 -997 这样非法的数据。导致很多缓存没被击中，也就是击穿</li>
</ul>
</li>
<li><ul>
<li>处理方案：在缓存前，若传过来一些非法的数据给他拦截提示非法数据，直接返回，如ID必须为正数，。或者设置ip黑名单。</li>
</ul>
</li>
<li>缓存雪崩：出现原因：突然一下子很多redis key过期，导致来的请求直接走数据库。 </li>
<li><ul>
<li>处理方案：随机过期时间、缓存预热（提前查一遍到缓存）、多级缓存（吹牛逼的）？</details></li>
</ul>
</li>
</ul>
<h4 id="mq-消息怎么保证不重复消费"><a href="#mq-消息怎么保证不重复消费" class="headerlink" title="mq 消息怎么保证不重复消费"></a>mq 消息怎么保证不重复消费</h4><details>
<summary><b> 实际上的回答（点击展开）</b></summary>

<p>  其实我都不知道面试官要问啥，我以为是幂等性的问题，虽然有部分相似。实际要理解 mq 为什么会出现这种问题，因为我实际没遇到过这种问题，这种又是经典八股文。<br>  我回答的是消费mq的数据的时候带过来唯一的 ID(流水号之类) 先查 select 数据库数据是否存在，没有的话根据ID创建该业务数据，后面再执行后续的消费功能。<br>  因为我之前所做过的项目的特点，数据最好留下痕迹，简单就是调用过程的数据多入库，我先入库了，数据就好排查问题。<br>  我的回答就这么简短，就是一句话就说完了。面试官也没多问。。。但是其实还可以拓展。</p>
</details>
<details>
<summary><b> 满意的回答（点击展开）</b></summary>

<ul>
<li>消息队列（MQ）的设计初衷是确保消息不会被重复消费，但在实际运行中，仍可能发生一些情况导致消息被多次消费。</li>
</ul>
<p>队列基本流程是，生产者-&gt;交换机-&gt;队列-&gt;消费者</p>
<p>TODO 我看了交换机有好多，这些有啥用啊晕死…….</p>
<p>消费者处理失败：消息未被正确确认（acknowledge），消息队列系统会重新投递该消息<br>消费者进程崩溃，同上。<br>网络问题，同上。</p>
<p>都是因为消费者未能及时确认消息，队列没收到ack，认为消息没处理。</p>
<p>所以才会产生重复消费的场景</p>
<p>有很多种方案：</p>
<p>如遇到并发问题方案2可行但是比较粗暴，或者方案 3 手动应答但是 <code>不放/放</code>回队列（我公司就是这种方法，然后多个消费者，这批数据跑完了再跑失败的数据）。或者看方案 4 比较麻烦。</p>
<ol>
<li>缓存 ID 去重<br>  每个消息附带一个唯一的 ID，放到静态变量或者缓存中，插入前先查询一遍缓存。</li>
<li>数据库去重<br>  每个消息附带一个唯一的 ID,通过唯一约束避免重复处理，把它在数据库字段设置成 unique 的字段。</li>
<li>消息确认机制（Consumer Acknowledgements）<br>  使用手动消息确认机制，basicAck 方法最后一个参数。确保只有成功处理的消息才会被确认，未确认的消息会被重新投递。<br>  虽然在 RabbitMQ 中，每条消息只会被一个消费者接收，但如果消费者并未及时确认（acknowledge），则消息可能会在消费者处理期间超时，并被 RabbitMQ 重新投递，导致重复消费。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;myQueue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(String message, Channel channel, <span class="meta">@Header(AmqpHeaders.DELIVERY_TAG)</span> <span class="type">long</span> deliveryTag)</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 处理消息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;接收到消息: &quot;</span> + message);</span><br><span class="line">    <span class="comment">// 手动确认消息</span></span><br><span class="line">    channel.basicAck(deliveryTag, <span class="literal">false</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;消息已确认&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 处理失败，拒绝消息并重新投递</span></span><br><span class="line">    channel.basicNack(deliveryTag, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    System.err.println(<span class="string">&quot;消息处理失败，重新投递: &quot;</span> + message);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>Redis 分布式锁 这名字挺高级，我怎么感觉就和第一种id放缓存一样呢。<br>不一样，因为如果两个线程会同时检查key是否存在，这样可能会漏。所以得给key(id)加锁。</li>
</ol>
<p>给key加锁<br>加锁：使用 SETNX(SET if Not eXists) 命令尝试设置一个键，表示锁的存在，如果返回 1，说明加锁成功。如果返回 0，说明锁已经存在，加锁失败。<br>设置过期时间：为了防止进程在获得锁后崩溃，导致锁无法释放，需要为锁设置一个过期时间。<br>解锁：使用 DEL 命令删除锁，释放资源。</p>
</details>

<h4 id="数据库优化方案"><a href="#数据库优化方案" class="headerlink" title="数据库优化方案"></a>数据库优化方案</h4><details>
<summary><b> 满意的回答（点击展开）</b></summary>

<ul>
<li>能写在where限定的条件就不要写在having中</li>
<li>避免select *,应该只查询所需字段</li>
<li>大表数据：垂直分表(Union all)</li>
<li><ul>
<li>例如日志表，可以每个月一个日志。</li>
</ul>
</li>
<li>大表数据：水平分表(建一个表，id关联)</li>
<li>like 查询尽量加上左边确定的值 如 like ‘nameSpac%’</li>
<li>减少索引失效</li>
<li><ul>
<li>避免使用 is not null、 or 、not in 、!&#x3D;这样不会走索引</li>
</ul>
</li>
<li><ul>
<li>like ‘%something’ 不会走索引</li>
</ul>
</li>
<li><ul>
<li>隐式类型转换</li>
</ul>
</li>
<li><ul>
<li>前导列失效：在联合索引中，如果查询条件中缺少前导列，索引将失效。</li>
</ul>
</li>
<li><ul>
<li>select 很慢可以用覆盖索引，和联合索引差不多，不过解决的问题不同。</li>
</ul>
</li>
<li>表太多大于3个最好不要连表了，把数据到应用层处理，挑出来要的数据再放sql去查</li>
<li>对于查询慢的sql，经常要用到的条件（select，where ,order by,group by,distinct …)添加索引</li>
<li>varchar 存储浪费空间，特殊定长字段用char</li>
<li>一个表中最好不要超过6个索引</li>
<li>尽量是区分度高的数据作为索引</li>
<li>条件中多个字段要创建索引的情况下，可以创建联合索引（减少回表）。如 age &gt; 18 and hight &lt; 183</li>
<li>当字段类型为字符串(varchar, text等)时，有时候需要索引很长的字符串，这会让索引变得很大，此时可以只将字符串的一部分前缀，建立索引（前缀索引）。</li>
</ul>
</details>

<h4 id="SpringCloud-常用注解"><a href="#SpringCloud-常用注解" class="headerlink" title="SpringCloud 常用注解"></a>SpringCloud 常用注解</h4><details>
<summary><b> 满意的回答（点击展开）</b></summary>

<ul>
<li><p>@SpringBootApplication 这是springboot的配置，主要是约定大于配置，自动加载一些配置文件。</p>
</li>
<li><p>@EnableDiscoveryClient</p>
</li>
<li><ul>
<li>开启服务注册发现功能,如让 Eureka，Nacos 能访问到你</li>
</ul>
</li>
<li><p>@EnableFeignClients</p>
</li>
<li><ul>
<li>用于启用 Feign 客户端，简化 RESTful 服务的调用。</li>
</ul>
</li>
<li><p>@FeignClient</p>
</li>
<li><ul>
<li>加在 feign 接口上，用于其他模块引用</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="variable">@FeignClient</span>(<span class="keyword">value</span><span class="operator">=</span>&quot;XXX-service&quot;)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>@RefreshScope</p>
</li>
<li><ul>
<li>动态刷新配置文件<br><code>@Value(&quot;$&#123;config.property&#125;&quot;)</code></li>
</ul>
</li>
<li><p>@EnableHystrix</p>
</li>
<li><ul>
<li>熔断降级</details></li>
</ul>
</li>
</ul>
<h4 id="Feign-超时时间，超时怎么处理"><a href="#Feign-超时时间，超时怎么处理" class="headerlink" title="Feign 超时时间，超时怎么处理"></a>Feign 超时时间，超时怎么处理</h4><details>
<summary><b> 实际的的回答（点击展开）</b></summary>
递归 `exception.getCause instance of socketTimeoutException`去获取去识别的。
我们项目是catch这个异常转成业务异常，基本上所有的都是把能转成业务异常的都转业务异常，不能转的报联系管理员

<p>不过面试官想问的应该不是这个…</p>
</details>

<details>
<summary><b> 满意的回答（点击展开）</b></summary>
启动类中启用 Hystrix 熔断降级功能
自定义实现 fallback 接口

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">feign:</span><br><span class="line">  client:</span><br><span class="line">    config:</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        connectTimeout: <span class="number">5000</span>  # 连接超时，单位为毫秒</span><br><span class="line">        readTimeout: <span class="number">10000</span>    # 读取超时，单位为毫秒</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;my-service&quot;, fallback = MyServiceFallback.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyServiceClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/endpoint&quot;)</span></span><br><span class="line">    String <span class="title function_">getEndpoint</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h4 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h4><details>
<summary><b> 实际的的回答（点击展开）</b></summary>
我大概知道这是啥，就是你服务启动的时候，比如nacos地址配错了、或者挂了，服务器就会一直刷日志，heartbeat之类的，就是一直找注册中心。springCloud 启动的时候会显示用什么配置文件，用地址是什么，给你展示出来。
应该就是心跳机制，检查服务是否在，免得真正调用的时候才发现出问题。

<p>很显然没答到点上。</p>
</details>

<details>
<summary><b> 满意的回答（点击展开）</b></summary>
心跳机制的主要作用是：

<ul>
<li><p>确保服务可用性：定期向注册中心发送心跳信号，报告服务实例的健康状况。如果心跳信号发送失败，说明服务可能不可用，便于及时发现和处理问题。</p>
</li>
<li><p>预防调用失败：通过心跳机制，可以在服务实例不可用时及时将其从注册中心移除，避免实际调用时发现服务不可用的问题。</p>
</li>
<li><p>提高系统可靠性：定期监控服务健康状况，确保系统各个服务实例处于正常运行状态，提高系统的整体可靠性和稳定性。</p>
</li>
</ul>
<p>Nacos 提供两种健康检查机制，分别对应不同类型的服务实例：</p>
<ul>
<li>临时实例（非持久化实例）：</li>
</ul>
<p>机制：客户端主动上报心跳消息。</p>
<p>特点：临时实例不会在 Nacos 服务端持久化存储，需要通过上报心跳的方式进行保活。如果一段时间内没有上报心跳，实例会被 Nacos 服务端摘除</p>
<ul>
<li>永久实例（持久化实例）：</li>
</ul>
<p>机制：服务器端反向探测健康状况。</p>
<p>特点：永久实例会在 Nacos 服务端持久化存储，即使注册实例的客户端进程不在，实例也不会从服务端删除，只会将健康状态设为不健康</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: my-service</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 127.0.0.1:8848</span><br><span class="line">        ephemeral: true  # 设置实例为临时实例</span><br></pre></td></tr></table></figure>

</details>
]]></content>
  </entry>
  <entry>
    <title>2025-02-28 面试总结</title>
    <url>/2025/02/28/2025-02-28-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>这两天的面试能约就约，因为马上就是周末了基本上没公司上班，今天约了两场，上午和下午。<br>我遇到不会的答不上来，或者答出来不是很满意，就很紧张然后磕磕绊绊的，得多面试见识不同的面试官练练胆子，然后看看面试中级程序员主要问哪些问题，</p>
</blockquote>
<hr>
<h1 id="面试过程"><a href="#面试过程" class="headerlink" title="面试过程"></a>面试过程</h1><p><strong>上午场的面试：</strong> </p>
<blockquote>
<p>上午的面试比较无厘头，提的问题我基本能答上来，最后问我还需要了解一些什么？最后就说让我回去等消息，然后软件上说我不通过…问他原因也不说，不过还是总结一下他的问题。</p>
</blockquote>
<ul>
<li><p>线程的创建方式</p>
</li>
<li><p>线程的几种状态</p>
</li>
<li><p>线程池几种策略</p>
</li>
<li><p>为什么要三次握手</p>
</li>
<li><p>Redis 几种类型</p>
</li>
<li><p>Jvm内存模型</p>
</li>
<li><p>Jvm如何调优</p>
</li>
<li><p>你还需要了解一些什么？</p>
</li>
</ul>
<hr>

<p><strong>下午场的面试：</strong></p>
<blockquote>
<p>下午的面试体验还可以，但问了几个八股文我答不上来应该是没过，这个公司面试的人比较多，要先填表，hr 还会倒杯水喝，映像很不错比昨天放松一些。我前面那个哥们进去不到 5 分钟就出来了，下一个是我。但面试官看起来比较和善，自我介绍后，问了一些学校、然后工作的项目经历，谈了大概快 20 多分钟整体上还不错挺轻松的，但随之就问八股文了，丫的，问的这些八股文太抽象了，我是一个答不上来，虽然我看到过这种题目但是真没去记这些东西，但是我也说了很多自己的理解，把我知道的都说了，很显然是不标准的，然后开始紧张了…类似于空气凝固了，面试官估计也懂，问我哪时候开始准备面试的，我说昨天才开始面试。</p>
</blockquote>
<ul>
<li><p>SpringBean 生命周期</p>
</li>
<li><p>Jvm 垃圾回收的几种算法</p>
</li>
<li><p>循环依赖怎么解决</p>
</li>
</ul>
<h1 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h1><h4 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h4><details>
<summary><b> 我觉得满意的回答（点击展开）</b></summary>
四种：

<ul>
<li>继承 Thread 类</li>
<li>实现 RunAble 接口</li>
<li>实现 CallAble 接口</li>
<li>线程池</li>
</ul>
<p>要是只说这四种也太逊了，我觉得得知道哪些时候用哪种，或者说应用场景优劣势。</p>
<ul>
<li><p>继承 Thread 类</p>
</li>
<li><ul>
<li>优点：能直接调用 Thread 类的方法，如 getName,其他实现的接口得用 Thread.currentThread才行</li>
</ul>
</li>
<li><ul>
<li>缺点：因为 Java 是单继承多实现的，拓展性差。</li>
</ul>
</li>
<li><p>实现 RunAble 接口</p>
</li>
<li><ul>
<li>优点：拓展性高，一个类可以实现多个接口，而且比1方法写法简单，匿名内部类只需写方法的实现即可。</li>
</ul>
</li>
<li><ul>
<li>缺点：不能直接调用 Thread 类的方法</li>
</ul>
</li>
<li><p>使用 Callable 和 Future</p>
</li>
<li><ul>
<li>优点：可以接受返回值</li>
</ul>
</li>
<li><ul>
<li>缺点：相对复杂？性能问题，要创建Future 对象，有一点点开销。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">extracted</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 FutureTask 包装 Callable 任务</span></span><br><span class="line">    FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 创建并启动线程来执行任务</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">    thread.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取任务执行结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">        <span class="comment">// 打印结果</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Executors 接口实现线程池</li>
<li><ul>
<li>优点：高效，面对使用对象简单</li>
</ul>
</li>
<li><ul>
<li>缺点：管理和维护较为复杂</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</details>


<h4 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h4><details>
<summary><b> 我觉得满意的回答（点击展开）</b></summary>

<ul>
<li>新建 new Thread()</li>
<li>就绪 start() 跟cpu抢夺资源</li>
<li>运行 实际在跑</li>
<li>阻塞 线程被锁</li>
<li>等待 wait(),join(),sleep(),sleep(argument),join(arg),wait(arg)</li>
<li>终止</details></li>
</ul>
<h4 id="线程池几种策略"><a href="#线程池几种策略" class="headerlink" title="线程池几种策略"></a>线程池几种策略</h4><details>
<summary><b> 我觉得满意的回答（点击展开）</b></summary>

<p>当线程池和任务队列都满时，线程池会拒绝新任务。常见的拒绝策略包括：</p>
<ul>
<li>AbortPolicy 抛出 RejectedExecutionException 异常，默认策略。</li>
<li>CallerRunsPolicy 由调用线程处理该任务。</li>
<li>DiscardPolicy 直接丢弃任务，不抛出异常</li>
<li>DiscardOldestPolicy 丢弃队列中最旧的任务，并尝试重新提交新任务。</details></li>
</ul>
<h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><h4 id="Redis-几种类型"><a href="#Redis-几种类型" class="headerlink" title="Redis 几种类型"></a>Redis 几种类型</h4><h4 id="Jvm内存模型"><a href="#Jvm内存模型" class="headerlink" title="Jvm内存模型"></a>Jvm内存模型</h4><h4 id="Jvm如何调优"><a href="#Jvm如何调优" class="headerlink" title="Jvm如何调优"></a>Jvm如何调优</h4><h4 id="你还需要了解一些什么？"><a href="#你还需要了解一些什么？" class="headerlink" title="你还需要了解一些什么？"></a>你还需要了解一些什么？</h4>]]></content>
  </entry>
  <entry>
    <title>2025-03-04 面试总结</title>
    <url>/2025/03/04/2025-03-04-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>今天约了两场，上午和下午。<br>上午是线上会议面试<br>下午是线下现场面</p>
</blockquote>
<hr>
<h1 id="面试过程"><a href="#面试过程" class="headerlink" title="面试过程"></a>面试过程</h1><p><strong>上午场的面试：</strong> </p>
<blockquote>
<p>上午的面试是腾讯会议面试，聊了半个钟感觉还行，我开了摄像头感觉我巨帅，看到会议中的自己感觉很自信，因为见不到面试官只能听到他声音，我答不上来也没有那么紧张，体验还不错。我不喜欢面试官一边拿着我简历一边看着我审问我的感觉。<br>提前预总结一下，感觉好多能说的没说上来，比如sql优化，就说了两个方面，其实这方面能说很多的，之前总结那么多都忘记说了。晕晕晕</p>
</blockquote>
<ul>
<li>Java 常用的设计模式</li>
<li>SpringBean 的作用</li>
<li>用过哪些代理模式</li>
<li>docker 查看容器</li>
<li>docker 怎么导出</li>
<li>docker 要修改端口，挂载目录怎么做</li>
<li>redis 有几种类型</li>
<li>MySQL 的隔离级别是</li>
<li>sql 优化</li>
</ul>
<hr>
<p><strong>下午场的面试：</strong></p>
<p><strong>面试前</strong></p>
<p>面试地点是 深业上城，是好几座高楼大厦，特别的高，然后主体建筑是蓝色玻璃的，感觉我就像个土狗啊，进去里面一股女人的香水味。<br>然后进去问前台服务员说明我是来这里面试，让我登记名字，里面还有座椅给休息，而且进去的门庭很高，电梯也是那种分层的电梯，很高级的感觉。</p>
<details>
<summary><strong>随手拍的深业上城图片（点击展开）</strong></summary>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2025/03/04/2025-03-04-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/1741093867256.jpg"
                        alt="1741093867256.jpg"
                 ><br><img  
                       lazyload
                       alt="image"
                       data-src="/2025/03/04/2025-03-04-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/1741093790525.jpg"
                        alt="1741093790525.jpg"
                 ></p>
</details>

<details>
<summary><strong>随手拍的深业上城门庭内部（点击展开）</strong></summary>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2025/03/04/2025-03-04-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/1741093867204.jpg"
                        alt="1741093867204.jpg"
                 ><br><img  
                       lazyload
                       alt="image"
                       data-src="/2025/03/04/2025-03-04-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/1741093790685.jpg"
                        alt="1741093790685.jpg"
                 ><br><img  
                       lazyload
                       alt="image"
                       data-src="/2025/03/04/2025-03-04-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/1741093790730.jpg"
                        alt="1741093790730.jpg"
                 ></p>
</details>

<details>
<summary><strong>岗厦北地铁站真漂亮（点击展开）</strong></summary>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2025/03/04/2025-03-04-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/FFC01AE5A1E405186C316B2F8D530012.jpg"
                       
                 ><br><img  
                       lazyload
                       alt="image"
                       data-src="/2025/03/04/2025-03-04-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/E1C759A5359BAAF3D149D9CA08AECACF.jpg"
                       
                 ><br><img  
                       lazyload
                       alt="image"
                       data-src="/2025/03/04/2025-03-04-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/0F29702FD5C6D0609E9E4A1AAA348495.jpg"
                       
                 ></p>
</details>

<blockquote>
<p>面试体验不错，聊了有 40 多分钟，但是后半段面试官有点赶，可能是还有人在排队等候面试。面试官和我坐的很近，我描述东西的时候手又喜欢比划，讲一些底层的数据结构之类的就在桌上比划给他看。<br>面试过程基本上把我简历上项目做过的功能问了个遍，技术点的也问了几个，都能答上来，虽然不是标准级别的答案，但我觉得至少把我理解的东西给表达出来了，而且面试官给到我的反馈也是正向的，比如点头等，让我能够没有压力的表达自己的想法。</p>
</blockquote>
<ul>
<li>Java 代理模式</li>
<li>Docker 哪些些命令</li>
<li>字符串 String、StringBuilder 区别</li>
<li>集合 ArrayList、LinkedList 区别</li>
</ul>
<h1 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h1><h4 id="Java-常用的设计模式"><a href="#Java-常用的设计模式" class="headerlink" title="Java 常用的设计模式"></a>Java 常用的设计模式</h4><h4 id="SpringBean-的作用"><a href="#SpringBean-的作用" class="headerlink" title="SpringBean 的作用"></a>SpringBean 的作用</h4><h4 id="用过哪些代理模式"><a href="#用过哪些代理模式" class="headerlink" title="用过哪些代理模式"></a>用过哪些代理模式</h4><h4 id="docker-查看容器"><a href="#docker-查看容器" class="headerlink" title="docker 查看容器"></a>docker 查看容器</h4><h4 id="docker-怎么导出"><a href="#docker-怎么导出" class="headerlink" title="docker 怎么导出"></a>docker 怎么导出</h4><h4 id="docker-要修改端口，挂载目录怎么做"><a href="#docker-要修改端口，挂载目录怎么做" class="headerlink" title="docker 要修改端口，挂载目录怎么做"></a>docker 要修改端口，挂载目录怎么做</h4><h4 id="redis-有几种类型"><a href="#redis-有几种类型" class="headerlink" title="redis 有几种类型"></a>redis 有几种类型</h4><h4 id="MySQL-的隔离级别是"><a href="#MySQL-的隔离级别是" class="headerlink" title="MySQL 的隔离级别是"></a>MySQL 的隔离级别是</h4><h4 id="sql-优化"><a href="#sql-优化" class="headerlink" title="sql 优化"></a>sql 优化</h4><h4 id="Java-代理模式"><a href="#Java-代理模式" class="headerlink" title="Java 代理模式"></a>Java 代理模式</h4><details>
<summary><b>我认为满意的回答（点击展开）</b></summary>

<p>我说了自己的理解：代理主要是增强一些方法，比如增强方法加入日志、或者提前校验入参等。<br>我司主要是代理请求方法切入打印入参出餐。其实就是项目中的aop</p>
<p>有两种代理模式：</p>
<ul>
<li><p>静态代理：继承父类重写要被代理的方法，在重写的方法上加你要加的代码 </p>
</li>
<li><ul>
<li>缺点就是需要一直重写，很麻烦。不能批量弄</li>
</ul>
</li>
<li><p>动态代理：jdk cglib</p>
</li>
<li><p>&#x2F;&#x2F;TODO 原理 好像是接口和继承关系才能用</p>
</li>
<li><p>&#x2F;&#x2F;TODO 突然想起来自己很早的时候折腾过这个玩意，挺牛逼的，是 java 运行的时候动态生成的那种很古早的代码，还得用命令才不会删除具体的 .class 实现。有时间总结一下</p>
</details></li>
</ul>
<h4 id="Docker-哪些些命令"><a href="#Docker-哪些些命令" class="headerlink" title="Docker 哪些些命令"></a>Docker 哪些些命令</h4><h4 id="字符串-String、StringBuilder-区别"><a href="#字符串-String、StringBuilder-区别" class="headerlink" title="字符串 String、StringBuilder 区别"></a>字符串 String、StringBuilder 区别</h4><h4 id="集合-ArrayList、LinkedList-区别"><a href="#集合-ArrayList、LinkedList-区别" class="headerlink" title="集合 ArrayList、LinkedList 区别"></a>集合 ArrayList、LinkedList 区别</h4>]]></content>
  </entry>
  <entry>
    <title>Centos基本的云服务器配置</title>
    <url>/2024/06/20/Centos%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>玩云服务器时想装一个 neovim 的插件，因为 Centos 8 已经不维护了，然而我要用的 neovim 一直在更新用到了glibc,不能直接安装，然而他又是linux一个底层的玩意,只能编译安装，<br>然后就把系统搞崩了，命令全部用不了，我看了网上的 <a class="link"   href="https://blog.csdn.net/qq_56776641/article/details/134027044" >恢复教程<i class="fas fa-external-link-alt"></i></a> 有点困难，直接重置得了。</p>
<p>于是乎顺手记录一下安装基本插件的过程</p>
</blockquote>
<h2 id="提前总结一下"><a href="#提前总结一下" class="headerlink" title="提前总结一下"></a>提前总结一下</h2><p>基本上能用yum就用yum，不行就去官方找对应操作系统的安装方式，实在不行再自己编译安装（最好提前拍个快照）。</p>
<h2 id="一些常用的脚本、命令、工具："><a href="#一些常用的脚本、命令、工具：" class="headerlink" title="一些常用的脚本、命令、工具："></a>一些常用的脚本、命令、工具：</h2><h3 id="yum-源更换"><a href="#yum-源更换" class="headerlink" title="yum 源更换"></a>yum 源更换</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/yum.repos.d      //进入/etc/yum.repos.d目录</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo</span><br><span class="line">yum -y clean all   //清除所有文件</span><br><span class="line">yum -y makecache   //建立缓存</span><br></pre></td></tr></table></figure>

<h3 id="nvm-（node版本管理"><a href="#nvm-（node版本管理" class="headerlink" title="nvm （node版本管理)"></a>nvm （node版本管理)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -o- https://ghfast.top/https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash</span><br></pre></td></tr></table></figure>

<h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install zsh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># ohmyzsh</span></span></span><br><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure>

<h3 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install tmux</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># ohmytmux</span></span></span><br></pre></td></tr></table></figure>

<h3 id="zsh-plugin"><a href="#zsh-plugin" class="headerlink" title="zsh-plugin"></a>zsh-plugin</h3><ul>
<li>zsh-syntax-highlighting</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>

<ul>
<li>zsh-autosuggestions</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Git 设置 配置分支</title>
    <url>/2024/02/15/Git%20%E8%AE%BE%E7%BD%AE%20%E9%85%8D%E7%BD%AE%E5%88%86%E6%94%AF/</url>
    <content><![CDATA[<h2 id="缘故"><a href="#缘故" class="headerlink" title="缘故"></a>缘故</h2><p>项目总有一些本地文件不能他提交到服务器上，例如 yml 配置信息，打印日志代码等。又不想提交代码的时候总是勾选。所以想着弄个settings分支并且与开发分支（dev）保持一致。以下是折腾过程。</p>
<h2 id="开发的时候拉去代码自动-rebase-settings"><a href="#开发的时候拉去代码自动-rebase-settings" class="headerlink" title="开发的时候拉去代码自动 rebase settings"></a>开发的时候拉去代码自动 rebase settings</h2><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">-- 更新最新的远程分支</span><br><span class="line">git fetch o dev test prod</span><br><span class="line"></span><br><span class="line">-- 暂存</span><br><span class="line">git stash save &#x27;before checkout :)&#x27;</span><br><span class="line"></span><br><span class="line">-- 复位 dev 为最新</span><br><span class="line">git checkout -B dev o/dev</span><br><span class="line">git checkout settings</span><br><span class="line"></span><br><span class="line">-- rebase settings 分支到最新的dev 然后我的分分支就基于settings开发 </span><br><span class="line">git rebase --onto dev settings</span><br><span class="line"></span><br><span class="line">-- dev-mine 为我开发的需求</span><br><span class="line">git checkout dev-mine</span><br><span class="line"></span><br><span class="line">-- rebase 配置，然后开始需求开发</span><br><span class="line">git rebase settings</span><br><span class="line"></span><br><span class="line">-- 开发完了之后</span><br><span class="line">-- 左边是开区间（不包含settngs提交的rebase）</span><br><span class="line">git rebase --onto dev yulei-settings dev-mine</span><br><span class="line"></span><br><span class="line">-- 提交合并请求</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Github Action 自动部署博客</title>
    <url>/2024/06/20/Github-Action-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>我是用的是 hexo 静态博客，该博客原理是解析 markdown 成 HTML 文件。</p>
<hr>
<p>命令 <code>hexo generate</code>会把原始的博客转换成一个可以访问的 public 文件夹（类似于前端工程的 dist 文件夹）。 把这个文件夹放服务器上 nginx 代理就是你的博客了。 我是用 github 仓库管理博客，<code>hexo generate</code> 生成文件夹要部署到服务器上，得把它打包到服务器上 <code>/www/wwwroot/leijiba.cn</code> 解压才行。</p>
<p>为了写完博客提交到github的后自动执行部署操作，于是有了这篇文章</p>
<p>其实有网上有很多方案，我采用的是 Github Action</p>
<h2 id="Github-Action"><a href="#Github-Action" class="headerlink" title="Github Action"></a>Github Action</h2><p>原理是推送代码到仓库后，github 会给你一个虚拟机，配置好配置文件虚拟机就会按照yaml文件执行命令。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Hexo</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span> <span class="comment"># 或你使用的默认分支名称</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">blog</span> <span class="string">source</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">blog</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;18&quot;</span> <span class="comment"># 设置 Node.js 版本</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">        <span class="attr">working-directory:</span> <span class="string">./blog</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Hexo</span> <span class="string">CLI</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span></span><br><span class="line">        <span class="attr">working-directory:</span> <span class="string">./blog</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Generate</span> <span class="string">static</span> <span class="string">pages</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line">        <span class="attr">working-directory:</span> <span class="string">./blog</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">personal_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PERSONAL_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">publish_dir:</span> <span class="string">./blog/public</span></span><br><span class="line">          <span class="attr">external_repository:</span> <span class="string">notfornothing/notfornothing.github.io</span> <span class="comment"># 更改为你的 GitHub Pages 仓库, username 是你的用户名</span></span><br><span class="line">          <span class="attr">publish_branch:</span> <span class="string">main</span> <span class="comment"># GitHub Pages 分支</span></span><br><span class="line">          </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">JD_Server</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">easingthemes/ssh-deploy@v2.1.1</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="comment"># 本地.ssh文件下的私钥id_rsa，存在secrets的PRIVATE_KEY中</span></span><br><span class="line">          <span class="attr">SSH_PRIVATE_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.JD_SSH_PRIVATE_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="comment"># 复制操作的参数。&quot;-avzr --delete&quot;意味部署时清空服务器目标目录下的文件</span></span><br><span class="line">          <span class="attr">ARGS:</span> <span class="string">&quot;-avzr --delete&quot;</span></span><br><span class="line">          <span class="comment"># 源目录，相对于$GITHUB_WORKSPACE根目录的路径</span></span><br><span class="line">          <span class="attr">SOURCE:</span> <span class="string">&quot;./blog/public/&quot;</span></span><br><span class="line">          <span class="comment"># 服务器域名/IP</span></span><br><span class="line">          <span class="attr">REMOTE_HOST:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.JD_REMOTE_HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="comment"># 服务器默认用户名为root</span></span><br><span class="line">          <span class="attr">REMOTE_USER:</span> <span class="string">&quot;root&quot;</span></span><br><span class="line">          <span class="comment"># 目标目录</span></span><br><span class="line">          <span class="attr">TARGET:</span> <span class="string">&#x27;/opt/hexo&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>I-like-KFC-And-McDonald&#39;s</title>
    <url>/2025/02/23/I-like-KFC-And-McDonald&#39;s/</url>
    <content><![CDATA[<h2 id="我喜欢"><a href="#我喜欢" class="headerlink" title="我喜欢"></a>我喜欢</h2><p>我没搞图片外链，这图片放我放服务器上的，服务器带宽太小只有5M。<br>好像有cdn这个东西，这个有时间在弄了。</p>
<hr>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2025/02/23/I-like-KFC-And-McDonald's/2F66906AE559E3E1012ACC789D38BF87.jpg"
                        alt="2F66906AE559E3E1012ACC789D38BF87.jpg"
                 ><br><img  
                       lazyload
                       alt="image"
                       data-src="/2025/02/23/I-like-KFC-And-McDonald's/9812D950000EC834F1EC39FEB51987E6.jpg"
                        alt="9812D950000EC834F1EC39FEB51987E6.jpg"
                 ><br><img  
                       lazyload
                       alt="image"
                       data-src="/2025/02/23/I-like-KFC-And-McDonald's/77610A1DAF6184B86F0E1E4DC38330CA.jpg"
                        alt="77610A1DAF6184B86F0E1E4DC38330CA.jpg"
                 ><br><img  
                       lazyload
                       alt="image"
                       data-src="/2025/02/23/I-like-KFC-And-McDonald's/BB36721806F7A8640742FFAF67536036.jpg"
                        alt="BB36721806F7A8640742FFAF67536036.jpg"
                 ><br><img  
                       lazyload
                       alt="image"
                       data-src="/2025/02/23/I-like-KFC-And-McDonald's/BD13BF58EEA4E7102E346E94F949E002.jpg"
                        alt="BD13BF58EEA4E7102E346E94F949E002.jpg"
                 ><br><img  
                       lazyload
                       alt="image"
                       data-src="/2025/02/23/I-like-KFC-And-McDonald's/D1AAA85894C42ED1113F756A71E5C6E7.jpg"
                        alt="D1AAA85894C42ED1113F756A71E5C6E7.jpg"
                 ><br><img  
                       lazyload
                       alt="image"
                       data-src="/2025/02/23/I-like-KFC-And-McDonald's/F2E10C93E0EB4592659594B4F8B0808C.jpg"
                        alt="F2E10C93E0EB4592659594B4F8B0808C.jpg"
                 ><br><img  
                       lazyload
                       alt="image"
                       data-src="/2025/02/23/I-like-KFC-And-McDonald's/4a49b266d9ae1a65344a9b8ebdf9aa8-min.jpg"
                       
                 ><br><img  
                       lazyload
                       alt="image"
                       data-src="/2025/02/23/I-like-KFC-And-McDonald's/6cef04e9b240e7735773186c2d0690b-min.jpg"
                       
                 ><br><img  
                       lazyload
                       alt="image"
                       data-src="/2025/02/23/I-like-KFC-And-McDonald's/50b9dd5c666bd6d2a403946655400ef-min.jpg"
                       
                 ><br><img  
                       lazyload
                       alt="image"
                       data-src="/2025/02/23/I-like-KFC-And-McDonald's/50d05593f90f84fff4b88357d379bfd-min.jpg"
                       
                 ></p>
]]></content>
  </entry>
  <entry>
    <title>Java 为什么要使用泛型</title>
    <url>/2022/11/01/Java-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Java-历史"><a href="#Java-历史" class="headerlink" title="Java 历史"></a>Java 历史</h1><p>泛型是从 Java 1.5 出现的。</p>
<h2 id="不用泛型会有哪些不便性"><a href="#不用泛型会有哪些不便性" class="headerlink" title="不用泛型会有哪些不便性"></a>不用泛型会有哪些不便性</h2><h3 id="需求：遍历集合"><a href="#需求：遍历集合" class="headerlink" title="需求：遍历集合"></a>需求：遍历集合</h3><p>  Java1.5 之前的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCase</span> &#123;</span><br><span class="line">  <span class="meta">@org</span>.junit.Test</span><br><span class="line">  <span class="meta">@SuppressWarnings(value = &#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="string">&quot;Sparrow&quot;</span>);</span><br><span class="line">    list.add(<span class="number">23</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object obj : list) &#123;</span><br><span class="line">      <span class="comment">//多态，查找父类的 toString 方法，打印出结果，</span></span><br><span class="line">      System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果我们遍历的时候就想得到自己想要的数据类型</span></span><br><span class="line">    <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">      <span class="comment">//在取 Integer 的时候会报类型转换错误</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">obj</span> <span class="operator">=</span> (String) o;</span><br><span class="line">      System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sparrow</span><br><span class="line">23</span><br><span class="line">Sparrow</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br><span class="line">	at cn.leijiba.config.MyConfig.Test.main(Test.java:20)</span><br></pre></td></tr></table></figure>

<p>图例</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2022/11/01/Java-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B/Snipaste_2024-03-26_15-21-17.png"
                       
                 ></p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>  如图抛错所示，List 存和取元素都是 Object 类型。所以存在运行时异常，编译不会报错有安全隐患，不方便写代码。</p>
<p>  如果我们遍历的时候就想得到自己想要的数据类型有以下解决办法</p>
<h4 id="解决办法-1："><a href="#解决办法-1：" class="headerlink" title="解决办法 1："></a>解决办法 1：</h4><p>  在遍历集合的时候用 instance of 去判断属于哪个类，再进行强转</p>
<blockquote>
<p>但是这样不合理，类很多，而且只能处理逻辑已知的类型，不知情的类型还是会报错。</p>
</blockquote>
<h4 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法 2:"></a>解决办法 2:</h4><p>  限定存入的类型，也限制取出的类型。所以会有如下代码出现：</p>
<blockquote>
<p>但是这样对于未知的类型还是没法判断。而且太过于繁琐。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringArrayList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StringArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = <span class="keyword">new</span> <span class="title class_">StringList</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (String) list.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        list.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引入泛型后"><a href="#引入泛型后" class="headerlink" title="引入泛型后"></a>引入泛型后</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>源代码：</p>
<p><code>System.out.println(list.get(i));</code></p>
</li>
<li><p>class 字节码：</p>
<p><code>System.out.println((String)list.get(i));</code></p>
</li>
</ul>
<p>可以知道编译器会自动转换</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>  1.减少 Java5 以往代码的冗余，提高代码复用性</p>
<p>  2.返回泛型类型时，会自动强转，强转后的变量必须要当前泛型类或者其父类（Object 之类）接收，省时省力</p>
<blockquote>
<p>Java 执行顺序：*.java 文件 （编译） -&gt; *.class 字节码 （运行）-&gt;  jvm</p>
</blockquote>
<p>  3.由 2 知：把运行时报错转成了编译就报错，编译没过自然没法运行，减少试错成本</p>
]]></content>
  </entry>
  <entry>
    <title>Java 泛型擦除小实验</title>
    <url>/2022/11/05/Java-%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4%E5%B0%8F%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>很多人看到泛型就害怕，其实你只要想象成人为的一个约束。</li>
<li>泛型是编译期间的行为，下面会通过程序运行时的反射案例校验。</li>
<li>泛型是防止错误输入的，本质上就是 <code>Object</code>,存在的意义是方便编码确认类型。只在编译阶段有效 – 绕过编译无效</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>  Test.Java 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@org.junit.Test</span><br><span class="line">public void test1() throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">    list.add(&quot;A&quot;);</span><br><span class="line">//        编译报错，类型不同不能转换</span><br><span class="line">//        list.add(1);</span><br><span class="line">    @SuppressWarnings(&quot;rawtypes&quot;)</span><br><span class="line">    Class&lt;? extends List&gt; aClass = list.getClass();</span><br><span class="line">    aClass.getMethod(&quot;add&quot;, Object.class).invoke(list, 666);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    System.out.println((String) list.get(0));</span><br><span class="line">    System.out.println((String) list.get(1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/./Java-%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4/Snipaste_2024-03-26_15-12-36.png"
                       
                 ></p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ul>
<li><p>通过反射（运行时执行方法）,把 <code>Integer</code> 类型 666 放入 list 中。</p>
</li>
<li><p>可知道程序运行时 <code>List&lt;String&gt;</code> 并没有被约束（即放入时就报错）。</p>
</li>
<li><p>所以 <code>List&lt;String&gt;</code> 就相当于 <code>List&lt;Object&gt;</code> 所以可以取出来。</p>
</li>
<li><p>由于是泛型返回值类型自动强转（可以看 class 文件结果），强转会会报运行时异常。</p>
</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li>所以 Java 的泛型只是编译期的约束行为。 应该尽量避免这种运行时能赋值非泛型类型值的行为，不然会导致后面自动强转报运行错误。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>JavaSE 总结</title>
    <url>/2021/06/20/JavaSE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="面试总结："><a href="#面试总结：" class="headerlink" title="面试总结："></a>面试总结：</h1><h2 id="Java-内存分区"><a href="#Java-内存分区" class="headerlink" title="Java 内存分区"></a>Java 内存分区</h2><details><summary>图解（点击展开）</summary>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/06/20/JavaSE%E6%80%BB%E7%BB%93/Snipaste_2022-03-20_19-44-14.jpg"
                        alt="PANGU_DISABLE"
                 ></p>
</details>

<ul>
<li><a class="link"   href="https://www.bilibili.com/video/BV12t411u726" >java jvm 内存模型<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="JVM-分区？"><a href="#JVM-分区？" class="headerlink" title="JVM 分区？"></a>JVM 分区？</h2><h3 id="根据上一个问题得，堆区是用来存放创建对象的地方，堆区的清理需要-JVM-的垃圾收集器清理。"><a href="#根据上一个问题得，堆区是用来存放创建对象的地方，堆区的清理需要-JVM-的垃圾收集器清理。" class="headerlink" title="根据上一个问题得，堆区是用来存放创建对象的地方，堆区的清理需要 JVM 的垃圾收集器清理。"></a>根据上一个问题得，堆区是用来存放创建对象的地方，堆区的清理需要 JVM 的垃圾收集器清理。</h3><ul>
<li>GCRoot– 栈 &#x2F; 本地方法栈 &#x2F; 方法区域<ul>
<li>被 GCRoot 直接或者间接引用的对象是不能被删除的</li>
</ul>
</li>
<li>孤立存在的对象，没有和 GCRoot 有直接的关系。这些对象可以被删除</li>
</ul>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ul>
<li>标记清理 – 标记存活的对象，清理未被标记的对象<ul>
<li>缺点：会产生内存碎片，如果你删除了两个连续的 1KB 的对象。来一个 2KB 的对象放不下那个地方，所以会有内存碎片。</li>
</ul>
</li>
<li>标记整理 – 在上面基础上把清理之后。后面的对象补上来，紧凑。<ul>
<li>缺点：代价大，所有对象会前移，补空缺的内存碎片。</li>
</ul>
</li>
<li>复制算法 – 将整个内存一分为二，不需要删除的复制到另一边。<ul>
<li>缺点：需要内存空间大。</li>
</ul>
</li>
</ul>
<h3 id="JVM-分区"><a href="#JVM-分区" class="headerlink" title="JVM 分区"></a>JVM 分区</h3><h4 id="young-区-–-也叫新生代"><a href="#young-区-–-也叫新生代" class="headerlink" title="young 区 – 也叫新生代"></a>young 区 – 也叫新生代</h4><ul>
<li>内部又分为 Eden 区域，作为对象初始分配的区域还有两个 Survivor（也叫幸存区），有时候也叫 from、to 区域，被用来放置从 young GC（也叫 Minor GC ,Eden 区满了就会触发） 中保留下来的对象。young GC 采用的是复制算法。</li>
</ul>
<p><strong>每一次 young GC 后，对象的年龄就会加一，然后超过 6 次。就会到 old 区 , 然后大的对象 (Integer.maxValue) 也会直接存到 old 区，因为前面不容易啊！</strong></p>
<h4 id="old-区-–-也叫老年代"><a href="#old-区-–-也叫老年代" class="headerlink" title="old 区 – 也叫老年代"></a>old 区 – 也叫老年代</h4><ul>
<li>标记清理和标记整理主要用于 old GC .</li>
<li>old GC 一般会同时伴随 young GC. 称为 Full GC.</li>
<li>Full GC 会引起 Java 程序暂停，应该尽量减少次数。</li>
</ul>
<h4 id="Permanent-区-–-永久代？"><a href="#Permanent-区-–-永久代？" class="headerlink" title="Permanent 区 – 永久代？"></a><del>Permanent 区 – 永久代？</del></h4><ul>
<li>永久代在 JDK 7 中逐渐变化，到 JDK 8 之后完全消失，合并到了 Native 堆中</li>
</ul>
<details><summary>图解（点击展开）</summary>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/06/20/JavaSE%E6%80%BB%E7%BB%93/Snipaste_2022-03-20_19-43-36.jpg"
                        alt="PANGU_DISABLE"
                 ></p>
</details>


<p><a class="link"   href="https://www.bilibili.com/video/BV1dt411u7wi/" >GC 过程<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="Java-中的-equals-与-hashCode-的区别与联系"><a href="#Java-中的-equals-与-hashCode-的区别与联系" class="headerlink" title="Java 中的 &#x3D;&#x3D;, equals 与 hashCode 的区别与联系"></a><a class="link"   href="https://blog.csdn.net/justloveyou_/article/details/52464440" >Java 中的 &#x3D;&#x3D;, equals 与 hashCode 的区别与联系<i class="fas fa-external-link-alt"></i></a></h2><hr>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p>一般把常量写 前面 即 “常量”.equals() 防止空指针异常</p>
<ul>
<li>初衷：就是判断两个对象的 content 是否相同。</li>
</ul>
<hr>
<p>Objects 类：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></blockquote>
<blockquote>
<p>Objects 的意思是判断两个对象是否相同</p>
<p>很显然，在 Object 类中，equals 方法是用来比较两个对象的引用是否相等，即是否指向同一个对象。</p>
</blockquote>
<blockquote>
<p>但是我们知道：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);<span class="comment">// 这里指向不同的 hello</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);<span class="comment">// 这里指向不同的 hello 却是 true</span></span><br><span class="line">System.out.println(str1.equals(str2));<span class="comment">//ture</span></span><br></pre></td></tr></table></figure>

<p>这是因为 String 重写了 equals() 方法：</p>
</blockquote>
<p>String 类：（重写了 equals 方法） 不需要看懂</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码：</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;<span class="comment">// 先比较引用类型是否相同（即是佛为同一对象）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;<span class="comment">// 在判断类型是否一致</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="type">char</span> v1[] = value;</span><br><span class="line">                <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])<span class="comment">// 最后比较内容是否一致</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Java 中所有内置的类的 equals 方法的实现步骤均是如此，特别是诸如 Integer，Double 等包装器类。</strong></p>
<ul>
<li>一般分为三个步骤：<ul>
<li>先比较引用类型是否相同（即是佛为同一对象）</li>
<li>在判断类型是否一致</li>
<li>最后比较内容是否一致</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
</blockquote>
<h3 id="判断数组是不是对象"><a href="#判断数组是不是对象" class="headerlink" title="判断数组是不是对象"></a>判断数组是不是对象</h3><hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;判断数组是否是对象？&quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] chars = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line">    System.out.println(chars);<span class="comment">// 这是字符数组的特性</span></span><br><span class="line">    <span class="comment">// 可以理解为指向的第一个数组的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] ints = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    System.out.println(ints);<span class="comment">// 这样就不行了，没有重写 toString 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chars <span class="keyword">instanceof</span> Object) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数组是对象&quot;</span>);<span class="comment">// 输出为这个</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数组不是对象&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于-toString-方法"><a href="#关于-toString-方法" class="headerlink" title="关于 toString() 方法"></a>关于 toString() 方法</h3><hr>
<p>Object 类：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这样比较 hashCode() 没有意义。因为我们要的是比较里面的 String 或者说是实质性的东西</p>
</blockquote>
<p>String 类：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String 类重写了 toString 方法</p>
</blockquote>
<p>数组类：</p>
<p>int[] ints &#x3D;new int[10]</p>
<p>char[] chars&#x3D;new char[10]</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] chars = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line">System.out.println(chars);<span class="comment">//abcdefg</span></span><br><span class="line"><span class="comment">// 这是字符数组的特性</span></span><br><span class="line"><span class="comment">// 可以理解为指向的第一个数组的地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] ints = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">System.out.println(ints);<span class="comment">// 这样就不行了，没有重写 toString 方法</span></span><br></pre></td></tr></table></figure>

<p>数组类没有重写 toString( )  chars 数组可以打印是因为 chars 指向第一个数组的地址</p>
</blockquote>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><hr>
<p><strong>Integer</strong> 的两种构造方法：</p>
<ul>
<li><ul>
<li><table>
<thead>
<tr>
<th>Constructor and Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>Integer(int value)</code>  构造一个新分配的 <code>Integer</code>对象，该对象表示指定的 <code>int</code>值。</td>
</tr>
<tr>
<td><code>Integer(String s)</code>  构造一个新分配 <code>Integer</code>对象，表示 <code>int</code>由指示值  <code>String</code>参数。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Integer 在给 -128 到 127 用高效的效果 相同的数据存一次</p>
<p>但是在其他范围内存的是两个对象 (<strong>只要 Integer 有这个高效</strong>)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i=<span class="number">1</span>;</span><br><span class="line">等价于</span><br><span class="line">Integer i=Integer.valueOf(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><a class="link"   href="https://github.com/notfornothing/JavaSE/blob/main/JavaSE_Basic_Basic/src/cn/leijiba/day11/Test6_Integer.java" >关于 Integer 的高效：了解即可 &#x3D;&#x3D;&gt;由此去源代码<i class="fas fa-external-link-alt"></i></a></p>
<ul>
<li><pre><code class="language-java">    private static void integerTest2() &#123;
        Integer i1 = Integer.valueOf((int)666);
        Integer i2 = Integer.valueOf((int)666);
        Integer i3 = new Integer((int) 666);
        Integer i4 = new Integer((int) 666);
        System.out.println(i1==i2);//false
        System.out.println(i3==i4);//false
    &#125;

    private static void integerTestEqual() &#123;
        Integer i1 = Integer.valueOf((int)6);
        Integer i2 = Integer.valueOf((int)6);
        Integer i3 = new Integer((int) 6);
        Integer i4 = new Integer((int) 6);
        System.out.println(i1==i2);//true
        System.out.println(i3==i4);//false
    &#125;

    public static void integerTest() &#123;
        Integer i1=  6;
        Integer i2 = 6;
        Integer i3 = new Integer(6);
        Integer i4 = new Integer(6);
        System.out.println(i1 == i2);//true
        System.out.println(i3 == i4);//false
    &#125;

   public static void main(String[] args) &#123;
        integerTest();
        integerTest2();
        System.out.println(&quot;=========|&quot;);
        // 为什么会输出 true  false
        // 下面的是反编译，这是
        integerTestEqual();
        // 可以看到 i1 i2 以自动装箱的方式创建
        //i3  i4 以构造方法的方式创建

        // 那为啥会有 true 返回呢？
        // 因为 Integer 在 valueOf() 第一次 调用时。会创建 -128~127 直接的实例
        // 加到缓存，后续调用 valueOf 方法时，会返回缓存中的实例。
        // 所以指向同一内存地址 为 true.
        // 所以 integerTest2 超过了 127 的最大值。你自己可以进 valueOf 方法里看。
    &#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### String</span><br><span class="line"></span><br><span class="line">重写了 equals 方法和 toString 方法</span><br><span class="line"></span><br><span class="line">sout 默认打印的是他的 toString 方法</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">String =&quot; &quot;  和 String str=new String(&quot; &quot;) 的区别 ==&gt;[StringTest.java](https://github.com/notfornothing/JavaSE/blob/main/JavaSE_Basic_Basic/src/cn/leijiba/day11/StringTest.java)</span><br><span class="line"></span><br><span class="line">&gt; [基于 == 判断的，因为 == 是比较的地址值.](https://blog.csdn.net/justloveyou_/article/details/52464440)</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    /** String=&quot;&quot;  和 String s=new String(&quot;string&quot;) 的区别*/</span><br><span class="line"></span><br><span class="line">    String str1 = &quot;abcd&quot;;</span><br><span class="line">    String str2 = &quot;abcd&quot;;</span><br><span class="line">    System.out.println(str1==str2);//true</span><br><span class="line">    // 因为 String str1 = &quot;abcd&quot;的实现过程：</span><br><span class="line">    // 首先栈区创建 str 引用，然后在 String 池（独立于栈和堆而存在，存储不可变量）</span><br><span class="line">    // 中寻找其指向的内容为&quot;abcd&quot;的对象，如果 String 池中没有，则创建一个，</span><br><span class="line">    // 然后 str 指向 String 池中的对象，如果有，则直接将 str1 指向&quot;abcd&quot;&quot;；</span><br><span class="line">   // 如果后来又定义了字符串变量 str2 = &quot;abcd&quot;,</span><br><span class="line">    // 则直接将 str2 引用指向 String 池中已经存在的“abcd”，不再重新创建对象；</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;============&quot;);</span><br><span class="line">    str1 = &quot;abc&quot;;</span><br><span class="line">    String str3 = &quot;abc&quot;;</span><br><span class="line">    System.out.println(str1 == str3);//true</span><br><span class="line">    // 当 str1 进行了赋值（str1=“abc”），则 str1 将不再指向&quot;abcd&quot;，</span><br><span class="line">    // 而是重新指 String 池中的&quot;abc&quot;，此时如果定义 String str3 = &quot;abc&quot;,</span><br><span class="line">    // 进行 str1 == str3 操作，返回值为 true，因为他们的值一样，地址一样</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;============&quot;);</span><br><span class="line">    str1 = str3 + &quot;d&quot;;</span><br><span class="line">    System.out.println(str2 == str1);//false</span><br><span class="line">    System.out.println(str2.equals(str1));//true</span><br><span class="line">    // 内容为&quot;abc&quot;的 str1 进行了字符串的 + 连接 str1 = str1+&quot;d&quot;；</span><br><span class="line">    // 此时 str1 指向的是在堆中新建的内容为&quot;abcd&quot;的对象，*************这是重点</span><br><span class="line">    // 即此时进行 str1==str2，返回值 false，因为地址不一样。但是值一样</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;=================&quot;);</span><br><span class="line">    System.out.println(&quot;以下是区别&quot;);</span><br><span class="line"></span><br><span class="line">    String str4 = new String(&quot;abcd&quot;);</span><br><span class="line">    String str5 = new String(&quot;abcd&quot;);</span><br><span class="line">    System.out.println(str4 == str5);//false</span><br><span class="line">    System.out.println(str4.equals(str5));//true</span><br><span class="line">    //String str4 = new String(&quot;abcd&quot;) 的实现过程：</span><br><span class="line">    // 直接在堆中创建对象。如果后来又有 String str5 = new String(&quot;abcd&quot;)，</span><br><span class="line">    // str5 不会指向之前的对象，而是重新创建一个对象并指向它，</span><br><span class="line">    // 所以如果此时进行 str3==str4 返回值是 false，因为两个对象的地址不一样，</span><br><span class="line">    // 如果是 str3.equals(str4)，返回 true, 因为内容相同。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="String-常用-API"><a href="#String-常用-API" class="headerlink" title="String 常用 API"></a><strong>String 常用 API</strong></h3><p>—————– 不用记下来，有印象就行</p>
<hr>
<ul>
<li>charAt</li>
<li><strong>concat</strong> – 拼接，但不改变原字符串</li>
<li>endsWith</li>
<li>startsWith</li>
<li>equals</li>
<li><strong>indexOf</strong></li>
<li>lastIndexOf</li>
<li>length</li>
<li>toUpperCase</li>
<li>toLowerCase</li>
<li><strong>split</strong> – 切割</li>
<li><strong>valueOf</strong> – int 转 String</li>
<li>trim – 去掉头尾空格</li>
<li>getBytes – 转成 byte[]</li>
<li><strong>subString</strong> – 截取子串 左闭右开 [)</li>
</ul>
<p>对于 String 的这些方法：</p>
<p>可以用字符串常量来解释：所以他返回的值是变的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;abcdefg&quot;</span>.substring(<span class="number">2</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<h3 id="String-和-StringBuffer-和-String"><a href="#String-和-StringBuffer-和-String" class="headerlink" title="String 和 StringBuffer 和 String"></a>String 和 StringBuffer 和 String</h3><hr>
<p>目前只知道 String 拼接字符串 比其他两个很耗时间和内存</p>
<p>用 System.currentTimeMillis() 两个相减得到的</p>
<h3 id="思考-成员变量为自定义的类型，那么-equals-是否调用该成员变量的-equals-方法呢？toString-呢？"><a href="#思考-成员变量为自定义的类型，那么-equals-是否调用该成员变量的-equals-方法呢？toString-呢？" class="headerlink" title="思考 成员变量为自定义的类型，那么 equals 是否调用该成员变量的 equals 方法呢？toString 呢？"></a>思考 成员变量为自定义的类型，那么 equals 是否调用该成员变量的 equals 方法呢？toString 呢？</h3><hr>
<p>是的，所以应该重写 equals 和 toString</p>
<ul>
<li><p>其中 toString 调用的是 hashCode 的默认。所以应该重写才好</p>
</li>
<li><p>重写的 equals 调用的是基本数据类型的是用 &#x3D;&#x3D;. 引用数据类型调用的是 Objects.equals(a,b)</p>
<blockquote>
<p>我看了一下他的实现，就是去调用 a 的 equals 方法。所以说要重写才好。免得到时候 equals 判断半天还不等于。免得踩坑</p>
</blockquote>
</li>
</ul>
<p>下面有关于 Objects 的 quals 方法</p>
<h3 id="Stringbuffer-是线程安全的："><a href="#Stringbuffer-是线程安全的：" class="headerlink" title="Stringbuffer 是线程安全的："></a>Stringbuffer 是线程安全的：</h3><blockquote>
<p><strong>他是从 JDK1.0 版本就有的，他是线程安全</strong><br><strong>StringBuffer 源码有</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity &gt; value.length) &#123;</span><br><span class="line">        expandCapacity(minimumCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Stringbuilder-不是线程安全的"><a href="#Stringbuilder-不是线程安全的" class="headerlink" title="Stringbuilder 不是线程安全的"></a>Stringbuilder 不是线程安全的</h3><blockquote>
<ul>
<li><strong>从版本 JDK 5 开始，这个类别已经被一个等级类补充了，这个类被设计为使用一个线程 Stringbuilder 类，Stringbuilder 应该使用 Stringbuilder 类，因为它支持所有相同的操作，但它更快，因为它不执行同步。</strong></li>
</ul>
<p><strong>Stringbuilder 没有 synchronized 锁</strong> ,<strong>所以他不是线程安全的.</strong></p>
</blockquote>
<h3 id="好像还有一个-Objects-类"><a href="#好像还有一个-Objects-类" class="headerlink" title="好像还有一个 Objects 类"></a>好像还有一个 Objects 类</h3><hr>
<p>主要用到的是 Objects 类的 Objects.equals</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="literal">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
















<h2 id="Spring-AOP-几种通知？"><a href="#Spring-AOP-几种通知？" class="headerlink" title="Spring AOP 几种通知？"></a>Spring AOP 几种通知？</h2><h2 id="MySQL-四种特性？"><a href="#MySQL-四种特性？" class="headerlink" title="MySQL 四种特性？"></a>MySQL 四种特性？</h2><h2 id="MySQL-赃读，幻读那些"><a href="#MySQL-赃读，幻读那些" class="headerlink" title="MySQL 赃读，幻读那些"></a>MySQL 赃读，幻读那些</h2><h2 id="Spring-的注解有哪些（注意不是-SpringBoot-的）"><a href="#Spring-的注解有哪些（注意不是-SpringBoot-的）" class="headerlink" title="Spring 的注解有哪些（注意不是 SpringBoot 的）"></a>Spring 的注解有哪些（注意不是 SpringBoot 的）</h2><h2 id="业务：SpringBoot-中返回一个-JSON-和重定向应该怎么使用？"><a href="#业务：SpringBoot-中返回一个-JSON-和重定向应该怎么使用？" class="headerlink" title="业务：SpringBoot 中返回一个 JSON, 和重定向应该怎么使用？"></a>业务：SpringBoot 中返回一个 JSON, 和重定向应该怎么使用？</h2><h2 id="String-StringBuffer-StringBuilder-区别"><a href="#String-StringBuffer-StringBuilder-区别" class="headerlink" title="String , StringBuffer , StringBuilder 区别"></a>String , StringBuffer , StringBuilder 区别</h2><h2 id="SpringMVC-流程"><a href="#SpringMVC-流程" class="headerlink" title="SpringMVC 流程"></a>SpringMVC 流程</h2><h2 id="多线程状态"><a href="#多线程状态" class="headerlink" title="多线程状态"></a>多线程状态</h2><details><summary>图解（点击展开）</summary>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/06/20/JavaSE%E6%80%BB%E7%BB%93/Snipaste_2022-03-20_19-42-06.jpg"
                       
                 ></p>
</details>

<h2 id="hashMap-底层原理"><a href="#hashMap-底层原理" class="headerlink" title="hashMap 底层原理"></a>hashMap 底层原理</h2><details><summary>DEBUG 代码探究其原理（点击展开） </summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DEBUG 代码探究其原理：</span></span><br><span class="line"><span class="keyword">package</span> cn.leijiba.hashTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;SimpleBO, String&gt; stringMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">7</span>) &#123;</span><br><span class="line">                stringMap.put(<span class="keyword">new</span> <span class="title class_">SimpleBO</span>(<span class="string">&quot;test&quot;</span> + i), <span class="string">&quot;test&quot;</span> + i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt;= <span class="number">45</span>) &#123;</span><br><span class="line">                stringMap.put(<span class="keyword">new</span> <span class="title class_">SimpleBO</span>(<span class="string">&quot;test&quot;</span> + i), <span class="string">&quot;test&quot;</span> + i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stringMap.put(<span class="keyword">new</span> <span class="title class_">SimpleBO</span>(<span class="string">&quot;test&quot;</span> + i), <span class="string">&quot;test&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleBO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleBO</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">replace</span> <span class="operator">=</span> UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">char</span>[] chars = replace.toCharArray();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> aChar : chars) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aChar &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; aChar &lt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                stringBuilder.append(aChar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringBuilder.toString();</span><br><span class="line">        <span class="keyword">if</span> (s.length() &gt; <span class="number">6</span>) &#123;</span><br><span class="line">            s = s.substring(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<hr>
<ul>
<li><p>hashMap 树化得同时满足：</p>
<ul>
<li>链接长度 &gt; 8</li>
<li>数组长度为 64</li>
</ul>
</li>
<li><p>hashMap  当总元素个数 &gt; 数组长度*0.75 会扩容 rehash(), 但是下面还有一种情况。</p>
</li>
<li><p>hashMap 当总元素没有达到 <code>当前数组长度*0.75</code> 且 <code>数组长度 &lt; 64</code> 时 ，有一个数组地址哈希冲突了，形成<strong>链表</strong>。在这前提下如果哈希冲突的元素达到 8，在插入第 9 个哈希冲突的元素时。数组会扩容到两倍（即长度向左移一位），而且不会形成红黑树，而是扩容 rehash(). 当第一种情况满足才会红黑树。</p>
</li>
<li><p><a class="link"   href="https://www.bilibili.com/video/BV1YA411T76k?p=40&t=514" >hashMap 扩容源码讲解<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://www.bilibili.com/video/BV1YA411T76k?p=23" >hashMap 变红黑树必须同时满足链表》8 和数组 &#x3D;&#x3D;64 才会变红黑树<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Map 中引用遇到的问题</title>
    <url>/2021/06/08/Map-%E4%B8%AD%E5%BC%95%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Map-中引用遇到的问题"><a href="#Map-中引用遇到的问题" class="headerlink" title="Map 中引用遇到的问题"></a>Map 中引用遇到的问题</h1><h2 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、有 List&lt;String&gt; nameList 值为『张三，李四，王五』</span><br><span class="line">2、把 nameList 的每个值都存到 key 为&quot;name&quot; 的 map&lt;String,Object&gt; 中</span><br><span class="line">3、并把 map 放到 List&lt;Map&lt;String, Object&gt;&gt; 里面</span><br></pre></td></tr></table></figure>
<p>等于说是：</p>
<p>『张三，李四，王五』&#x3D;&#x3D;&gt; 『{name&#x3D; 张三}, {name&#x3D; 李四}, {name&#x3D; 王五}』</p>
<h2 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h2><ul>
<li><p>BUG : 一直都是最后一个人的姓名</p>
</li>
<li><p>BUG 代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[PANGU_DISABLE] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; nameList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>));</span><br><span class="line">    System.out.println(nameList);</span><br><span class="line">    System.out.println(<span class="string">&quot;================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BUG 一直都是最后一个人的姓名</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">for</span> (String name : nameList) &#123;</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">        list.add(map);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/06/08/Map-%E4%B8%AD%E5%BC%95%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/Snipaste_2021-12-08_19-27-47.jpg"
                        alt="PANGU_DISABLE"
                 ></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ol>
<li>由输出可见：存进 list 的值都是最后一个的 name.</li>
<li>因为 list 存的都是这个 map 的同一个引用。类似于 C 语言的指针。也就是<strong>list  存的都是同一个地址</strong>，这个地址所指向的东西改变，其他存这个地址的里面的值也会改变。所以该 list 下面的值都会变，也就是 name 都是一样的。</li>
<li>然后 map 的 put 有去重的效果，以最后一个 key 所 put 进去的值为准。所以存的是最后一个 name.</li>
</ol>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ul>
<li>由<a href="#%E5%8E%9F%E5%9B%A0">原因</a>的第 2 点，我们只需不让 list 存同一个地址。即让 map 重新指向新的地址。即重新 new 一个 HashMap.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; nameList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>));</span><br><span class="line">    System.out.println(nameList);</span><br><span class="line">    System.out.println(<span class="string">&quot;================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 map 放到循环里面，避免重复引用</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String name : nameList) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">        list.add(map);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/06/08/Map-%E4%B8%AD%E5%BC%95%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/Snipaste_2021-12-08_19-58-14.jpg"
                       
                 ></p>
]]></content>
  </entry>
  <entry>
    <title>MySQL-外连接的几种情况</title>
    <url>/2021/11/28/MySQL-%E5%A4%96%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/28/MySQL-%E5%A4%96%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5/1554979255233.png"
                        alt="1554979255233.png"
                 ></p>
<hr>
<p>前提： </p>
<ul>
<li><p>因为有可能有的员工没有部门（他是老总）</p>
</li>
<li><p>有的部门没有员工（部门刚成立的情况）</p>
</li>
</ul>
<h1 id="查询有部门的员工-内连接"><a href="#查询有部门的员工-内连接" class="headerlink" title="查询有部门的员工(内连接)"></a>查询有部门的员工(内连接)</h1><p>你只要查询有部门的员工，潜意识就是没有部门的不要查<br>所以就是员工和部门表的交集</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- where 子句方式</span></span><br><span class="line"><span class="keyword">SELECT</span> e.name, d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e, departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.department_id <span class="operator">=</span> d.id; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 内连接方式</span></span><br><span class="line"><span class="keyword">SELECT</span> e.name, d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> e.department_id <span class="operator">=</span> d.id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="查询所有员工的部门-左外连接"><a href="#查询所有员工的部门-左外连接" class="headerlink" title="查询所有员工的部门(左外连接)"></a>查询所有员工的部门(左外连接)</h1><p>你要查询 <strong><code>所有</code></strong> 员工，然后把他部门信息也带上<br>考虑到这种情况，即需要员工表设为主表，涉及到外连接；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name, e.department_id, d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> departments d <span class="keyword">on</span> e.department_id <span class="operator">=</span> d.department_id </span><br></pre></td></tr></table></figure>

<h1 id="查询所有员工的部门-只查询有部门的员工-左外连接"><a href="#查询所有员工的部门-只查询有部门的员工-左外连接" class="headerlink" title="查询所有员工的部门,只查询有部门的员工(左外连接)"></a>查询所有员工的部门,只查询有部门的员工(左外连接)</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name, e.department_id, d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">join</span> departments d <span class="keyword">on</span> e.department_id <span class="operator">=</span> d.department_id</span><br><span class="line"><span class="keyword">where</span> e.department_id <span class="keyword">is</span> <span class="keyword">not null</span>;</span><br></pre></td></tr></table></figure>

<h1 id="查询所有部门下的员工信息-右外连接"><a href="#查询所有部门下的员工信息-右外连接" class="headerlink" title="查询所有部门下的员工信息(右外连接)"></a>查询所有部门下的员工信息(右外连接)</h1><p>你要查询 <strong><code>所有</code></strong> 部门，然后把他员工信息列出来，没有员工也得给我列出来；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name, e.department_id, d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span> departments d <span class="keyword">on</span> e.department_id <span class="operator">=</span> d.department_id</span><br></pre></td></tr></table></figure>

<h1 id="查询所有部门下的有部门的员工信息，-右外连接"><a href="#查询所有部门下的有部门的员工信息，-右外连接" class="headerlink" title="查询所有部门下的有部门的员工信息，(右外连接)"></a>查询所有部门下的有部门的员工信息，(右外连接)</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name, e.department_id, d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span> departments d <span class="keyword">on</span> e.department_id <span class="operator">=</span> d.department_id</span><br><span class="line"><span class="keyword">where</span> e.department_id <span class="keyword">is</span> <span class="keyword">not null</span></span><br></pre></td></tr></table></figure>

<h1 id="查询没有员工的部门，还有没有部门的员工-全外连接"><a href="#查询没有员工的部门，还有没有部门的员工-全外连接" class="headerlink" title="查询没有员工的部门，还有没有部门的员工(全外连接)"></a>查询没有员工的部门，还有没有部门的员工(全外连接)</h1><blockquote>
<p>MySQL 不支持全外链接 可以用 <code>Union all</code>实现</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.last_name, e.department_id, d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">join</span> departments d <span class="keyword">on</span> e.department_id <span class="operator">=</span> d.department_id</span><br><span class="line"><span class="keyword">where</span> e.department_id <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span>  <span class="keyword">all</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> e.last_name, e.department_id, d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line">         <span class="keyword">right</span> <span class="keyword">join</span> departments d <span class="keyword">on</span> e.department_id <span class="operator">=</span> d.department_id</span><br><span class="line"><span class="keyword">where</span> e.department_id <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<h1 id="查询所有员工，还有所有部门-全外连接"><a href="#查询所有员工，还有所有部门-全外连接" class="headerlink" title="查询所有员工，还有所有部门(全外连接)"></a>查询所有员工，还有所有部门(全外连接)</h1><p>补充：没有部门的员工，没有员工的部门都要带出来</p>
<blockquote>
<p>MySQL 不支持全外链接 可以用 <code>Union all</code>实现</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 部门id 为空的那个老总</span></span><br><span class="line"><span class="keyword">SELECT</span> e.last_name, e.department_id, d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line">         <span class="keyword">left</span> <span class="keyword">join</span> departments d <span class="keyword">on</span> e.department_id <span class="operator">=</span> d.department_id</span><br><span class="line"><span class="keyword">where</span> e.department_id <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span>  <span class="keyword">all</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询所有部门下的员工信息 </span></span><br><span class="line"><span class="keyword">SELECT</span> e.last_name, e.department_id, d.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line">         <span class="keyword">right</span> <span class="keyword">join</span> departments d <span class="keyword">on</span> e.department_id <span class="operator">=</span> d.department_id</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>MySQL 查询优化</title>
    <url>/2025/02/25/MySQL-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>考虑到面试可能会问到 SQL 优化相关的问题，提前总结一下：</p>
<h1 id="能写在where限定的条件就不要写在having中"><a href="#能写在where限定的条件就不要写在having中" class="headerlink" title="能写在where限定的条件就不要写在having中"></a>能写在where限定的条件就不要写在having中</h1><p>查询 部门为产品部,宣传部的平均工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 反例</span></span><br><span class="line"><span class="keyword">select</span> dept_name,<span class="built_in">avg</span>(salary)</span><br><span class="line"><span class="keyword">from</span> dept t</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br><span class="line"><span class="keyword">having</span> t.dept_name <span class="keyword">in</span> (<span class="string">&#x27;产品部&#x27;</span>,<span class="string">&#x27;宣传部&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正例</span></span><br><span class="line"><span class="keyword">select</span> dept_name,<span class="built_in">avg</span>(salary)</span><br><span class="line"><span class="keyword">from</span> dept t</span><br><span class="line"><span class="keyword">where</span> t.dept_name <span class="keyword">in</span> (<span class="string">&#x27;产品部&#x27;</span>,<span class="string">&#x27;宣传部&#x27;</span>)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name;</span><br></pre></td></tr></table></figure>

<p>因为 sql 的执行顺序是</p>
<p>FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT 的字段 -&gt; DISTINCT -&gt; ORDER BY -&gt; LIMIT</p>
<p>所以 avg() 会把其他部门的薪水也进行分组计算，放到where语句中可减少avg的消耗。</p>
<h1 id="避免select-应该只查询所需字段"><a href="#避免select-应该只查询所需字段" class="headerlink" title="避免select *,应该只查询所需字段"></a>避免select *,应该只查询所需字段</h1><h1 id="大表数据：垂直分表"><a href="#大表数据：垂直分表" class="headerlink" title="大表数据：垂直分表"></a>大表数据：垂直分表</h1><p>例如 一个接口是查询各个汽车，点击查看详细才会去跳转到这辆汽车的各种排气孔大小，轮胎尺寸，后备箱空间等特别详细的参数。<br>对于这种特别详细的参数不属于高频查询的数据，可以采用多个表，用id关联。</p>
<h1 id="大表数据：水平分表"><a href="#大表数据：水平分表" class="headerlink" title="大表数据：水平分表"></a>大表数据：水平分表</h1><p>Union all<br>例如日志表，可以每个月一个日志。</p>
<h1 id="like-查询尽量加上左边确定的值-如-like-‘nameSpac-’"><a href="#like-查询尽量加上左边确定的值-如-like-‘nameSpac-’" class="headerlink" title="like 查询尽量加上左边确定的值 如 like ‘nameSpac%’"></a>like 查询尽量加上左边确定的值 如 like ‘nameSpac%’</h1><h1 id="导致索引失效"><a href="#导致索引失效" class="headerlink" title="导致索引失效"></a>导致索引失效</h1><ul>
<li>避免使用 is not null、 or 、not in 、!&#x3D;这样不会走索引</li>
<li>like ‘%something’ 不会走索引</li>
<li>隐式类型转换</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 这里 age 为整数类型，但查询条件是字符串</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="string">&#x27;30&#x27;</span>;  </span><br></pre></td></tr></table></figure>
<ul>
<li>前导列失效：在联合索引中，如果查询条件中缺少前导列，索引将失效。</li>
</ul>
<h1 id="select-很慢可以用覆盖索引"><a href="#select-很慢可以用覆盖索引" class="headerlink" title="select 很慢可以用覆盖索引"></a>select 很慢可以用覆盖索引</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name_city <span class="keyword">ON</span> users (name, city);</span><br></pre></td></tr></table></figure>

<h1 id="表太多大于3个最好不要连表了，把数据到应用层处理，挑出来要的数据再放sql去查"><a href="#表太多大于3个最好不要连表了，把数据到应用层处理，挑出来要的数据再放sql去查" class="headerlink" title="表太多大于3个最好不要连表了，把数据到应用层处理，挑出来要的数据再放sql去查"></a>表太多大于3个最好不要连表了，把数据到应用层处理，挑出来要的数据再放sql去查</h1><h1 id="对于查询慢的sql，经常要用到的条件（select，where-order-by-group-by-distinct-…-添加索引"><a href="#对于查询慢的sql，经常要用到的条件（select，where-order-by-group-by-distinct-…-添加索引" class="headerlink" title="对于查询慢的sql，经常要用到的条件（select，where ,order by,group by,distinct …)添加索引"></a>对于查询慢的sql，经常要用到的条件（select，where ,order by,group by,distinct …)添加索引</h1><h1 id="varchar-存储浪费空间，特殊定长字段用char"><a href="#varchar-存储浪费空间，特殊定长字段用char" class="headerlink" title="varchar 存储浪费空间，特殊定长字段用char"></a>varchar 存储浪费空间，特殊定长字段用char</h1><p>添加索引要注意：</p>
<ul>
<li>一个表中最好不要超过6个索引</li>
<li>尽量是区分度高的数据作为索引</li>
<li>条件中多个字段要创建索引的情况下，可以创建联合索引（减少回表）。如 age &gt; 18 and hight &lt; 183</li>
<li>当字段类型为字符串(varchar, text等)时，有时候需要索引很长的字符串，这会让索引变得很大，此时可以只将字符串的一部分前缀，建立索引（前缀索引）。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>MySQL 资料</title>
    <url>/2021/11/30/MySQL/</url>
    <content><![CDATA[<blockquote>
<p>文档来自<a class="link"   href="https://www.bilibili.com/video/BV1iq4y1u7vj" >网上视频文档<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h1 id="第01章-数据库概述"><a href="#第01章-数据库概述" class="headerlink" title="第01章_数据库概述"></a>第01章_数据库概述</h1><hr>
<h2 id="1-为什么要使用数据库"><a href="#1-为什么要使用数据库" class="headerlink" title="1. 为什么要使用数据库"></a>1. 为什么要使用数据库</h2><ul>
<li>持久化(persistence)：<strong>把数据保存到可掉电式存储设备中以供之后使用</strong>。大多数情况下，特别是企业级应用，<strong>数据持久化意味着将内存中的数据保存到硬盘上加以”固化”</strong>，而持久化的实现过程大多通过各种关系数据库来完成。</li>
<li>持久化的主要作用是<strong>将内存中的数据存储在关系型数据库中</strong>，当然也可以存储在磁盘文件、XML数据文件中。</li>
</ul>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211020202152071.png"
                         alt="image-20211020202152071" style="zoom:50%;" 
                 >

<p>生活中的例子：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image_20211020132711.jpg"
                       
                 ></p>
<h2 id="2-数据库与数据库管理系统"><a href="#2-数据库与数据库管理系统" class="headerlink" title="2. 数据库与数据库管理系统"></a>2. 数据库与数据库管理系统</h2><h3 id="2-1-数据库的相关概念"><a href="#2-1-数据库的相关概念" class="headerlink" title="2.1 数据库的相关概念"></a>2.1 数据库的相关概念</h3><table>
<thead>
<tr>
<th><strong>DB：数据库（Database）</strong></th>
</tr>
</thead>
<tbody><tr>
<td>即存储数据的“仓库”，其本质是一个文件系统。它保存了一系列有组织的数据。</td>
</tr>
<tr>
<td><strong>DBMS：数据库管理系统（Database Management System）</strong></td>
</tr>
<tr>
<td>是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制。用户通过数据库管理系统访问数据库中表内的数据。</td>
</tr>
<tr>
<td><strong>SQL：结构化查询语言（Structured Query Language）</strong></td>
</tr>
<tr>
<td>专门用来与数据库通信的语言。</td>
</tr>
</tbody></table>
<h3 id="2-2-数据库与数据库管理系统的关系"><a href="#2-2-数据库与数据库管理系统的关系" class="headerlink" title="2.2 数据库与数据库管理系统的关系"></a>2.2 数据库与数据库管理系统的关系</h3><p>数据库管理系统(DBMS)可以管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。</p>
<p>数据库管理系统、数据库和表的关系如图所示：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211013202511233.png"
                        alt="image-20211013202511233"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20210915112546261.png"
                        alt="image-20210915112546261"
                 ></p>
<h3 id="2-3-常见的数据库管理系统排名-DBMS"><a href="#2-3-常见的数据库管理系统排名-DBMS" class="headerlink" title="2.3 常见的数据库管理系统排名(DBMS)"></a>2.3 常见的数据库管理系统排名(DBMS)</h3><p>目前互联网上常见的数据库管理软件有Oracle、MySQL、MS SQL Server、DB2、PostgreSQL、Access、Sybase、Informix这几种。以下是2021年<strong>DB-Engines Ranking</strong> 对各数据库受欢迎程度进行调查后的统计结果：（查看数据库最新排名:<a class="link"   href="https://db-engines.com/en/ranking%EF%BC%89" >https://db-engines.com/en/ranking）<i class="fas fa-external-link-alt"></i></a></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211013202815851.png"
                        alt="image-20211013202815851"
                 ></p>
<p>。。。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211013202940798.png"
                        alt="image-20211013202940798"
                 ></p>
<p>对应的走势图：（<a class="link"   href="https://db-engines.com/en/ranking_trend%EF%BC%89" >https://db-engines.com/en/ranking_trend）<i class="fas fa-external-link-alt"></i></a></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211013203029492.png"
                        alt="image-20211013203029492"
                 ></p>
<h3 id="2-4-常见的数据库介绍"><a href="#2-4-常见的数据库介绍" class="headerlink" title="2.4 常见的数据库介绍"></a>2.4 常见的数据库介绍</h3><p><strong>Oracle</strong></p>
<p>1979 年，Oracle 2 诞生，它是第一个商用的 RDBMS（关系型数据库管理系统）。随着 Oracle 软件的名气越来越大，公司也改名叫 Oracle 公司。</p>
<p>2007年，总计85亿美金收购BEA Systems。</p>
<p>2009年，总计74亿美金收购SUN。此前的2008年，SUN以10亿美金收购MySQL。意味着Oracle 同时拥有了 MySQL 的管理权，至此 Oracle 在数据库领域中成为绝对的领导者。</p>
<p>2013年，甲骨文超越IBM，成为继Microsoft后全球第二大软件公司。</p>
<p>如今 Oracle 的年收入达到了 400 亿美金，足以证明商用（收费）数据库软件的价值。</p>
<p><strong>SQL Server</strong></p>
<p>SQL Server 是微软开发的大型商业数据库，诞生于 1989 年。C#、.net等语言常使用，与WinNT完全集成，也可以很好地与Microsoft BackOffice产品集成。</p>
<p><strong>DB2</strong></p>
<p>IBM公司的数据库产品,收费的。常应用在银行系统中。</p>
<p><strong>PostgreSQL</strong></p>
<p>PostgreSQL 的稳定性极强，最符合SQL标准，开放源码，具备商业级DBMS质量。PG对数据量大的文本以及SQL处理较快。</p>
<p><strong>SyBase</strong></p>
<p>已经淡出历史舞台。提供了一个非常专业数据建模的工具PowerDesigner。</p>
<p><strong>SQLite</strong></p>
<p>嵌入式的小型数据库，应用在手机端。 零配置，SQlite3不用安装，不用配置，不用启动，关闭或者配置数据库实例。当系统崩溃后不用做任何恢复操作，再下次使用数据库的时候自动恢复。</p>
<p><strong>informix</strong></p>
<p>IBM公司出品，取自Information 和Unix的结合，它是第一个被移植到Linux上的商业数据库产品。仅运行于unix&#x2F;linux平台，命令行操作。 性能较高，支持集群，适应于安全性要求极高的系统，尤其是银行，证券系统的应用。</p>
<h2 id="3-MySQL介绍"><a href="#3-MySQL介绍" class="headerlink" title="3. MySQL介绍"></a>3. MySQL介绍</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20210829230656830.png"
                        alt="image-20210829230656830"
                 ></p>
<h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><ul>
<li>MySQL是一个<code>开放源代码的关系型数据库管理系统</code>，由瑞典MySQL AB（创始人Michael Widenius）公司1995年开发，迅速成为开源数据库的 No.1。</li>
<li>2008被<code>Sun</code>收购（10亿美金），2009年Sun被<code>Oracle</code>收购。<code>MariaDB</code>应运而生。（MySQL 的创造者担心 MySQL 有闭源的风险，因此创建了 MySQL 的分支项目 MariaDB）</li>
<li>MySQL6.x 版本之后分为<code>社区版</code>和<code>商业版</code>。</li>
<li>MySQL是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。</li>
<li>MySQL是开源的，所以你不需要支付额外的费用。</li>
<li>MySQL是可以定制的，采用了<code>GPL（GNU General Public License）</code>协议，你可以修改源码来开发自己的MySQL系统。</li>
<li>MySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。</li>
<li>MySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持<code>4GB</code>，64位系统支持最大的表文件为<code>8TB</code>。</li>
<li>MySQL使用<code>标准的SQL数据语言</code>形式。</li>
<li>MySQL可以允许运行于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP和Ruby等。</li>
</ul>
<h3 id="3-2-MySQL发展史重大事件"><a href="#3-2-MySQL发展史重大事件" class="headerlink" title="3.2 MySQL发展史重大事件"></a>3.2 MySQL发展史重大事件</h3><p>MySQL的历史就是整个互联网的发展史。互联网业务从社交领域、电商领域到金融领域的发展，推动着应用对数据库的需求提升，对传统的数据库服务能力提出了挑战。高并发、高性能、高可用、轻资源、易维护、易扩展的需求，促进了MySQL的长足发展。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20210730161043856.png"
                        alt="image-20210730161043856"
                 ></p>
<h3 id="1-4-关于MySQL-8-0"><a href="#1-4-关于MySQL-8-0" class="headerlink" title="1.4 关于MySQL 8.0"></a>1.4 关于MySQL 8.0</h3><p><code>MySQL从5.7版本直接跳跃发布了8.0版本</code>，可见这是一个令人兴奋的里程碑版本。MySQL 8版本在功能上做了显著的改进与增强，开发者对MySQL的源代码进行了重构，最突出的一点是多MySQL Optimizer优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。</p>
<h3 id="1-5-Why-choose-MySQL"><a href="#1-5-Why-choose-MySQL" class="headerlink" title="1.5 Why choose MySQL?"></a>1.5 Why choose MySQL?</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211013210429011.png"
                        alt="image-20211013210429011"
                 ></p>
<p>为什么如此多的厂商要选用MySQL？大概总结的原因主要有以下几点：</p>
<ol>
<li><p>   开放源代码，使用成本低。</p>
</li>
<li><p>   性能卓越，服务稳定。</p>
</li>
<li><p>   软件体积小，使用简单，并且易于维护。</p>
</li>
<li><p>   历史悠久，社区用户非常活跃，遇到问题可以寻求帮助。</p>
</li>
<li><p>   许多互联网公司在用，经过了时间的验证。</p>
</li>
</ol>
<h3 id="1-6-Oracle-vs-MySQL"><a href="#1-6-Oracle-vs-MySQL" class="headerlink" title="1.6 Oracle vs MySQL"></a>1.6 Oracle vs MySQL</h3><p>Oracle 更适合大型跨国企业的使用，因为他们对费用不敏感，但是对性能要求以及安全性有更高的要求。</p>
<p>MySQL 由于其<strong>体积小、速度快、总体拥有成本低，可处理上千万条记录的大型数据库，尤其是开放源码这一特点，使得很多互联网公司、中小型网站选择了MySQL作为网站数据库</strong>（Facebook，Twitter，YouTube，阿里巴巴&#x2F;蚂蚁金服，去哪儿，美团外卖，腾讯）。</p>
<h2 id="4-RDBMS-与-非RDBMS"><a href="#4-RDBMS-与-非RDBMS" class="headerlink" title="4. RDBMS 与 非RDBMS"></a>4. RDBMS 与 非RDBMS</h2><p>从排名中我们能看出来，关系型数据库绝对是 DBMS 的主流，其中使用最多的 DBMS 分别是 Oracle、MySQL 和 SQL Server。这些都是关系型数据库（RDBMS）。</p>
<h3 id="4-1-关系型数据库-RDBMS"><a href="#4-1-关系型数据库-RDBMS" class="headerlink" title="4.1 关系型数据库(RDBMS)"></a>4.1 关系型数据库(RDBMS)</h3><h4 id="4-1-1-实质"><a href="#4-1-1-实质" class="headerlink" title="4.1.1 实质"></a>4.1.1 实质</h4><ul>
<li><p>这种类型的数据库是<code>最古老</code>的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的<code>二元关系</code>（即二维表格形式）。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211020145811031.png"
                        alt="image-20211020145811031"
                 ></p>
</li>
<li><p>关系型数据库以<code>行(row)</code>和<code>列(column)</code>的形式存储数据，以便于用户理解。这一系列的行和列被称为<code>表(table)</code>，一组表组成了一个库(database)。</p>
</li>
<li><p>表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用<code>关系模型</code>来表示。关系型数据库，就是建立在<code>关系模型</code>基础上的数据库。</p>
</li>
<li><p>SQL 就是关系型数据库的查询语言。</p>
</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20210914235413708.png"
                        alt="image-20210914235413708"
                 ></p>
<h4 id="4-1-2-优势"><a href="#4-1-2-优势" class="headerlink" title="4.1.2 优势"></a>4.1.2 优势</h4><ul>
<li><strong>复杂查询</strong><br>可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li>
<li><strong>事务支持</strong><br>使得对于安全性能很高的数据访问要求得以实现。</li>
</ul>
<h3 id="4-2-非关系型数据库-非RDBMS"><a href="#4-2-非关系型数据库-非RDBMS" class="headerlink" title="4.2 非关系型数据库(非RDBMS)"></a>4.2 非关系型数据库(非RDBMS)</h3><h4 id="4-2-1-介绍"><a href="#4-2-1-介绍" class="headerlink" title="4.2.1 介绍"></a>4.2.1 介绍</h4><p><strong>非关系型数据库</strong>，可看成传统关系型数据库的功能<code>阉割版本</code>，基于键值对存储数据，不需要经过SQL层的解析，<code>性能非常高</code>。同时，通过减少不常用的功能，进一步提高性能。</p>
<p>目前基本上大部分主流的非关系型数据库都是免费的。</p>
<h4 id="4-2-2-有哪些非关系型数据库"><a href="#4-2-2-有哪些非关系型数据库" class="headerlink" title="4.2.2 有哪些非关系型数据库"></a>4.2.2 有哪些非关系型数据库</h4><p>相比于 SQL，NoSQL 泛指非关系型数据库，包括了榜单上的键值型数据库、文档型数据库、搜索引擎和列存储等，除此以外还包括图形数据库。也只有用 NoSQL 一词才能将这些技术囊括进来。</p>
<p><strong>键值型数据库</strong></p>
<p>键值型数据库通过 Key-Value 键值的方式来存储数据，其中 Key 和 Value 可以是简单的对象，也可以是复杂的对象。Key 作为唯一的标识符，优点是查找速度快，在这方面明显优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤（比如 WHERE），如果你不知道去哪里找数据，就要遍历所有的键，这就会消耗大量的计算。</p>
<p>键值型数据库典型的使用场景是作为<code>内存缓存</code>。<code>Redis </code>是最流行的键值型数据库。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211020172958427.png"
                        alt="image-20211020172958427"
                 ></p>
<p><strong>文档型数据库</strong></p>
<p>此类数据库可存放并获取文档，可以是XML、JSON等格式。在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。MongoDB 是最流行的文档型数据库。此外，还有CouchDB等。</p>
<p><strong>搜索引擎数据库</strong></p>
<p>虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是“倒排索引”。</p>
<p>典型产品：Solr、Elasticsearch、Splunk 等。</p>
<p><strong>列式数据库</strong></p>
<p>列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的 I&#x2F;O，适合于分布式文件系统，不足在于功能相对有限。典型产品：HBase等。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211020173921726.png"
                        alt="image-20211020173921726"
                 ></p>
<p><strong>图形数据库</strong></p>
<p>图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。</p>
<p>图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象）之间的关系。关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。典型产品：Neo4J、InfoGrid等。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211020180934455.png"
                         alt="image-20211020180934455" style="zoom:80%;" 
                 >

<h4 id="4-2-3-NoSQL的演变"><a href="#4-2-3-NoSQL的演变" class="headerlink" title="4.2.3 NoSQL的演变"></a>4.2.3 NoSQL的演变</h4><p>由于 SQL 一直称霸 DBMS，因此许多人在思考是否有一种数据库技术能远离 SQL，于是 NoSQL 诞生了，但是随着发展却发现越来越离不开 SQL。到目前为止 NoSQL 阵营中的 DBMS 都会有实现类似 SQL 的功能。下面是“NoSQL”这个名词在不同时期的诠释，从这些释义的变化中可以看出 <code>NoSQL 功能的演变</code>：</p>
<p>1970：NoSQL &#x3D; We have no SQL</p>
<p>1980：NoSQL &#x3D; Know SQL</p>
<p>2000：NoSQL &#x3D; No SQL!</p>
<p>2005：NoSQL &#x3D; Not only SQL</p>
<p>2013：NoSQL &#x3D; No, SQL!</p>
<p>NoSQL 对 SQL 做出了很好的补充，比如实际开发中，有很多业务需求，其实并不需要完整的关系型数据库功能，非关系型数据库的功能就足够使用了。这种情况下，使用<code>性能更高</code>、<code>成本更低</code>的非关系型数据库当然是更明智的选择。比如：日志收集、排行榜、定时器等。</p>
<h3 id="4-3-小结"><a href="#4-3-小结" class="headerlink" title="4.3 小结"></a>4.3 小结</h3><p>NoSQL 的分类很多，即便如此，在 DBMS 排名中，还是 SQL 阵营的比重更大，影响力前 5 的 DBMS 中有 4 个是关系型数据库，而排名前 20 的 DBMS 中也有 12 个是关系型数据库。所以说，掌握 SQL 是非常有必要的。整套课程将围绕 SQL 展开。</p>
<h2 id="5-关系型数据库设计规则"><a href="#5-关系型数据库设计规则" class="headerlink" title="5. 关系型数据库设计规则"></a>5. 关系型数据库设计规则</h2><ul>
<li><p>关系型数据库的典型数据结构就是<code>数据表</code>，这些数据表的组成都是结构化的（Structured）。</p>
</li>
<li><p>将数据放到表中，表再放到库中。</p>
</li>
<li><p>一个数据库中可以有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。</p>
</li>
<li><p>表具有一些特性，这些特性定义了数据在表中如何存储，类似Java和Python中 “类”的设计。</p>
</li>
</ul>
<h3 id="5-1-表、记录、字段"><a href="#5-1-表、记录、字段" class="headerlink" title="5.1 表、记录、字段"></a>5.1 表、记录、字段</h3><ul>
<li><p>E-R（entity-relationship，实体-联系）模型中有三个主要概念是：<code>实体集</code>、<code>属性</code>、<code>联系集</code>。</p>
</li>
<li><p>一个实体集（class）对应于数据库中的一个表（table），一个实体（instance）则对应于数据库表中的一行（row），也称为一条记录（record）。一个属性（attribute）对应于数据库表中的一列（column），也称为一个字段（field）。</p>
</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20210914235450032-1634141235163.png"
                        alt="image-20210914235450032"
                 ></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ORM思想 (Object Relational Mapping)体现：</span><br><span class="line">数据库中的一个表  &lt;---&gt; Java或Python中的一个类</span><br><span class="line">表中的一条数据  &lt;---&gt; 类中的一个对象（或实体）</span><br><span class="line">表中的一个列  &lt;----&gt; 类中的一个字段、属性(field)</span><br></pre></td></tr></table></figure>

<h3 id="5-2-表的关联关系"><a href="#5-2-表的关联关系" class="headerlink" title="5.2 表的关联关系"></a>5.2 表的关联关系</h3><ul>
<li><p>表与表之间的数据记录有关系(relationship)。现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。</p>
</li>
<li><p>四种：一对一关联、一对多关联、多对多关联、自我引用</p>
</li>
</ul>
<h4 id="5-2-1-一对一关联（one-to-one）"><a href="#5-2-1-一对一关联（one-to-one）" class="headerlink" title="5.2.1 一对一关联（one-to-one）"></a>5.2.1 一对一关联（one-to-one）</h4><ul>
<li>在实际的开发中应用不多，因为一对一可以创建成一张表。</li>
<li>举例：设计<code>学生表</code>：学号、姓名、手机号码、班级、系别、身份证号码、家庭住址、籍贯、紧急联系人、…<ul>
<li><p>拆为两个表：两个表的记录是一一对应关系。</p>
</li>
<li><p><code>基础信息表</code>（常用信息）：学号、姓名、手机号码、班级、系别</p>
</li>
<li><p><code>档案信息表</code>（不常用信息）：学号、身份证号码、家庭住址、籍贯、紧急联系人、…</p>
</li>
</ul>
</li>
<li>两种建表原则：<ul>
<li>外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。</li>
<li>外键是主键：主表的主键和从表的主键，形成主外键关系。</li>
</ul>
</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20210914235534452.png"
                        alt="image-20210914235534452"
                 ></p>
<h4 id="5-2-2-一对多关系（one-to-many）"><a href="#5-2-2-一对多关系（one-to-many）" class="headerlink" title="5.2.2 一对多关系（one-to-many）"></a>5.2.2 一对多关系（one-to-many）</h4><ul>
<li>常见实例场景：<code>客户表和订单表</code>，<code>分类表和商品表</code>，<code>部门表和员工表</code>。</li>
<li>举例：<ul>
<li><p>员工表：编号、姓名、…、所属部门</p>
</li>
<li><p>部门表：编号、名称、简介</p>
</li>
</ul>
</li>
<li>一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20210915001013524.png"
                        alt="image-20210915001013524"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20210914235610597.png"
                        alt="image-20210914235610597"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20210915084623432.png"
                        alt="image-20210915084623432"
                 ></p>
<h4 id="5-2-3-多对多（many-to-many）"><a href="#5-2-3-多对多（many-to-many）" class="headerlink" title="5.2.3 多对多（many-to-many）"></a>5.2.3 多对多（many-to-many）</h4><p>要表示多对多关系，必须创建第三个表，该表通常称为<code>联接表</code>，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20210915001048215.png"
                        alt="image-20210915001048215"
                 ></p>
<ul>
<li><p><strong>举例1：学生-课程</strong></p>
<ul>
<li><p><code>学生信息表</code>：一行代表一个学生的信息（学号、姓名、手机号码、班级、系别…）</p>
</li>
<li><p><code>课程信息表</code>：一行代表一个课程的信息（课程编号、授课老师、简介…）</p>
</li>
<li><p><code>选课信息表</code>：一个学生可以选多门课，一门课可以被多个学生选择</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">学号     课程编号  </span><br><span class="line">1        1001</span><br><span class="line">2        1001</span><br><span class="line">1        1002</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>举例2：产品-订单</strong></p>
<p>“订单”表和“产品”表有一种多对多的关系，这种关系是通过与“订单明细”表建立两个一对多关系来定义的。一个订单可以有多个产品，每个产品可以出现在多个订单中。</p>
<ul>
<li><code>产品表</code>：“产品”表中的每条记录表示一个产品。</li>
<li><code>订单表</code>：“订单”表中的每条记录表示一个订单。</li>
<li><code>订单明细表</code>：每个产品可以与“订单”表中的多条记录对应，即出现在多个订单中。一个订单可以与“产品”表中的多条记录对应，即包含多个产品。</li>
</ul>
</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20210914235637068.png"
                        alt="image-20210914235637068"
                 ></p>
<ul>
<li><strong>举例3：用户-角色</strong></li>
<li>多对多关系建表原则：需要创建第三张表，中间表中至少两个字段，这两个字段分别作为外键指向各自一方的主键。</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20210915084707586.png"
                        alt="image-20210915084707586"
                 ></p>
<h4 id="5-3-4-自我引用-Self-reference"><a href="#5-3-4-自我引用-Self-reference" class="headerlink" title="5.3.4 自我引用(Self reference)"></a>5.3.4 自我引用(Self reference)</h4><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20210914235651997.png"
                        alt="image-20210914235651997"
                 ></p>
<hr>
<h1 id="第02章-MySQL环境搭建"><a href="#第02章-MySQL环境搭建" class="headerlink" title="第02章_MySQL环境搭建"></a>第02章_MySQL环境搭建</h1><p>讲师：尚硅谷 宋红康（江湖人称：康师傅）</p>
<hr>
<h2 id="1-MySQL的卸载"><a href="#1-MySQL的卸载" class="headerlink" title="1. MySQL的卸载"></a>1. MySQL的卸载</h2><h3 id="步骤1：停止MySQL服务"><a href="#步骤1：停止MySQL服务" class="headerlink" title="步骤1：停止MySQL服务"></a>步骤1：停止MySQL服务</h3><p>在卸载之前，先停止MySQL8.0的服务。按键盘上的“Ctrl + Alt + Delete”组合键，打开“任务管理器”对话框，可以在“服务”列表找到“MySQL8.0”的服务，如果现在“正在运行”状态，可以右键单击服务，选择“停止”选项停止MySQL8.0的服务，如图所示。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211014153604802.png"
                        alt="image-20211014153604802"
                 ></p>
<h3 id="步骤2：软件的卸载"><a href="#步骤2：软件的卸载" class="headerlink" title="步骤2：软件的卸载"></a>步骤2：软件的卸载</h3><p><strong>方式1：通过控制面板方式</strong></p>
<p>卸载MySQL8.0的程序可以和其他桌面应用程序一样直接在“控制面板”选择“卸载程序”，并在程序列表中找到MySQL8.0服务器程序，直接双击卸载即可，如图所示。这种方式删除，数据目录下的数据不会跟着删除。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211014153657668.png"
                        alt="image-20211014153657668"
                 ></p>
<p><strong>方式2：通过360或电脑管家等软件卸载</strong></p>
<p>略</p>
<p><strong>方式3：通过安装包提供的卸载功能卸载</strong></p>
<p>你也可以通过安装向导程序进行MySQL8.0服务器程序的卸载。</p>
<p>① 再次双击下载的mysql-installer-community-8.0.26.0.msi文件，打开安装向导。安装向导会自动检测已安装的MySQL服务器程序。</p>
<p>② 选择要卸载的MySQL服务器程序，单击“Remove”（移除），即可进行卸载。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211014153722683.png"
                        alt="image-20211014153722683"
                 ></p>
<p>③ 单击“Next”（下一步）按钮，确认卸载。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211014153747283.png"
                        alt="image-20211014153747283"
                 ></p>
<p>④ 弹出是否同时移除数据目录选择窗口。如果想要同时删除MySQL服务器中的数据，则勾选“Remove the data directory”，如图所示。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211014154112574.png"
                         alt="image-20211014154112574" style="zoom:80%;" 
                 >

<p>⑤ 执行卸载。单击“Execute”（执行）按钮进行卸载。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211014154006530.png"
                         alt="image-20211014154006530" style="zoom:90%;" 
                 >

<p>⑥ 完成卸载。单击“Finish”（完成）按钮即可。如果想要同时卸载MySQL8.0的安装向导程序，勾选“Yes，Uninstall MySQL Installer”即可，如图所示。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211014154046268.png"
                         alt="image-20211014154046268" style="zoom:80%;" 
                 >

<h3 id="步骤3：残余文件的清理"><a href="#步骤3：残余文件的清理" class="headerlink" title="步骤3：残余文件的清理"></a>步骤3：残余文件的清理</h3><p>如果再次安装不成功，可以卸载后对残余文件进行清理后再安装。</p>
<p>（1）服务目录：mysql服务的安装目录</p>
<p>（2）数据目录：默认在C:\ProgramData\MySQL</p>
<p>如果自己单独指定过数据目录，就找到自己的数据目录进行删除即可。</p>
<blockquote>
<p>注意：请在卸载前做好数据备份</p>
<p>在操作完以后，需要重启计算机，然后进行安装即可。<strong>如果仍然安装失败，需要继续操作如下步骤4。</strong></p>
</blockquote>
<h3 id="步骤4：清理注册表（选做）"><a href="#步骤4：清理注册表（选做）" class="headerlink" title="步骤4：清理注册表（选做）"></a>步骤4：清理注册表（选做）</h3><p>如果前几步做了，再次安装还是失败，那么可以清理注册表。</p>
<p>如何打开注册表编辑器：在系统的搜索框中输入<code>regedit</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\Eventlog\Application\MySQL服务 目录删除</span><br><span class="line"></span><br><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\MySQL服务 目录删除</span><br><span class="line"></span><br><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\Eventlog\Application\MySQL服务 目录删除</span><br><span class="line"></span><br><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\Services\MySQL服务 目录删除</span><br><span class="line"></span><br><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application\MySQL服务目录删除</span><br><span class="line"></span><br><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\MySQL服务删除</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注册表中的ControlSet001,ControlSet002,不一定是001和002,可能是ControlSet005、006之类</p>
</blockquote>
<h3 id="步骤5：删除环境变量配置"><a href="#步骤5：删除环境变量配置" class="headerlink" title="步骤5：删除环境变量配置"></a>步骤5：删除环境变量配置</h3><p>找到path环境变量，将其中关于mysql的环境变量删除，<strong>切记不要全部删除。</strong></p>
<p>例如：删除  D:\develop_tools\mysql\MySQLServer8.0.26\bin;  这个部分</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1575694476072.png"
                        alt="1575694476072"
                 ></p>
<h2 id="2-MySQL的下载、安装、配置"><a href="#2-MySQL的下载、安装、配置" class="headerlink" title="2. MySQL的下载、安装、配置"></a>2. MySQL的下载、安装、配置</h2><h3 id="2-1-MySQL的4大版本"><a href="#2-1-MySQL的4大版本" class="headerlink" title="2.1 MySQL的4大版本"></a>2.1 MySQL的4大版本</h3><blockquote>
<ul>
<li><p><strong>MySQL Community Server 社区版本</strong>，开源免费，自由下载，但不提供官方技术支持，适用于大多数普通用户。</p>
</li>
<li><p><strong>MySQL Enterprise Edition 企业版本</strong>，需付费，不能在线下载，可以试用30天。提供了更多的功能和更完备的技术支持，更适合于对数据库的功能和可靠性要求较高的企业客户。</p>
</li>
<li><p><strong>MySQL Cluster 集群版</strong>，开源免费。用于架设集群服务器，可将几个MySQL Server封装成一个Server。需要在社区版或企业版的基础上使用。</p>
</li>
<li><p><strong>MySQL Cluster CGE 高级集群版</strong>，需付费。</p>
</li>
</ul>
</blockquote>
<ul>
<li><p>目前最新版本为<code>8.0.27</code>，发布时间<code>2021年10月</code>。此前，8.0.0 在 2016.9.12日就发布了。</p>
</li>
<li><p>本课程中使用<code>8.0.26版本</code>。</p>
</li>
</ul>
<p>此外，官方还提供了<code>MySQL Workbench</code>（GUITOOL）一款专为MySQL设计的<code>图形界面管理工具</code>。MySQLWorkbench又分为两个版本，分别是<code>社区版</code>（MySQL Workbench OSS）、<code>商用版</code>（MySQL WorkbenchSE）。</p>
<h3 id="2-2-软件的下载"><a href="#2-2-软件的下载" class="headerlink" title="2.2 软件的下载"></a>2.2 软件的下载</h3><p><strong>1. 下载地址</strong></p>
<p>官网：<a class="link"   href="https://www.mysql.com/" >https://www.mysql.com<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>2. 打开官网，点击DOWNLOADS</strong></p>
<p>然后，点击<code>MySQL Community(GPL) Downloads</code></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20210817185920150.png"
                        alt="image-20210817185920150"
                 ></p>
<p><strong>3. 点击 MySQL Community Server</strong></p>
 <img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20210817185955123.png"
                         alt="image-20210817185955123" style="zoom:80%;" 
                 >

<p><strong>4. 在General Availability(GA) Releases中选择适合的版本</strong></p>
<p>Windows平台下提供两种安装文件：MySQL二进制分发版（.msi安装文件）和免安装版（.zip压缩文件）。一般来讲，应当使用二进制分发版，因为该版本提供了图形化的安装向导过程，比其他的分发版使用起来要简单，不再需要其他工具启动就可以运行MySQL。</p>
<ul>
<li>这里在Windows 系统下推荐下载<code>MSI安装程序</code>；点击<code>Go to Download Page</code>进行下载即可</li>
</ul>
 <img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20210727192819147.png"
                         alt="image-20210727192819147" style="zoom:67%;" 
                 >

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211014163001964.png"
                        alt="image-20211014163001964"
                 ></p>
<ul>
<li>Windows下的MySQL8.0安装有两种安装程序<ul>
<li><code>mysql-installer-web-community-8.0.26.0.msi</code> 下载程序大小：2.4M；安装时需要联网安装组件。</li>
<li><code>mysql-installer-community-8.0.26.0.msi</code> 下载程序大小：450.7M；安装时离线安装即可。<strong>推荐。</strong></li>
</ul>
</li>
<li>如果安装MySQL5.7版本的话，选择<code>Archives</code>，接着选择MySQL5.7的相应版本即可。这里下载最近期的MySQL5.7.34版本。</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211014163228051.png"
                        alt="image-20211014163228051"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211014163353156.png"
                        alt="image-20211014163353156"
                 ></p>
<h3 id="2-3-MySQL8-0-版本的安装"><a href="#2-3-MySQL8-0-版本的安装" class="headerlink" title="2.3 MySQL8.0 版本的安装"></a>2.3 MySQL8.0 版本的安装</h3><p>MySQL下载完成后，找到下载文件，双击进行安装，具体操作步骤如下。</p>
<p>步骤1：双击下载的mysql-installer-community-8.0.26.0.msi文件，打开安装向导。</p>
<p>步骤2：打开“Choosing a Setup Type”（选择安装类型）窗口，在其中列出了5种安装类型，分别是Developer Default（默认安装类型）、Server only（仅作为服务器）、Client only（仅作为客户端）、Full（完全安装）、Custom（自定义安装）。这里选择“Custom（自定义安装）”类型按钮，单击“Next(下一步)”按钮。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211014170553535.png"
                         alt="image-20211014170553535" style="zoom:90%;" 
                 >

<p>步骤3：打开“Select Products” （选择产品）窗口，可以定制需要安装的产品清单。例如，选择“MySQL Server 8.0.26-X64”后，单击“→”添加按钮，即可选择安装MySQL服务器，如图所示。采用通用的方法，可以添加其他你需要安装的产品。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211014170638699.png"
                         alt="image-20211014170638699" style="zoom:80%;" 
                 >

<p>此时如果直接“Next”（下一步），则产品的安装路径是默认的。如果想要自定义安装目录，则可以选中对应的产品，然后在下面会出现“Advanced Options”（高级选项）的超链接。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211014170814386.png"
                         alt="image-20211014170814386" style="zoom:80%;" 
                 >

<p>单击“Advanced Options”（高级选项）则会弹出安装目录的选择窗口，如图所示，此时你可以分别设置MySQL的服务程序安装目录和数据存储目录。如果不设置，默认分别在C盘的Program Files目录和ProgramData目录（这是一个隐藏目录）。如果自定义安装目录，请避免“中文”目录。另外，建议服务目录和数据目录分开存放。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211014170857263.png"
                         alt="image-20211014170857263" style="zoom:80%;" 
                 >

<p>步骤4：在上一步选择好要安装的产品之后，单击“Next”（下一步）进入确认窗口，如图所示。单击“Execute”（执行）按钮开始安装。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211014170934889.png"
                         alt="image-20211014170934889" style="zoom:90%;" 
                 >

<p>步骤5：安装完成后在“Status”（状态）列表下将显示“Complete”（安装完成），如图所示。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211014171002259.png"
                         alt="image-20211014171002259" style="zoom:90%;" 
                 >

<h3 id="2-4-配置MySQL8-0"><a href="#2-4-配置MySQL8-0" class="headerlink" title="2.4 配置MySQL8.0"></a>2.4 配置MySQL8.0</h3><p>MySQL安装之后，需要对服务器进行配置。具体的配置步骤如下。</p>
<p>步骤1：在上一个小节的最后一步，单击“Next”（下一步）按钮，就可以进入产品配置窗口。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/clip_image002-1634203188594.jpg"
                         alt="img" style="zoom:80%;" 
                 >

<p>步骤2：单击“Next”（下一步）按钮，进入MySQL服务器类型配置窗口，如图所示。端口号一般选择默认端口号3306。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/clip_image004-1634203188595.jpg"
                         alt="img" style="zoom:80%;" 
                 >

<p>其中，“Config Type”选项用于设置服务器的类型。单击该选项右侧的下三角按钮，即可查看3个选项，如图所示。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/clip_image006-1634203188595.jpg"
                         alt="img" style="zoom:80%;" 
                 >

<ul>
<li><p><code>Development Machine（开发机器）</code>：该选项代表典型个人用桌面工作站。此时机器上需要运行多个应用程序，那么MySQL服务器将占用最少的系统资源。</p>
</li>
<li><p><code>Server Machine（服务器）</code>：该选项代表服务器，MySQL服务器可以同其他服务器应用程序一起运行，例如Web服务器等。MySQL服务器配置成适当比例的系统资源。</p>
</li>
<li><p><code>Dedicated Machine（专用服务器）</code>：该选项代表只运行MySQL服务的服务器。MySQL服务器配置成使用所有可用系统资源。</p>
</li>
</ul>
<p>步骤3：单击“Next”（下一步）按钮，打开设置授权方式窗口。其中，上面的选项是MySQL8.0提供的新的授权方式，采用SHA256基础的密码加密方法；下面的选项是传统授权方法（保留5.x版本兼容性）。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/clip_image008-1634203188595.jpg"
                         alt="img" style="zoom:80%;" 
                 >

<p>步骤4：单击“Next”（下一步）按钮，打开设置服务器root超级管理员的密码窗口，如图所示，需要输入两次同样的登录密码。也可以通过“Add User”添加其他用户，添加其他用户时，需要指定用户名、允许该用户名在哪台&#x2F;哪些主机上登录，还可以指定用户角色等。此处暂不添加用户，用户管理在MySQL高级特性篇中讲解。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/clip_image010-1634203188595.jpg"
                         alt="img" style="zoom:80%;" 
                 >

<p>步骤5：单击“Next”（下一步）按钮，打开设置服务器名称窗口，如图所示。该服务名会出现在Windows服务列表中，也可以在命令行窗口中使用该服务名进行启动和停止服务。本书将服务名设置为“MySQL80”。如果希望开机自启动服务，也可以勾选“Start the MySQL Server at System Startup”选项（推荐）。</p>
<p>下面是选择以什么方式运行服务？可以选择“Standard System Account”(标准系统用户)或者“Custom User”(自定义用户)中的一个。这里推荐前者。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/clip_image012-1634203188596.jpg"
                         alt="img" style="zoom:80%;" 
                 >

<p>步骤6：单击“Next”（下一步）按钮，打开确认设置服务器窗口，单击“Execute”（执行）按钮。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/clip_image014-1634203188596.jpg"
                         alt="img" style="zoom:80%;" 
                 >

<p>步骤7：完成配置，如图所示。单击“Finish”（完成）按钮，即可完成服务器的配置。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/clip_image016.jpg"
                         alt="img" style="zoom:80%;" 
                 >

<p>步骤8：如果还有其他产品需要配置，可以选择其他产品，然后继续配置。如果没有，直接选择“Next”（下一步），直接完成整个安装和配置过程。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/clip_image018.jpg"
                         alt="img" style="zoom:80%;" 
                 >

<p>步骤9：结束安装和配置。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/clip_image020.jpg"
                         alt="img" style="zoom:80%;" 
                 >

<h3 id="2-5-配置MySQL8-0-环境变量"><a href="#2-5-配置MySQL8-0-环境变量" class="headerlink" title="2.5 配置MySQL8.0 环境变量"></a>2.5 配置MySQL8.0 环境变量</h3><p>如果不配置MySQL环境变量，就不能在命令行直接输入MySQL登录命令。下面说如何配置MySQL的环境变量：</p>
<p>步骤1：在桌面上右击【此电脑】图标，在弹出的快捷菜单中选择【属性】菜单命令。<br>步骤2：打开【系统】窗口，单击【高级系统设置】链接。<br>步骤3：打开【系统属性】对话框，选择【高级】选项卡，然后单击【环境变量】按钮。<br>步骤4：打开【环境变量】对话框，在系统变量列表中选择path变量。<br>步骤5：单击【编辑】按钮，在【编辑环境变量】对话框中，将MySQL应用程序的bin目录（C:\Program Files\MySQL\MySQL Server 8.0\bin）添加到变量值中，用分号将其与其他路径分隔开。<br>步骤6：添加完成之后，单击【确定】按钮，这样就完成了配置path变量的操作，然后就可以直接输入MySQL命令来登录数据库了。</p>
<h3 id="2-6-MySQL5-7-版本的安装、配置"><a href="#2-6-MySQL5-7-版本的安装、配置" class="headerlink" title="2.6 MySQL5.7 版本的安装、配置"></a>2.6 MySQL5.7 版本的安装、配置</h3><ul>
<li><strong>安装</strong></li>
</ul>
<p>此版本的安装过程与上述过程除了版本号不同之外，其它环节都是相同的。所以这里省略了MySQL5.7.34版本的安装截图。</p>
<ul>
<li><strong>配置</strong></li>
</ul>
<p>配置环节与MySQL8.0版本确有细微不同。大部分情况下直接选择“Next”即可，不影响整理使用。</p>
<p>这里配置MySQL5.7时，重点强调：<strong>与前面安装好的MySQL8.0不能使用相同的端口号。</strong></p>
<h3 id="2-7-安装失败问题"><a href="#2-7-安装失败问题" class="headerlink" title="2.7 安装失败问题"></a>2.7 安装失败问题</h3><p>MySQL的安装和配置是一件非常简单的事，但是在操作过程中也可能出现问题，特别是初学者。</p>
<p><strong>问题1：无法打开MySQL8.0软件安装包或者安装过程中失败，如何解决？</strong></p>
<p>在运行MySQL8.0软件安装包之前，用户需要确保系统中已经安装了.Net Framework相关软件，如果缺少此软件，将不能正常地安装MySQL8.0软件。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/clip_image002.gif"
                         alt="img" style="zoom:80%;" 
                 >

<p>解决方案：到这个地址<a class="link"   href="https://www.microsoft.com/en-us/download/details.aspx?id=42642%E4%B8%8B%E8%BD%BDMicrosoft" >https://www.microsoft.com/en-us/download/details.aspx?id=42642下载Microsoft<i class="fas fa-external-link-alt"></i></a> .NET Framework 4.5并安装后，再去安装MySQL。</p>
<p>另外，还要确保Windows Installer正常安装。windows上安装mysql8.0需要操作系统提前已安装好Microsoft Visual C++ 2015-2019。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/clip_image004.gif"
                         alt="img" style="zoom:75%;" 
                 >

<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/clip_image006.gif"
                         alt="img" style="zoom:75%;" 
                 >

<p>解决方案同样是，提前到微软官网<a class="link"   href="https://support.microsoft.com/en-us/topic/the-latest-supported-visual-c-downloads-2647da03-1eea-4433-9aff-95f26a218cc0%EF%BC%8C%E4%B8%8B%E8%BD%BD%E7%9B%B8%E5%BA%94%E7%9A%84%E7%8E%AF%E5%A2%83%E3%80%82" >https://support.microsoft.com/en-us/topic/the-latest-supported-visual-c-downloads-2647da03-1eea-4433-9aff-95f26a218cc0，下载相应的环境。<i class="fas fa-external-link-alt"></i></a></p>
<p><strong>问题2：卸载重装MySQL失败？</strong></p>
<p>该问题通常是因为MySQL卸载时，没有完全清除相关信息导致的。</p>
<p>解决办法是，把以前的安装目录删除。如果之前安装并未单独指定过服务安装目录，则默认安装目录是“C:\Program Files\MySQL”，彻底删除该目录。同时删除MySQL的Data目录，如果之前安装并未单独指定过数据目录，则默认安装目录是“C:\ProgramData\MySQL”，该目录一般为隐藏目录。删除后，重新安装即可。</p>
<p><strong>问题3：如何在Windows系统删除之前的未卸载干净的MySQL服务列表？</strong></p>
<p>操作方法如下，在系统“搜索框”中输入“cmd”，按“Enter”（回车）键确认，弹出命令提示符界面。然后输入“sc delete MySQL服务名”,按“Enter”（回车）键，就能彻底删除残余的MySQL服务了。</p>
<h2 id="3-MySQL的登录"><a href="#3-MySQL的登录" class="headerlink" title="3. MySQL的登录"></a>3. MySQL的登录</h2><h3 id="3-1-服务的启动与停止"><a href="#3-1-服务的启动与停止" class="headerlink" title="3.1 服务的启动与停止"></a>3.1 服务的启动与停止</h3><p>MySQL安装完毕之后，需要启动服务器进程，不然客户端无法连接数据库。</p>
<p>在前面的配置过程中，已经将MySQL安装为Windows服务，并且勾选当Windows启动、停止时，MySQL也自动启动、停止。</p>
<h4 id="方式1：使用图形界面工具"><a href="#方式1：使用图形界面工具" class="headerlink" title="方式1：使用图形界面工具"></a>方式1：使用图形界面工具</h4><ul>
<li><p>步骤1：打开windows服务</p>
<ul>
<li>方式1：计算机（点击鼠标右键）→ 管理（点击）→ 服务和应用程序（点击）→ 服务（点击）</li>
<li>方式2：控制面板（点击）→ 系统和安全（点击）→ 管理工具（点击）→ 服务（点击）</li>
<li>方式3：任务栏（点击鼠标右键）→ 启动任务管理器（点击）→ 服务（点击）</li>
<li>方式4：单击【开始】菜单，在搜索框中输入“services.msc”，按Enter键确认</li>
</ul>
</li>
<li><p>步骤2：找到MySQL80（点击鼠标右键）→ 启动或停止（点击）</p>
</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211014183908375.png"
                        alt="image-20211014183908375"
                 ></p>
<h4 id="方式2：使用命令行工具"><a href="#方式2：使用命令行工具" class="headerlink" title="方式2：使用命令行工具"></a>方式2：使用命令行工具</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动 MySQL 服务命令：</span><br><span class="line">net start MySQL服务名</span><br><span class="line"></span><br><span class="line"># 停止 MySQL 服务命令：</span><br><span class="line">net stop MySQL服务名</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211014184037414.png"
                         alt="image-20211014184037414" style="zoom:80%;" 
                 >

<p>说明：</p>
<ol>
<li><p>start和stop后面的服务名应与之前配置时指定的服务名一致。</p>
</li>
<li><p>如果当你输入命令后，提示“拒绝服务”，请以<code>系统管理员身份</code>打开命令提示符界面重新尝试。</p>
</li>
</ol>
<h3 id="3-2-自带客户端的登录与退出"><a href="#3-2-自带客户端的登录与退出" class="headerlink" title="3.2 自带客户端的登录与退出"></a>3.2 自带客户端的登录与退出</h3><p>当MySQL服务启动完成后，便可以通过客户端来登录MySQL数据库。注意：确认服务是开启的。</p>
<h4 id="登录方式1：MySQL自带客户端"><a href="#登录方式1：MySQL自带客户端" class="headerlink" title="登录方式1：MySQL自带客户端"></a>登录方式1：MySQL自带客户端</h4><p>开始菜单 → 所有程序 → MySQL → MySQL 8.0 Command Line Client</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211014184425147.png"
                         alt="image-20211014184425147" style="zoom:80%;" 
                 >

<blockquote>
<p>说明：仅限于root用户</p>
</blockquote>
<h4 id="登录方式2：windows命令行"><a href="#登录方式2：windows命令行" class="headerlink" title="登录方式2：windows命令行"></a>登录方式2：windows命令行</h4><ul>
<li>格式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -h 主机名 -P 端口号 -u 用户名 -p密码</span><br></pre></td></tr></table></figure>

<ul>
<li>举例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -h localhost -P 3306 -u root -pabc123  # 这里我设置的root用户的密码是abc123</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211014185035137.png"
                         alt="image-20211014185035137" style="zoom:80%;" 
                 >

<p>注意：</p>
<p>（1）-p与密码之间不能有空格，其他参数名与参数值之间可以有空格也可以没有空格。如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>hlocalhost <span class="operator">-</span>P3306 <span class="operator">-</span>uroot <span class="operator">-</span>pabc123</span><br></pre></td></tr></table></figure>

<p>（2）密码建议在下一行输入，保证安全</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h localhost <span class="operator">-</span>P <span class="number">3306</span> <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line">Enter password:<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br></pre></td></tr></table></figure>

<p>（3）客户端和服务器在同一台机器上，所以输入localhost或者IP地址127.0.0.1。同时，因为是连接本机：<br>-hlocalhost就可以省略，如果端口号没有修改：-P3306也可以省略</p>
<p>简写成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line">Enter password:<span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br></pre></td></tr></table></figure>

<p>连接成功后，有关于MySQL Server服务版本的信息，还有第几次连接的id标识。</p>
<p>也可以在命令行通过以下方式获取MySQL Server服务版本的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c:\&gt; mysql -V</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c:\&gt; mysql --version</span><br></pre></td></tr></table></figure>

<p>或<strong>登录</strong>后，通过以下方式查看当前版本信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select version();</span><br></pre></td></tr></table></figure>

<h4 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br><span class="line">或</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>

<h2 id="4-MySQL演示使用"><a href="#4-MySQL演示使用" class="headerlink" title="4. MySQL演示使用"></a>4. MySQL演示使用</h2><h3 id="4-1-MySQL的使用演示"><a href="#4-1-MySQL的使用演示" class="headerlink" title="4.1 MySQL的使用演示"></a>4.1 MySQL的使用演示</h3><p>1、查看所有的数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>“information_schema”是 MySQL 系统自带的数据库，主要保存 MySQL 数据库服务器的系统信息，比如数据库的名称、数据表的名称、字段名称、存取权限、数据文件 所在的文件夹和系统使用的文件夹，等等</p>
<p>“performance_schema”是 MySQL 系统自带的数据库，可以用来监控 MySQL 的各类性能指标。</p>
<p>“sys”数据库是 MySQL 系统自带的数据库，主要作用是以一种更容易被理解的方式展示 MySQL 数据库服务器的各类性能指标，帮助系统管理员和开发人员监控 MySQL 的技术性能。</p>
<p>“mysql”数据库保存了 MySQL 数据库服务器运行时需要的系统信息，比如数据文件夹、当前使用的字符集、约束检查信息，等等</p>
</blockquote>
<p>为什么 Workbench 里面我们只能看到“demo”和“sys”这 2 个数据库呢？</p>
<p>这是因为，Workbench 是图形化的管理工具，主要面向开发人 员，“demo”和“sys”这 2 个数据库已经够用了。如果有特殊需求，比如，需要监控 MySQL 数据库各项性能指标、直接操作 MySQL 数据库系统文件等，可以由 DBA 通过 SQL 语句，查看其它的系统数据库。</p>
<p>2、创建自己的数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database 数据库名;</span><br><span class="line"></span><br><span class="line">#创建atguigudb数据库，该名称不能与已经存在的数据库重名。</span><br><span class="line">create database atguigudb;</span><br></pre></td></tr></table></figure>

<p>3、使用自己的数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use 数据库名;</span><br><span class="line"></span><br><span class="line">#使用atguigudb数据库</span><br><span class="line">use atguigudb;</span><br></pre></td></tr></table></figure>

<p>说明：如果没有使用use语句，后面针对数据库的操作也没有加“数据名”的限定，那么会报“ERROR 1046 (3D000): No database selected”（没有选择数据库）</p>
<p>使用完use语句之后，如果接下来的SQL都是针对一个数据库操作的，那就不用重复use了，如果要针对另一个数据库操作，那么要重新use。</p>
<p>4、查看某个库的所有表格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show tables;  #要求前面有use语句</span><br><span class="line"></span><br><span class="line">show tables from 数据库名;</span><br></pre></td></tr></table></figure>

<p>5、创建新的表格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">	字段名  数据类型,</span><br><span class="line">	字段名 数据类型</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>说明：如果是最后一个字段，后面就用加逗号，因为逗号的作用是分割每个字段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建学生表</span><br><span class="line">create table student(</span><br><span class="line">	id int,</span><br><span class="line">    name varchar(20)  #说名字最长不超过20个字符</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>6、查看一个表的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from 数据库表名称;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看学生表的数据</span><br><span class="line">select * from student;</span><br></pre></td></tr></table></figure>

<p>7、添加一条记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into 表名称 values(值列表);</span><br><span class="line"></span><br><span class="line">#添加两条记录到student表中</span><br><span class="line">insert into student values(1,&#x27;张三&#x27;);</span><br><span class="line">insert into student values(2,&#x27;李四&#x27;);</span><br></pre></td></tr></table></figure>

<p>报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into student values(1,&#x27;张三&#x27;);</span><br><span class="line">ERROR 1366 (HY000): Incorrect string value: &#x27;\xD5\xC5\xC8\xFD&#x27; for column &#x27;name&#x27; at row 1</span><br><span class="line">mysql&gt; insert into student values(2,&#x27;李四&#x27;);</span><br><span class="line">ERROR 1366 (HY000): Incorrect string value: &#x27;\xC0\xEE\xCB\xC4&#x27; for column &#x27;name&#x27; at row 1</span><br><span class="line">mysql&gt; show create table student;</span><br></pre></td></tr></table></figure>

<p>字符集的问题。</p>
<p>8、查看表的创建信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show create table 表名称\G</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看student表的详细创建信息</span><br><span class="line">show create table student\G</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#结果如下</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: student</span><br><span class="line">Create Table: CREATE TABLE `student` (</span><br><span class="line">  `id` int(11) DEFAULT NULL,</span><br><span class="line">  `name` varchar(20) DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=latin1</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>上面的结果显示student的表格的默认字符集是“latin1”不支持中文。</p>
<p>9、查看数据库的创建信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show create database 数据库名\G</span><br><span class="line"></span><br><span class="line">#查看atguigudb数据库的详细创建信息</span><br><span class="line">show create database atguigudb\G</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#结果如下</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Database: atguigudb</span><br><span class="line">Create Database: CREATE DATABASE `atguigudb` /*!40100 DEFAULT CHARACTER SET latin1 */</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>上面的结果显示atguigudb数据库也不支持中文，字符集默认是latin1。</p>
<p>10、删除表格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table 表名称;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#删除学生表</span><br><span class="line">drop table student;</span><br></pre></td></tr></table></figure>

<p>11、删除数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop database 数据库名;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#删除atguigudb数据库</span><br><span class="line">drop database atguigudb;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-MySQL的编码设置"><a href="#4-2-MySQL的编码设置" class="headerlink" title="4.2 MySQL的编码设置"></a>4.2 MySQL的编码设置</h3><h4 id="MySQL5-7中"><a href="#MySQL5-7中" class="headerlink" title="MySQL5.7中"></a>MySQL5.7中</h4><p><strong>问题再现：命令行操作sql乱码问题</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; INSERT INTO t_stu VALUES(1,&#x27;张三&#x27;,&#x27;男&#x27;);</span><br><span class="line">ERROR 1366 (HY000): Incorrect string value: &#x27;\xD5\xC5\xC8\xFD&#x27; for column &#x27;sname&#x27; at row 1</span><br></pre></td></tr></table></figure>

<p><strong>问题解决</strong></p>
<p>步骤1：查看编码命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;character_%&#x27;;</span><br><span class="line">show variables like &#x27;collation_%&#x27;;</span><br></pre></td></tr></table></figure>

<p>步骤2：修改mysql的数据目录下的my.ini配置文件</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[mysql]</span>  <span class="comment">#大概在63行左右，在其下添加</span></span><br><span class="line">... </span><br><span class="line"><span class="attr">default-character-set</span>=utf8  <span class="comment">#默认字符集</span></span><br><span class="line"></span><br><span class="line"><span class="section">[mysqld]</span>  <span class="comment"># 大概在76行左右，在其下添加</span></span><br><span class="line">...</span><br><span class="line"><span class="attr">character-set-server</span>=utf8</span><br><span class="line"><span class="attr">collation-server</span>=utf8_general_ci</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：建议修改配置文件使用notepad++等高级文本编辑器，使用记事本等软件打开修改后可能会导致文件编码修改为“含BOM头”的编码，从而服务重启失败。</p>
</blockquote>
<p>步骤3：重启服务</p>
<p>步骤4：查看编码命令</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;character_%&#x27;</span>;</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;collation_%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/MySQL编码1.jpg"
                         style="zoom:90%;" 
                 >

<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/MySQL编码2.jpg"
                         style="zoom:90%;" 
                 >

<ul>
<li>如果是以上配置就说明对了。接着我们就可以新创建数据库、新创建数据表，接着添加包含中文的数据了。</li>
</ul>
<h4 id="MySQL8-0中"><a href="#MySQL8-0中" class="headerlink" title="MySQL8.0中"></a>MySQL8.0中</h4><p>在MySQL 8.0版本之前，默认字符集为latin1，utf8字符集指向的是utf8mb3。网站开发人员在数据库设计的时候往往会将编码修改为utf8字符集。如果遗忘修改默认的编码，就会出现乱码的问题。从MySQL 8.0开始，数据库的默认编码改为<code>utf8mb4</code>，从而避免了上述的乱码问题。</p>
<h2 id="5-MySQL图形化管理工具"><a href="#5-MySQL图形化管理工具" class="headerlink" title="5. MySQL图形化管理工具"></a>5. MySQL图形化管理工具</h2><p>MySQL图形化管理工具极大地方便了数据库的操作与管理，常用的图形化管理工具有：MySQL Workbench、phpMyAdmin、Navicat Preminum、MySQLDumper、SQLyog、dbeaver、MySQL ODBC Connector。</p>
<h3 id="工具1-MySQL-Workbench"><a href="#工具1-MySQL-Workbench" class="headerlink" title="工具1. MySQL Workbench"></a>工具1. MySQL Workbench</h3><p>MySQL官方提供的图形化管理工具MySQL Workbench完全支持MySQL 5.0以上的版本。MySQL Workbench分为社区版和商业版，社区版完全免费，而商业版则是按年收费。</p>
<p>MySQL Workbench 为数据库管理员、程序开发者和系统规划师提供可视化设计、模型建立、以及数据库管理功能。它包含了用于创建复杂的数据建模ER模型，正向和逆向数据库工程，也可以用于执行通常需要花费大量时间的、难以变更和管理的文档任务。</p>
<p>下载地址：<a class="link"   href="http://dev.mysql.com/downloads/workbench/%E3%80%82" >http://dev.mysql.com/downloads/workbench/。<i class="fas fa-external-link-alt"></i></a></p>
<p>使用：</p>
<p>首先，我们点击 Windows 左下角的“开始”按钮，如果你是 Win10 系统，可以直接看到所有程序。接着，找到“MySQL”，点开，找到“MySQL Workbench 8.0 CE”。点击打开 Workbench，如下图所示：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211007153522427.png"
                        alt="image-20211007153522427"
                 ></p>
<p>左下角有个本地连接，点击，录入 Root 的密码，登录本地 MySQL 数据库服务器，如下图所示：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211014195108502.png"
                         alt="image-20211014195108502" style="zoom:80%;" 
                 >

<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211014195129219.png"
                         alt="image-20211014195129219" style="zoom:80%;" 
                 >

<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211014195142849.png"
                         alt="image-20211014195142849" style="zoom:80%;" 
                 >

<p>这是一个图形化的界面，我来给你介绍下这个界面。</p>
<ul>
<li><p>上方是菜单。左上方是导航栏，这里我们可以看到 MySQL 数据库服务器里面的数据 库，包括数据表、视图、存储过程和函数；左下方是信息栏，可以显示上方选中的数据 库、数据表等对象的信息。</p>
</li>
<li><p>中间上方是工作区，你可以在这里写 SQL 语句，点击上方菜单栏左边的第三个运行按 钮，就可以执行工作区的 SQL 语句了。</p>
</li>
<li><p>中间下方是输出区，用来显示 SQL 语句的运行情况，包括什么时间开始运行的、运行的 内容、运行的输出，以及所花费的时长等信息。</p>
</li>
</ul>
<p>好了，下面我们就用 Workbench 实际创建一个数据库，并且导入一个 Excel 数据文件， 来生成一个数据表。数据表是存储数据的载体，有了数据表以后，我们就能对数据进行操作了。</p>
<h3 id="工具2-Navicat"><a href="#工具2-Navicat" class="headerlink" title="工具2. Navicat"></a>工具2. Navicat</h3><p>Navicat MySQL是一个强大的MySQL数据库服务器管理和开发工具。它可以与任何3.21或以上版本的MySQL一起工作，支持触发器、存储过程、函数、事件、视图、管理用户等，对于新手来说易学易用。其精心设计的图形用户界面（GUI）可以让用户用一种安全简便的方式来快速方便地创建、组织、访问和共享信息。Navicat支持中文，有免费版本提供。<br>下载地址：<a class="link"   href="http://www.navicat.com/%E3%80%82" >http://www.navicat.com/。<i class="fas fa-external-link-alt"></i></a></p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/1557378069584.png"
                         style="zoom:80%;" 
                 >

<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20210913180359685.png"
                         alt="image-20210913180359685" style="zoom:80%;" 
                 >

<h3 id="工具3-SQLyog"><a href="#工具3-SQLyog" class="headerlink" title="工具3. SQLyog"></a>工具3. SQLyog</h3><p>SQLyog 是业界著名的 Webyog 公司出品的一款简洁高效、功能强大的图形化 MySQL 数据库管理工具。这款工具是使用C++语言开发的。该工具可以方便地创建数据库、表、视图和索引等，还可以方便地进行插入、更新和删除等操作，同时可以方便地进行数据库、数据表的备份和还原。该工具不仅可以通过SQL文件进行大量文件的导入和导出，还可以导入和导出XML、HTML和CSV等多种格式的数据。<br>下载地址：<a class="link"   href="http://www.webyog.com/%EF%BC%8C%E8%AF%BB%E8%80%85%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%90%9C%E7%B4%A2%E4%B8%AD%E6%96%87%E7%89%88%E7%9A%84%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E3%80%82" >http://www.webyog.com/，读者也可以搜索中文版的下载地址。<i class="fas fa-external-link-alt"></i></a></p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211014213018979.png"
                         alt="image-20211014213018979" style="zoom:80%;" 
                 >

<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211014213036470.png"
                         alt="image-20211014213036470" style="zoom:80%;" 
                 >

<h3 id="工具4：dbeaver"><a href="#工具4：dbeaver" class="headerlink" title="工具4：dbeaver"></a>工具4：dbeaver</h3><p>DBeaver是一个通用的数据库管理工具和 SQL 客户端，支持所有流行的数据库：MySQL、PostgreSQL、SQLite、Oracle、DB2、SQL Server、 Sybase、MS Access、Teradata、 Firebird、Apache Hive、Phoenix、Presto等。DBeaver比大多数的SQL管理工具要轻量，而且支持中文界面。DBeaver社区版作为一个免费开源的产品，和其他类似的软件相比，在功能和易用性上都毫不逊色。</p>
<p>唯一需要注意是 DBeaver 是用Java编程语言开发的，所以需要拥有 JDK（Java Development ToolKit）环境。如果电脑上没有JDK，在选择安装DBeaver组件时，勾选“Include Java”即可。</p>
<p>下载地址：<a class="link"   href="https://dbeaver.io/download/" >https://dbeaver.io/download/<i class="fas fa-external-link-alt"></i></a></p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211014195237457.png"
                         alt="image-20211014195237457" style="zoom:80%;" 
                 >

<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211014195251371.png"
                         alt="image-20211014195251371" style="zoom:75%;" 
                 >

<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211014195300510.png"
                         alt="image-20211014195300510" style="zoom:80%;" 
                 >

<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211014195309805.png"
                         alt="image-20211014195309805" style="zoom:70%;" 
                 >

<h3 id="可能出现连接问题："><a href="#可能出现连接问题：" class="headerlink" title="可能出现连接问题："></a>可能出现连接问题：</h3><p>有些图形界面工具，特别是旧版本的图形界面工具，在连接MySQL8时出现“Authentication plugin ‘caching_sha2_password’ cannot be loaded”错误。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211019215249254.png"
                         alt="image-20211019215249254" style="zoom:80%;" 
                 >

<p>出现这个原因是MySQL8之前的版本中加密规则是mysql_native_password，而在MySQL8之后，加密规则是caching_sha2_password。解决问题方法有两种，第一种是升级图形界面工具版本，第二种是把MySQL8用户登录密码加密规则还原成mysql_native_password。</p>
<p>第二种解决方案如下，用命令行登录MySQL数据库之后，执行如下命令修改用户密码加密规则并更新用户密码，这里修改用户名为“root@localhost”的用户密码规则为“mysql_native_password”，密码值为“123456”，如图所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用mysql数据库</span><br><span class="line">USE mysql; </span><br><span class="line"></span><br><span class="line">#修改&#x27;root&#x27;@&#x27;localhost&#x27;用户的密码规则和密码</span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;abc123&#x27;; </span><br><span class="line"></span><br><span class="line">#刷新权限</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211019215408965.png"
                         alt="image-20211019215408965" style="zoom:80%;" 
                 >



<h2 id="6-MySQL目录结构与源码"><a href="#6-MySQL目录结构与源码" class="headerlink" title="6. MySQL目录结构与源码"></a>6. MySQL目录结构与源码</h2><h3 id="6-1-主要目录结构"><a href="#6-1-主要目录结构" class="headerlink" title="6.1 主要目录结构"></a>6.1 主要目录结构</h3><table>
<thead>
<tr>
<th>MySQL的目录结构</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>bin目录</td>
<td>所有MySQL的可执行文件。如：mysql.exe</td>
</tr>
<tr>
<td>MySQLInstanceConfig.exe</td>
<td>数据库的配置向导，在安装时出现的内容</td>
</tr>
<tr>
<td>data目录</td>
<td>系统数据库所在的目录</td>
</tr>
<tr>
<td>my.ini文件</td>
<td>MySQL的主要配置文件</td>
</tr>
<tr>
<td>c:\ProgramData\MySQL\MySQL Server 8.0\data\</td>
<td>用户创建的数据库所在的目录</td>
</tr>
</tbody></table>
<h3 id="6-2-MySQL-源代码获取"><a href="#6-2-MySQL-源代码获取" class="headerlink" title="6.2 MySQL 源代码获取"></a>6.2 MySQL 源代码获取</h3><p>首先，你要进入 MySQL下载界面。 这里你不要选择用默认的“Microsoft Windows”，而是要通过下拉栏，找到“Source Code”，在下面的操作系统版本里面， 选择 Windows（Architecture Independent），然后点击下载。</p>
<p>接下来，把下载下来的压缩文件解压，我们就得到了 MySQL 的源代码。</p>
<p>MySQL 是用 C++ 开发而成的，我简单介绍一下源代码的组成。</p>
<p>mysql-8.0.22 目录下的各个子目录，包含了 MySQL 各部分组件的源代码：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211007154113052.png"
                        alt="image-20211007154113052"
                 ></p>
<ul>
<li><p>sql 子目录是 MySQL 核心代码；</p>
</li>
<li><p>libmysql 子目录是客户端程序 API；</p>
</li>
<li><p>mysql-test 子目录是测试工具；</p>
</li>
<li><p>mysys 子目录是操作系统相关函数和辅助函数；</p>
</li>
</ul>
<p>源代码可以用记事本打开查看，如果你有 C++ 的开发环境，也可以在开发环境中打开查看。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211007154213156.png"
                        alt="image-20211007154213156"
                 ></p>
<p>如上图所示，源代码并不神秘，就是普通的 C++ 代码，跟你熟悉的一样，而且有很多注释，可以帮助你理解。阅读源代码就像在跟 MySQL 的开发人员对话一样，十分有趣。</p>
<h2 id="7-常见问题的解决-课外内容"><a href="#7-常见问题的解决-课外内容" class="headerlink" title="7. 常见问题的解决(课外内容)"></a>7. 常见问题的解决(课外内容)</h2><h3 id="问题1：root用户密码忘记，重置的操作"><a href="#问题1：root用户密码忘记，重置的操作" class="headerlink" title="问题1：root用户密码忘记，重置的操作"></a>问题1：root用户密码忘记，重置的操作</h3><p>1: 通过任务管理器或者服务管理，关掉mysqld(服务进程)<br>2: 通过命令行+特殊参数开启mysqld<br>mysqld –defaults-file&#x3D;”D:\ProgramFiles\mysql\MySQLServer5.7Data\my.ini” –skip-grant-tables</p>
<p>3: 此时，mysqld服务进程已经打开。并且不需要权限检查<br>4: mysql -uroot 无密码登陆服务器。另启动一个客户端进行<br>5: 修改权限表<br>（1） use mysql;<br>（2）update user set authentication_string&#x3D;password(‘新密码’) where user&#x3D;’root’ and Host&#x3D;’localhost’;<br>（3）flush privileges;<br>6: 通过任务管理器，关掉mysqld服务进程。<br>7: 再次通过服务管理，打开mysql服务。<br>8: 即可用修改后的新密码登陆。</p>
<h3 id="问题2：mysql命令报“不是内部或外部命令”"><a href="#问题2：mysql命令报“不是内部或外部命令”" class="headerlink" title="问题2：mysql命令报“不是内部或外部命令”"></a>问题2：mysql命令报“不是内部或外部命令”</h3><p>如果输入mysql命令报“不是内部或外部命令”，把mysql安装目录的bin目录配置到环境变量path中。如下：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20210914093150145.png"
                        alt="image-20210914093150145"
                 ></p>
<h3 id="问题3：错误ERROR-：没有选择数据库就操作表格和数据"><a href="#问题3：错误ERROR-：没有选择数据库就操作表格和数据" class="headerlink" title="问题3：错误ERROR ：没有选择数据库就操作表格和数据"></a>问题3：错误ERROR ：没有选择数据库就操作表格和数据</h3><table>
<thead>
<tr>
<th>ERROR 1046 (3D000): No database selected</th>
</tr>
</thead>
<tbody><tr>
<td>解决方案一：就是使用“USE 数据库名;”语句，这样接下来的语句就默认针对这个数据库进行操作</td>
</tr>
<tr>
<td>解决方案二：就是所有的表对象前面都加上“数据库.”</td>
</tr>
</tbody></table>
<h3 id="问题4：命令行客户端的字符集问题"><a href="#问题4：命令行客户端的字符集问题" class="headerlink" title="问题4：命令行客户端的字符集问题"></a>问题4：命令行客户端的字符集问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; INSERT INTO t_stu VALUES(1,&#x27;张三&#x27;,&#x27;男&#x27;);</span><br><span class="line">ERROR 1366 (HY000): Incorrect string value: &#x27;\xD5\xC5\xC8\xFD&#x27; for column &#x27;sname&#x27; at row 1</span><br></pre></td></tr></table></figure>

<p>原因：服务器端认为你的客户端的字符集是utf-8，而实际上你的客户端的字符集是GBK。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554912924219.png"
                        alt="1554912924219"
                 ></p>
<p>查看所有字符集：<strong>SHOW VARIABLES LIKE ‘character_set_%’;</strong></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554912943186.png"
                        alt="1554912943186"
                 ></p>
<p>解决方案，设置当前连接的客户端字符集 <strong>“SET NAMES GBK;”</strong></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554912957353.png"
                        alt="1554912957353"
                 ></p>
<h3 id="问题5：修改数据库和表的字符编码"><a href="#问题5：修改数据库和表的字符编码" class="headerlink" title="问题5：修改数据库和表的字符编码"></a>问题5：修改数据库和表的字符编码</h3><p>修改编码：</p>
<p>（1)先停止服务，（2）修改my.ini文件（3）重新启动服务</p>
<p>说明：</p>
<p>如果是在修改my.ini之前建的库和表，那么库和表的编码还是原来的Latin1，要么删了重建，要么使用alter语句修改编码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create database 0728db charset Latin1;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; use 0728db;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table student (id int , name varchar(20)) charset Latin1;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; show create table student\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: student</span><br><span class="line">Create Table: CREATE TABLE `student` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `name` varchar(20) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=latin1</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table student charset utf8; #修改表字符编码为UTF8</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; show create table student\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: student</span><br><span class="line">Create Table: CREATE TABLE `student` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `name` varchar(20) CHARACTER SET latin1 DEFAULT NULL,  #字段仍然是latin1编码</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; alter table student modify name varchar(20) charset utf8; #修改字段字符编码为UTF8</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; show create table student\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: student</span><br><span class="line">Create Table: CREATE TABLE `student` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `name` varchar(20) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show create database 0728db;;</span><br><span class="line">+--------+-----------------------------------------------------------------+</span><br><span class="line">|Database| Create Database                                                 |</span><br><span class="line">+------+-------------------------------------------------------------------+</span><br><span class="line">|0728db| CREATE DATABASE `0728db` /*!40100 DEFAULT CHARACTER SET latin1 */ |</span><br><span class="line">+------+-------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; alter database 0728db charset utf8; #修改数据库的字符编码为utf8</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; show create database 0728db;</span><br><span class="line">+--------+-----------------------------------------------------------------+</span><br><span class="line">|Database| Create Database                                                 |</span><br><span class="line">+--------+-----------------------------------------------------------------+</span><br><span class="line">| 0728db | CREATE DATABASE `0728db` /*!40100 DEFAULT CHARACTER SET utf8 */ |</span><br><span class="line">+--------+-----------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="第03章-基本的SELECT语句"><a href="#第03章-基本的SELECT语句" class="headerlink" title="第03章_基本的SELECT语句"></a>第03章_基本的SELECT语句</h1><hr>
<h2 id="1-SQL概述"><a href="#1-SQL概述" class="headerlink" title="1. SQL概述"></a>1. SQL概述</h2><h3 id="1-1-SQL背景知识"><a href="#1-1-SQL背景知识" class="headerlink" title="1.1 SQL背景知识"></a>1.1 SQL背景知识</h3><ul>
<li><p>1946 年，世界上第一台电脑诞生，如今，借由这台电脑发展起来的互联网已经自成江湖。在这几十年里，无数的技术、产业在这片江湖里沉浮，有的方兴未艾，有的已经几幕兴衰。但在这片浩荡的波动里，有一门技术从未消失，甚至“老当益壮”，那就是 SQL。</p>
<ul>
<li>45 年前，也就是 1974 年，IBM 研究员发布了一篇揭开数据库技术的论文《SEQUEL：一门结构化的英语查询语言》，直到今天这门结构化的查询语言并没有太大的变化，相比于其他语言，<code>SQL 的半衰期可以说是非常长</code>了。</li>
</ul>
</li>
<li><p>不论是前端工程师，还是后端算法工程师，都一定会和数据打交道，都需要了解如何又快又准确地提取自己想要的数据。更别提数据分析师了，他们的工作就是和数据打交道，整理不同的报告，以便指导业务决策。</p>
</li>
<li><p>SQL（Structured Query Language，结构化查询语言）是使用关系模型的数据库应用语言，<code>与数据直接打交道</code>，由<code>IBM</code>上世纪70年代开发出来。后由美国国家标准局（ANSI）开始着手制定SQL标准，先后有<code>SQL-86</code>，<code>SQL-89</code>，<code>SQL-92</code>，<code>SQL-99</code>等标准。</p>
<ul>
<li>SQL 有两个重要的标准，分别是 SQL92 和 SQL99，它们分别代表了 92 年和 99 年颁布的 SQL 标准，我们今天使用的 SQL 语言依然遵循这些标准。</li>
</ul>
</li>
<li><p>不同的数据库生产厂商都支持SQL语句，但都有特有内容。</p>
</li>
</ul>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/SQLisputonghua.jpg"
                         alt="SQLisputonghua" style="zoom:67%;" 
                 >

<h3 id="1-2-SQL语言排行榜"><a href="#1-2-SQL语言排行榜" class="headerlink" title="1.2 SQL语言排行榜"></a>1.2 SQL语言排行榜</h3><p>自从 SQL 加入了 TIOBE 编程语言排行榜，就一直保持在 Top 10。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211014230114639.png"
                         alt="image-20211014230114639" style="zoom:80%;" 
                 >

<h3 id="1-3-SQL-分类"><a href="#1-3-SQL-分类" class="headerlink" title="1.3 SQL 分类"></a>1.3 SQL 分类</h3><p>SQL语言在功能上主要分为如下3大类：</p>
<ul>
<li><p><strong>DDL（Data Definition Languages、数据定义语言）</strong>，这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。</p>
<ul>
<li>主要的语句关键字包括<code>CREATE</code>、<code>DROP</code>、<code>ALTER</code>等。</li>
</ul>
</li>
<li><p><strong>DML（Data Manipulation Language、数据操作语言）</strong>，用于添加、删除、更新和查询数据库记录，并检查数据完整性。</p>
<ul>
<li>主要的语句关键字包括<code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code>、<code>SELECT</code>等。</li>
<li><strong>SELECT是SQL语言的基础，最为重要。</strong></li>
</ul>
</li>
<li><p><strong>DCL（Data Control Language、数据控制语言）</strong>，用于定义数据库、表、字段、用户的访问权限和安全级别。</p>
<ul>
<li>主要的语句关键字包括<code>GRANT</code>、<code>REVOKE</code>、<code>COMMIT</code>、<code>ROLLBACK</code>、<code>SAVEPOINT</code>等。</li>
</ul>
</li>
</ul>
<blockquote>
<p>因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类：DQL（数据查询语言）。</p>
<p>还有单独将<code>COMMIT</code>、<code>ROLLBACK</code> 取出来称为TCL （Transaction Control Language，事务控制语言）。</p>
</blockquote>
<h2 id="2-SQL语言的规则与规范"><a href="#2-SQL语言的规则与规范" class="headerlink" title="2. SQL语言的规则与规范"></a>2. SQL语言的规则与规范</h2><h3 id="2-1-基本规则"><a href="#2-1-基本规则" class="headerlink" title="2.1 基本规则"></a>2.1 基本规则</h3><ul>
<li>SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进</li>
<li>每条命令以 ; 或 \g 或 \G 结束</li>
<li>关键字不能被缩写也不能分行</li>
<li>关于标点符号<ul>
<li>必须保证所有的()、单引号、双引号是成对结束的</li>
<li>必须使用英文状态下的半角输入方式</li>
<li>字符串型和日期时间类型的数据可以使用单引号（’ ‘）表示</li>
<li>列的别名，尽量使用双引号（” “），而且不建议省略as</li>
</ul>
</li>
</ul>
<h3 id="2-2-SQL大小写规范-（建议遵守）"><a href="#2-2-SQL大小写规范-（建议遵守）" class="headerlink" title="2.2 SQL大小写规范 （建议遵守）"></a>2.2 SQL大小写规范 （建议遵守）</h3><ul>
<li><strong>MySQL 在 Windows 环境下是大小写不敏感的</strong></li>
<li><strong>MySQL 在 Linux 环境下是大小写敏感的</strong><ul>
<li>数据库名、表名、表的别名、变量名是严格区分大小写的</li>
<li>关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。</li>
</ul>
</li>
<li><strong>推荐采用统一的书写规范：</strong><ul>
<li>数据库名、表名、表别名、字段名、字段别名等都小写</li>
<li>SQL 关键字、函数名、绑定变量等都大写</li>
</ul>
</li>
</ul>
<h3 id="2-3-注-释"><a href="#2-3-注-释" class="headerlink" title="2.3 注 释"></a>2.3 注 释</h3><p>可以使用如下格式的注释结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单行注释：#注释文字(MySQL特有的方式)</span><br><span class="line">单行注释：-- 注释文字(--后面必须包含一个空格。)</span><br><span class="line">多行注释：/* 注释文字  */</span><br></pre></td></tr></table></figure>

<h3 id="2-4-命名规则（暂时了解）"><a href="#2-4-命名规则（暂时了解）" class="headerlink" title="2.4 命名规则（暂时了解）"></a>2.4 命名规则（暂时了解）</h3><ul>
<li>数据库、表名不得超过30个字符，变量名限制为29个</li>
<li>必须只能包含 A–Z, a–z, 0–9, _共63个字符</li>
<li>数据库名、表名、字段名等对象名中间不要包含空格</li>
<li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li>
<li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用&#96;（着重号）引起来</li>
<li>保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了</li>
</ul>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#以下两句是一样的，不区分大小写</span><br><span class="line">show databases;</span><br><span class="line">SHOW DATABASES;</span><br><span class="line"></span><br><span class="line">#创建表格</span><br><span class="line">#create table student info(...); #表名错误，因为表名有空格</span><br><span class="line">create table student_info(...); </span><br><span class="line"></span><br><span class="line">#其中order使用``飘号，因为order和系统关键字或系统函数名等预定义标识符重名了</span><br><span class="line">CREATE TABLE `order`(</span><br><span class="line">    id INT,</span><br><span class="line">    lname VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">select id as &quot;编号&quot;, `name` as &quot;姓名&quot; from t_stu; #起别名时，as都可以省略</span><br><span class="line">select id as 编号, `name` as 姓名 from t_stu; #如果字段别名中没有空格，那么可以省略&quot;&quot;</span><br><span class="line">select id as 编 号, `name` as 姓 名 from t_stu; #错误，如果字段别名中有空格，那么不能省略&quot;&quot;</span><br></pre></td></tr></table></figure>



<h3 id="2-5-数据导入指令"><a href="#2-5-数据导入指令" class="headerlink" title="2.5 数据导入指令"></a>2.5 数据导入指令</h3><p>在命令行客户端登录mysql，使用source指令导入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; source d:\mysqldb.sql</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc employees;</span><br><span class="line">+----------------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field          | Type        | Null | Key | Default | Extra |</span><br><span class="line">+----------------+-------------+------+-----+---------+-------+</span><br><span class="line">| employee_id    | int(6)      | NO   | PRI | 0       |       |</span><br><span class="line">| first_name     | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| last_name      | varchar(25) | NO   |     | NULL    |       |</span><br><span class="line">| email          | varchar(25) | NO   | UNI | NULL    |       |</span><br><span class="line">| phone_number   | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| hire_date      | date        | NO   |     | NULL    |       |</span><br><span class="line">| job_id         | varchar(10) | NO   | MUL | NULL    |       |</span><br><span class="line">| salary         | double(8,2) | YES  |     | NULL    |       |</span><br><span class="line">| commission_pct | double(2,2) | YES  |     | NULL    |       |</span><br><span class="line">| manager_id     | int(6)      | YES  | MUL | NULL    |       |</span><br><span class="line">| department_id  | int(4)      | YES  | MUL | NULL    |       |</span><br><span class="line">+----------------+-------------+------+-----+---------+-------+</span><br><span class="line">11 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="3-基本的SELECT语句"><a href="#3-基本的SELECT语句" class="headerlink" title="3. 基本的SELECT语句"></a>3. 基本的SELECT语句</h2><h3 id="3-0-SELECT…"><a href="#3-0-SELECT…" class="headerlink" title="3.0 SELECT…"></a>3.0 SELECT…</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 1; #没有任何子句</span><br><span class="line">SELECT 9/2; #没有任何子句</span><br></pre></td></tr></table></figure>

<h3 id="3-1-SELECT-…-FROM"><a href="#3-1-SELECT-…-FROM" class="headerlink" title="3.1 SELECT … FROM"></a>3.1 SELECT … FROM</h3><ul>
<li>语法：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>   标识选择哪些列</span><br><span class="line"><span class="keyword">FROM</span>     标识从哪个表中选择</span><br></pre></td></tr></table></figure>

<ul>
<li>选择全部列：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>   departments;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554950890895.png"
                        alt="1554950890895"
                 ></p>
<blockquote>
<p>一般情况下，除非需要使用表中所有的字段数据，最好不要使用通配符‘*’。使用通配符虽然可以节省输入查询语句的时间，但是获取不需要的列数据通常会降低查询和所使用的应用程序的效率。通配符的优势是，当不知道所需要的列的名称时，可以通过它获取它们。</p>
<p>在生产环境下，不推荐你直接使用<code>SELECT *</code>进行查询。</p>
</blockquote>
<ul>
<li>选择特定的列：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id, location_id</span><br><span class="line"><span class="keyword">FROM</span>   departments;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554950947969.png"
                        alt="1554950947969"
                 ></p>
<blockquote>
<p>MySQL中的SQL语句是不区分大小写的，因此SELECT和select的作用是相同的，但是，许多开发人员习惯将关键字大写、数据列和表名小写，读者也应该养成一个良好的编程习惯，这样写出来的代码更容易阅读和维护。</p>
</blockquote>
<h3 id="3-2-列的别名"><a href="#3-2-列的别名" class="headerlink" title="3.2 列的别名"></a>3.2 列的别名</h3><ul>
<li><p>重命名一个列</p>
</li>
<li><p>便于计算</p>
</li>
<li><p>紧跟列名，也可以<strong>在列名和别名之间加入关键字AS，别名使用双引号</strong>，以便在别名中包含空格或特殊的字符并区分大小写。</p>
</li>
<li><p>AS 可以省略</p>
</li>
<li><p>建议别名简短，见名知意</p>
</li>
<li><p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last_name AS name, commission_pct comm</span><br><span class="line">FROM   employees;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554951616598.png"
                        alt="1554951616598"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554951622467.png"
                        alt="1554951622467"
                 ></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last_name &quot;Name&quot;, salary*12 &quot;Annual Salary&quot;</span><br><span class="line">FROM   employees;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554951648377.png"
                        alt="1554951648377"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554951655368.png"
                        alt="1554951655368"
                 ></p>
<h3 id="3-3-去除重复行"><a href="#3-3-去除重复行" class="headerlink" title="3.3 去除重复行"></a>3.3 去除重复行</h3><p>默认情况下，查询会返回全部行，包括重复行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span>   employees;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554951711115.png"
                        alt="1554951711115"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554951715923.png"
                        alt="1554951715923"
                 ></p>
<p><strong>在SELECT语句中使用关键字DISTINCT去除重复行</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id</span><br><span class="line"><span class="keyword">FROM</span>   employees;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554951796570.png"
                        alt="1554951796570"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554951801044.png"
                        alt="1554951801044"
                 ></p>
<p>针对于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT department_id,salary </span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>

<p>这里有两点需要注意：</p>
<ol>
<li>DISTINCT 需要放到所有列名的前面，如果写成<code>SELECT salary, DISTINCT department_id FROM employees</code>会报错。</li>
<li>DISTINCT 其实是对后面所有列名的组合进行去重，你能看到最后的结果是 74 条，因为这 74 个部门id不同，都有 salary 这个属性值。如果你想要看都有哪些不同的部门（department_id），只需要写<code>DISTINCT department_id</code>即可，后面不需要再加其他的列名了。</li>
</ol>
<h3 id="3-4-空值参与运算"><a href="#3-4-空值参与运算" class="headerlink" title="3.4 空值参与运算"></a>3.4 空值参与运算</h3><ul>
<li>所有运算符或列值遇到null值，运算的结果都为null</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,salary,commission_pct,</span><br><span class="line"><span class="number">12</span> <span class="operator">*</span> salary <span class="operator">*</span> (<span class="number">1</span> <span class="operator">+</span> commission_pct) &quot;annual_sal&quot;</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<p>这里你一定要注意，在 MySQL 里面， 空值不等于空字符串。一个空字符串的长度是 0，而一个空值的长度是空。而且，在 MySQL 里面，空值是占用空间的。</p>
<h3 id="3-5-着重号"><a href="#3-5-着重号" class="headerlink" title="3.5 着重号"></a>3.5 着重号</h3><ul>
<li>错误的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM ORDER;</span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;ORDER&#x27; at line 1</span><br></pre></td></tr></table></figure>

<ul>
<li>正确的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM `ORDER`;</span><br><span class="line">+----------+------------+</span><br><span class="line">| order_id | order_name |</span><br><span class="line">+----------+------------+</span><br><span class="line">|        1 | shkstart   |</span><br><span class="line">|        2 | tomcat     |</span><br><span class="line">|        3 | dubbo      |</span><br><span class="line">+----------+------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM `order`;</span><br><span class="line">+----------+------------+</span><br><span class="line">| order_id | order_name |</span><br><span class="line">+----------+------------+</span><br><span class="line">|        1 | shkstart   |</span><br><span class="line">|        2 | tomcat     |</span><br><span class="line">|        3 | dubbo      |</span><br><span class="line">+----------+------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>结论</li>
</ul>
<p>我们需要保证表中的字段、表名等没有和保留字、数据库系统或常用方法冲突。如果真的相同，请在SQL语句中使用一对&#96;&#96;（着重号）引起来。</p>
<h3 id="3-6-5、查询常数"><a href="#3-6-5、查询常数" class="headerlink" title="3.6 5、查询常数"></a>3.6 5、查询常数</h3><p>SELECT 查询还可以对常数进行查询。对的，就是在 SELECT 查询结果中增加一列固定的常数列。这列的取值是我们指定的，而不是从数据表中动态取出的。</p>
<p>你可能会问为什么我们还要对常数进行查询呢？</p>
<p>SQL 中的 SELECT 语法的确提供了这个功能，一般来说我们只从一个表中查询数据，通常不需要增加一个固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。</p>
<p>比如说，我们想对 employees 数据表中的员工姓名进行查询，同时增加一列字段<code>corporation</code>，这个字段固定值为“尚硅谷”，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT &#x27;尚硅谷&#x27; as corporation, last_name FROM employees;</span><br></pre></td></tr></table></figure>



<h2 id="4-显示表结构"><a href="#4-显示表结构" class="headerlink" title="4. 显示表结构"></a>4. 显示表结构</h2><p>使用DESCRIBE 或 DESC 命令，表示表结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESCRIBE employees;</span><br><span class="line">或</span><br><span class="line">DESC employees;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc employees;</span><br><span class="line">+----------------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field          | Type        | Null | Key | Default | Extra |</span><br><span class="line">+----------------+-------------+------+-----+---------+-------+</span><br><span class="line">| employee_id    | int(6)      | NO   | PRI | 0       |       |</span><br><span class="line">| first_name     | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| last_name      | varchar(25) | NO   |     | NULL    |       |</span><br><span class="line">| email          | varchar(25) | NO   | UNI | NULL    |       |</span><br><span class="line">| phone_number   | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| hire_date      | date        | NO   |     | NULL    |       |</span><br><span class="line">| job_id         | varchar(10) | NO   | MUL | NULL    |       |</span><br><span class="line">| salary         | double(8,2) | YES  |     | NULL    |       |</span><br><span class="line">| commission_pct | double(2,2) | YES  |     | NULL    |       |</span><br><span class="line">| manager_id     | int(6)      | YES  | MUL | NULL    |       |</span><br><span class="line">| department_id  | int(4)      | YES  | MUL | NULL    |       |</span><br><span class="line">+----------------+-------------+------+-----+---------+-------+</span><br><span class="line">11 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>其中，各个字段的含义分别解释如下：</p>
<ul>
<li>Field：表示字段名称。</li>
<li>Type：表示字段类型，这里 barcode、goodsname 是文本型的，price 是整数类型的。</li>
<li>Null：表示该列是否可以存储NULL值。</li>
<li>Key：表示该列是否已编制索引。PRI表示该列是表主键的一部分；UNI表示该列是UNIQUE索引的一部分；MUL表示在列中某个给定值允许出现多次。</li>
<li>Default：表示该列是否有默认值，如果有，那么值是多少。</li>
<li>Extra：表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等。</li>
</ul>
<h2 id="5-过滤数据"><a href="#5-过滤数据" class="headerlink" title="5. 过滤数据"></a>5. 过滤数据</h2><ul>
<li>背景：</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554952199742.png"
                        alt="1554952199742"
                 ></p>
<ul>
<li><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段1,字段2</span><br><span class="line">FROM 表名</span><br><span class="line">WHERE 过滤条件</span><br></pre></td></tr></table></figure>

<ul>
<li>使用WHERE 子句，将不满足条件的行过滤掉</li>
<li><strong>WHERE子句紧随 FROM子句</strong></li>
</ul>
</li>
<li><p>举例</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, job_id, department_id</span><br><span class="line"><span class="keyword">FROM</span>   employees</span><br><span class="line"><span class="keyword">WHERE</span>  department_id <span class="operator">=</span> <span class="number">90</span> ;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554952277028.png"
                        alt="1554952277028"
                 ></p>
<hr>
<h1 id="第04章-运算符"><a href="#第04章-运算符" class="headerlink" title="第04章_运算符"></a>第04章_运算符</h1><hr>
<h2 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h2><p>算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行加（+）、减（-）、乘（*）、除（&#x2F;）和取模（%）运算。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211012100749193.png"
                        alt="image-20211012100749193"
                 ></p>
<p><strong>1．加法与减法运算符</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 100, 100 + 0, 100 - 0, 100 + 50, 100 + 50 -30, 100 + 35.5, 100 - 35.5 FROM dual;</span><br><span class="line">+-----+---------+---------+----------+--------------+------------+------------+</span><br><span class="line">| 100 | 100 + 0 | 100 - 0 | 100 + 50 | 100 + 50 -30 | 100 + 35.5 | 100 - 35.5 |</span><br><span class="line">+-----+---------+---------+----------+--------------+------------+------------+</span><br><span class="line">| 100 |     100 |     100 |      150 |          120 |      135.5 |       64.5 |</span><br><span class="line">+-----+---------+---------+----------+--------------+------------+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>由运算结果可以得出如下结论：</p>
<blockquote>
<ul>
<li>一个整数类型的值对整数进行加法和减法操作，结果还是一个整数；</li>
<li>一个整数类型的值对浮点数进行加法和减法操作，结果是一个浮点数；</li>
<li>加法和减法的优先级相同，进行先加后减操作与进行先减后加操作的结果是一样的；</li>
<li>在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（补充：MySQL中字符串拼接要使用字符串函数CONCAT()实现）</li>
</ul>
</blockquote>
<p><strong>2．乘法与除法运算符</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 100, 100 * 1, 100 * 1.0, 100 / 1.0, 100 / 2,100 + 2 * 5 / 2,100 /3, 100 DIV 0 FROM dual;</span><br><span class="line">+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+</span><br><span class="line">| 100 | 100 * 1 | 100 * 1.0 | 100 / 1.0 | 100 / 2 | 100 + 2 * 5 / 2 | 100 /3  | 100 DIV 0 |</span><br><span class="line">+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+</span><br><span class="line">| 100 |     100 |     100.0 |  100.0000 | 50.0000 |        105.0000 | 33.3333 |      NULL |</span><br><span class="line">+-----+---------+-----------+-----------+---------+-----------------+---------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#计算出员工的年基本工资</span><br><span class="line">SELECT employee_id,salary,salary * 12 annual_sal </span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>

<p>由运算结果可以得出如下结论：</p>
<blockquote>
<ul>
<li>一个数乘以整数1和除以整数1后仍得原数；</li>
<li>一个数乘以浮点数1和除以浮点数1后变成浮点数，数值与原数相等；</li>
<li>一个数除以整数后，不管是否能除尽，结果都为一个浮点数；</li>
<li>一个数除以另一个数，除不尽时，结果为一个浮点数，并保留到小数点后4位；</li>
<li>乘法和除法的优先级相同，进行先乘后除操作与先除后乘操作，得出的结果相同。</li>
<li>在数学运算中，0不能用作除数，在MySQL中，一个数除以0为NULL。</li>
</ul>
</blockquote>
<p><strong>3．求模（求余）运算符</strong><br>将t22表中的字段i对3和5进行求模（求余）运算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 12 % 3, 12 MOD 5 FROM dual;</span><br><span class="line">+--------+----------+</span><br><span class="line">| 12 % 3 | 12 MOD 5 |</span><br><span class="line">+--------+----------+</span><br><span class="line">|      0 |        2 |</span><br><span class="line">+--------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#筛选出employee_id是偶数的员工</span><br><span class="line">SELECT * FROM employees</span><br><span class="line">WHERE employee_id MOD 2 = 0;</span><br></pre></td></tr></table></figure>

<p>可以看到，100对3求模后的结果为3，对5求模后的结果为0。</p>
<h2 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2. 比较运算符"></a>2. 比较运算符</h2><p>比较运算符用来对表达式左边的操作数和右边的操作数进行比较，比较的结果为真则返回1，比较的结果为假则返回0，其他情况则返回NULL。</p>
<p>比较运算符经常被用来作为SELECT查询语句的条件来使用，返回符合条件的结果记录。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211012101110021.png"
                         alt="image-20211012101110021" 
                 >

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211012104955094.png"
                        alt="image-20211012104955094"
                 ></p>
<p><strong>1．等号运算符</strong></p>
<ul>
<li><p>等号运算符（&#x3D;）判断等号两边的值、字符串或表达式是否相等，如果相等则返回1，不相等则返回0。</p>
</li>
<li><p>在使用等号运算符时，遵循如下规则：</p>
<ul>
<li>如果等号两边的值、字符串或表达式都为字符串，则MySQL会按照字符串进行比较，其比较的是每个字符串中字符的ANSI编码是否相等。</li>
<li>如果等号两边的值都是整数，则MySQL会按照整数来比较两个值的大小。</li>
<li>如果等号两边的值一个是整数，另一个是字符串，则MySQL会将字符串转化为数字进行比较。</li>
<li>如果等号两边的值、字符串或表达式中有一个为NULL，则比较结果为NULL。</li>
</ul>
</li>
<li><p>对比：SQL中赋值符号使用 :&#x3D;</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 = 1, 1 = &#x27;1&#x27;, 1 = 0, &#x27;a&#x27; = &#x27;a&#x27;, (5 + 3) = (2 + 6), &#x27;&#x27; = NULL , NULL = NULL; </span><br><span class="line">+-------+---------+-------+-----------+-------------------+-----------+-------------+</span><br><span class="line">| 1 = 1 | 1 = &#x27;1&#x27; | 1 = 0 | &#x27;a&#x27; = &#x27;a&#x27; | (5 + 3) = (2 + 6) | &#x27;&#x27; = NULL | NULL = NULL |</span><br><span class="line">+-------+---------+-------+-----------+-------------------+-----------+-------------+</span><br><span class="line">|    1  |     1   |   0   |      1    |             1     |    NULL   |        NULL  |</span><br><span class="line">+-------+---------+-------+-----------+-------------------+-----------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 = 2, 0 = &#x27;abc&#x27;, 1 = &#x27;abc&#x27; FROM dual;</span><br><span class="line">+-------+-----------+-----------+</span><br><span class="line">| 1 = 2 | 0 = &#x27;abc&#x27; | 1 = &#x27;abc&#x27; |</span><br><span class="line">+-------+-----------+-----------+</span><br><span class="line">|     0 |         1 |         0 |</span><br><span class="line">+-------+-----------+-----------+</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询salary=10000，注意在Java中比较是==</span><br><span class="line">SELECT employee_id,salary FROM employees WHERE salary = 10000;</span><br></pre></td></tr></table></figure>

<p><strong>2．安全等于运算符</strong><br>安全等于运算符（&lt;&#x3D;&gt;）与等于运算符（&#x3D;）的作用是相似的，<code>唯一的区别</code>是‘&lt;&#x3D;&gt;’可以用来对NULL进行判断。在两个操作数均为NULL时，其返回值为1，而不为NULL；当一个操作数为NULL时，其返回值为0，而不为NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 &lt;=&gt; &#x27;1&#x27;, 1 &lt;=&gt; 0, &#x27;a&#x27; &lt;=&gt; &#x27;a&#x27;, (5 + 3) &lt;=&gt; (2 + 6), &#x27;&#x27; &lt;=&gt; NULL,NULL &lt;=&gt; NULL FROM dual;</span><br><span class="line">+-----------+---------+-------------+---------------------+-------------+---------------+</span><br><span class="line">| 1 &lt;=&gt; &#x27;1&#x27; | 1 &lt;=&gt; 0 | &#x27;a&#x27; &lt;=&gt; &#x27;a&#x27; | (5 + 3) &lt;=&gt; (2 + 6) | &#x27;&#x27; &lt;=&gt; NULL | NULL &lt;=&gt; NULL |</span><br><span class="line">+-----------+---------+-------------+---------------------+-------------+---------------+</span><br><span class="line">|         1 |       0 |           1 |                   1 |           0 |             1 |</span><br><span class="line">+-----------+---------+-------------+---------------------+-------------+---------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询commission_pct等于0.40</span><br><span class="line">SELECT employee_id,commission_pct FROM employees WHERE commission_pct = 0.40;</span><br><span class="line"></span><br><span class="line">SELECT employee_id,commission_pct FROM employees WHERE commission_pct &lt;=&gt; 0.40;</span><br><span class="line"></span><br><span class="line">#如果把0.40改成 NULL 呢？</span><br></pre></td></tr></table></figure>

<p>可以看到，使用安全等于运算符时，两边的操作数的值都为NULL时，返回的结果为1而不是NULL，其他返回结果与等于运算符相同。</p>
<p><strong>3．不等于运算符</strong><br>不等于运算符（&lt;&gt;和!&#x3D;）用于判断两边的数字、字符串或者表达式的值是否不相等，如果不相等则返回1，相等则返回0。不等于运算符不能判断NULL值。如果两边的值有任意一个为NULL，或两边都为NULL，则结果为NULL。<br>SQL语句示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 &lt;&gt; 1, 1 != 2, &#x27;a&#x27; != &#x27;b&#x27;, (3+4) &lt;&gt; (2+6), &#x27;a&#x27; != NULL, NULL &lt;&gt; NULL; </span><br><span class="line">+--------+--------+------------+----------------+-------------+--------------+</span><br><span class="line">| 1 &lt;&gt; 1 | 1 != 2 | &#x27;a&#x27; != &#x27;b&#x27; | (3+4) &lt;&gt; (2+6) | &#x27;a&#x27; != NULL | NULL &lt;&gt; NULL |</span><br><span class="line">+--------+--------+------------+----------------+-------------+--------------+</span><br><span class="line">|      0 |   1    |       1    |            1   |     NULL    |         NULL |</span><br><span class="line">+--------+--------+------------+----------------+-------------+--------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>此外，还有非符号类型的运算符：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211012105303219.png"
                        alt="image-20211012105303219"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211012105030527.png"
                        alt="image-20211012105030527"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211012105052456.png"
                        alt="image-20211012105052456"
                 ></p>
<p><strong>4. 空运算符</strong><br>空运算符（IS NULL或者ISNULL）判断一个值是否为NULL，如果为NULL则返回1，否则返回0。<br>SQL语句示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT NULL IS NULL, ISNULL(NULL), ISNULL(&#x27;a&#x27;), 1 IS NULL;</span><br><span class="line">+--------------+--------------+-------------+-----------+</span><br><span class="line">| NULL IS NULL | ISNULL(NULL) | ISNULL(&#x27;a&#x27;) | 1 IS NULL |</span><br><span class="line">+--------------+--------------+-------------+-----------+</span><br><span class="line">|            1 |            1 |           0 |         0 |</span><br><span class="line">+--------------+--------------+-------------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询commission_pct等于NULL。比较如下的四种写法</span><br><span class="line">SELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NULL;</span><br><span class="line">SELECT employee_id,commission_pct FROM employees WHERE commission_pct &lt;=&gt; NULL;</span><br><span class="line">SELECT employee_id,commission_pct FROM employees WHERE ISNULL(commission_pct);</span><br><span class="line">SELECT employee_id,commission_pct FROM employees WHERE commission_pct = NULL;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last_name, manager_id</span><br><span class="line">FROM   employees</span><br><span class="line">WHERE  manager_id IS NULL;</span><br></pre></td></tr></table></figure>

<p><strong>5. 非空运算符</strong><br>非空运算符（IS NOT NULL）判断一个值是否不为NULL，如果不为NULL则返回1，否则返回0。<br>SQL语句示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT NULL IS NOT NULL, &#x27;a&#x27; IS NOT NULL,  1 IS NOT NULL; </span><br><span class="line">+------------------+-----------------+---------------+</span><br><span class="line">| NULL IS NOT NULL | &#x27;a&#x27; IS NOT NULL | 1 IS NOT NULL |</span><br><span class="line">+------------------+-----------------+---------------+</span><br><span class="line">|                0 |               1 |             1 |</span><br><span class="line">+------------------+-----------------+---------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询commission_pct不等于NULL</span><br><span class="line">SELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NOT NULL;</span><br><span class="line">SELECT employee_id,commission_pct FROM employees WHERE NOT commission_pct &lt;=&gt; NULL;</span><br><span class="line">SELECT employee_id,commission_pct FROM employees WHERE NOT ISNULL(commission_pct);</span><br></pre></td></tr></table></figure>

<p><strong>6. 最小值运算符</strong><br>语法格式为：LEAST(值1，值2，…，值n)。其中，“值n”表示参数列表中有n个值。在有两个或多个参数的情况下，返回最小值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT LEAST (1,0,2), LEAST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;), LEAST(1,NULL,2);</span><br><span class="line">+---------------+--------------------+-----------------+</span><br><span class="line">| LEAST (1,0,2) | LEAST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;) | LEAST(1,NULL,2) |</span><br><span class="line">+---------------+--------------------+-----------------+</span><br><span class="line">|       0       |        a           |      NULL       |</span><br><span class="line">+---------------+--------------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>由结果可以看到，当参数是整数或者浮点数时，LEAST将返回其中最小的值；当参数为字符串时，返回字母表中顺序最靠前的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p>
<p><strong>7. 最大值运算符</strong><br>语法格式为：GREATEST(值1，值2，…，值n)。其中，n表示参数列表中有n个值。当有两个或多个参数时，返回值为最大值。假如任意一个自变量为NULL，则GREATEST()的返回值为NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT GREATEST(1,0,2), GREATEST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;), GREATEST(1,NULL,2);</span><br><span class="line">+-----------------+-----------------------+--------------------+</span><br><span class="line">| GREATEST(1,0,2) | GREATEST(&#x27;b&#x27;,&#x27;a&#x27;,&#x27;c&#x27;) | GREATEST(1,NULL,2) |</span><br><span class="line">+-----------------+-----------------------+--------------------+</span><br><span class="line">|               2 | c                     |               NULL |</span><br><span class="line">+-----------------+-----------------------+--------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>由结果可以看到，当参数中是整数或者浮点数时，GREATEST将返回其中最大的值；当参数为字符串时，返回字母表中顺序最靠后的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。</p>
<p><strong>8. BETWEEN AND运算符</strong><br>BETWEEN运算符使用的格式通常为SELECT D FROM TABLE WHERE C BETWEEN A AND B，此时，当C大于或等于A，并且C小于或等于B时，结果为1，否则结果为0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 BETWEEN 0 AND 1, 10 BETWEEN 11 AND 12, &#x27;b&#x27; BETWEEN &#x27;a&#x27; AND &#x27;c&#x27;;</span><br><span class="line">+-------------------+----------------------+-------------------------+</span><br><span class="line">| 1 BETWEEN 0 AND 1 | 10 BETWEEN 11 AND 12 | &#x27;b&#x27; BETWEEN &#x27;a&#x27; AND &#x27;c&#x27; |</span><br><span class="line">+-------------------+----------------------+-------------------------+</span><br><span class="line">|                 1 |                    0 |                       1 |</span><br><span class="line">+-------------------+----------------------+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last_name, salary</span><br><span class="line">FROM   employees</span><br><span class="line">WHERE  salary BETWEEN 2500 AND 3500;</span><br></pre></td></tr></table></figure>

<p><strong>9. IN运算符</strong><br>IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回1，否则返回0。如果给定的值为NULL，或者IN列表中存在NULL，则结果为NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &#x27;a&#x27; IN (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;), 1 IN (2,3), NULL IN (&#x27;a&#x27;,&#x27;b&#x27;), &#x27;a&#x27; IN (&#x27;a&#x27;, NULL);</span><br><span class="line">+----------------------+------------+-------------------+--------------------+</span><br><span class="line">| &#x27;a&#x27; IN (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;) | 1 IN (2,3) | NULL IN (&#x27;a&#x27;,&#x27;b&#x27;) | &#x27;a&#x27; IN (&#x27;a&#x27;, NULL) |</span><br><span class="line">+----------------------+------------+-------------------+--------------------+</span><br><span class="line">|            1         |        0   |         NULL      |         1          |</span><br><span class="line">+----------------------+------------+-------------------+--------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id, last_name, salary, manager_id</span><br><span class="line">FROM   employees</span><br><span class="line">WHERE  manager_id IN (100, 101, 201);</span><br></pre></td></tr></table></figure>

<p><strong>10. NOT IN运算符</strong><br>NOT IN运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一个值，则返回1，否则返回0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &#x27;a&#x27; NOT IN (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;), 1 NOT IN (2,3);</span><br><span class="line">+--------------------------+----------------+</span><br><span class="line">| &#x27;a&#x27; NOT IN (&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;) | 1 NOT IN (2,3) |</span><br><span class="line">+--------------------------+----------------+</span><br><span class="line">|                 0        |            1   |</span><br><span class="line">+--------------------------+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>11. LIKE运算符</strong><br>LIKE运算符主要用来匹配字符串，通常用于模糊匹配，如果满足条件则返回1，否则返回0。如果给定的值或者匹配条件为NULL，则返回结果为NULL。</p>
<p>LIKE运算符通常使用如下通配符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">“%”：匹配0个或多个字符。</span><br><span class="line">“_”：只能匹配一个字符。</span><br></pre></td></tr></table></figure>

<p>SQL语句示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT NULL LIKE &#x27;abc&#x27;, &#x27;abc&#x27; LIKE NULL;  </span><br><span class="line">+-----------------+-----------------+</span><br><span class="line">| NULL LIKE &#x27;abc&#x27; | &#x27;abc&#x27; LIKE NULL |</span><br><span class="line">+-----------------+-----------------+</span><br><span class="line">|          NULL   |          NULL   |</span><br><span class="line">+-----------------+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT	first_name</span><br><span class="line">FROM 	employees</span><br><span class="line">WHERE	first_name LIKE &#x27;S%&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last_name</span><br><span class="line">FROM   employees</span><br><span class="line">WHERE  last_name LIKE &#x27;_o%&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>ESCAPE</strong></p>
<ul>
<li>回避特殊符号的：<strong>使用转义符</strong>。例如：将[%]转为[$%]、[]转为[$]，然后再加上[ESCAPE‘$’]即可。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT job_id</span><br><span class="line">FROM   jobs</span><br><span class="line">WHERE  job_id LIKE ‘IT\_%‘;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果使用\表示转义，要省略ESCAPE。如果不是\，则要加上ESCAPE。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT job_id</span><br><span class="line">FROM   jobs</span><br><span class="line">WHERE  job_id LIKE ‘IT$_%‘ escape ‘$‘;</span><br></pre></td></tr></table></figure>

<p><strong>12. REGEXP运算符</strong></p>
<p>REGEXP运算符用来匹配字符串，语法格式为：<code>expr REGEXP 匹配条件</code>。如果expr满足匹配条件，返回1；如果不满足，则返回0。若expr或匹配条件任意一个为NULL，则结果为NULL。</p>
<p>REGEXP运算符在进行匹配时，常用的有下面几种通配符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（1）‘^’匹配以该字符后面的字符开头的字符串。</span><br><span class="line">（2）‘$’匹配以该字符前面的字符结尾的字符串。</span><br><span class="line">（3）‘.’匹配任何一个单字符。</span><br><span class="line">（4）“[...]”匹配在方括号内的任何字符。例如，“[abc]”匹配“a”或“b”或“c”。为了命名字符的范围，使用一个‘-’。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。</span><br><span class="line">（5）‘*’匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的‘x’字符，“[0-9]*”匹配任何数量的数字，而“*”匹配任何数量的任何字符。</span><br></pre></td></tr></table></figure>

<p>SQL语句示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &#x27;shkstart&#x27; REGEXP &#x27;^s&#x27;, &#x27;shkstart&#x27; REGEXP &#x27;t$&#x27;, &#x27;shkstart&#x27; REGEXP &#x27;hk&#x27;;</span><br><span class="line">+------------------------+------------------------+-------------------------+</span><br><span class="line">| &#x27;shkstart&#x27; REGEXP &#x27;^s&#x27; | &#x27;shkstart&#x27; REGEXP &#x27;t$&#x27; | &#x27;shkstart&#x27; REGEXP &#x27;hk&#x27;  |</span><br><span class="line">+------------------------+------------------------+-------------------------+</span><br><span class="line">|                      1 |                      1 |                       1 |</span><br><span class="line">+------------------------+------------------------+-------------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT &#x27;atguigu&#x27; REGEXP &#x27;gu.gu&#x27;, &#x27;atguigu&#x27; REGEXP &#x27;[ab]&#x27;;</span><br><span class="line">+--------------------------+-------------------------+</span><br><span class="line">| &#x27;atguigu&#x27; REGEXP &#x27;gu.gu&#x27; | &#x27;atguigu&#x27; REGEXP &#x27;[ab]&#x27; |</span><br><span class="line">+--------------------------+-------------------------+</span><br><span class="line">|                        1 |                       1 |</span><br><span class="line">+--------------------------+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a>3. 逻辑运算符</h2><p>逻辑运算符主要用来判断表达式的真假，在MySQL中，逻辑运算符的返回结果为1、0或者NULL。</p>
<p>MySQL中支持4种逻辑运算符如下：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211012110241418.png"
                        alt="image-20211012110241418"
                 ></p>
<p><strong>1．逻辑非运算符</strong><br>逻辑非（NOT或!）运算符表示当给定的值为0时返回1；当给定的值为非0值时返回0；当给定的值为NULL时，返回NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT NOT 1, NOT 0, NOT(1+1), NOT !1, NOT NULL;    </span><br><span class="line">+-------+-------+----------+--------+----------+</span><br><span class="line">| NOT 1 | NOT 0 | NOT(1+1) | NOT !1 | NOT NULL |</span><br><span class="line">+-------+-------+----------+--------+----------+</span><br><span class="line">|     0 |     1 |        0 |      1 |     NULL |</span><br><span class="line">+-------+-------+----------+--------+----------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last_name, job_id</span><br><span class="line">FROM   employees</span><br><span class="line">WHERE  job_id NOT IN (&#x27;IT_PROG&#x27;, &#x27;ST_CLERK&#x27;, &#x27;SA_REP&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>2．逻辑与运算符</strong><br>逻辑与（AND或&amp;&amp;）运算符是当给定的所有值均为非0值，并且都不为NULL时，返回1；当给定的一个值或者多个值为0时则返回0；否则返回NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 AND -1, 0 AND 1, 0 AND NULL, 1 AND NULL;</span><br><span class="line">+----------+---------+------------+------------+</span><br><span class="line">| 1 AND -1 | 0 AND 1 | 0 AND NULL | 1 AND NULL |</span><br><span class="line">+----------+---------+------------+------------+</span><br><span class="line">|        1 |       0 |          0 |       NULL |</span><br><span class="line">+----------+---------+------------+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id, last_name, job_id, salary</span><br><span class="line">FROM   employees</span><br><span class="line">WHERE  salary &gt;=10000</span><br><span class="line">AND    job_id LIKE &#x27;%MAN%&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>3．逻辑或运算符</strong><br>逻辑或（OR或||）运算符是当给定的值都不为NULL，并且任何一个值为非0值时，则返回1，否则返回0；当一个值为NULL，并且另一个值为非0值时，返回1，否则返回NULL；当两个值都为NULL时，返回NULL。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 OR -1, 1 OR 0, 1 OR NULL, 0 || NULL, NULL || NULL;     </span><br><span class="line">+---------+--------+-----------+-----------+--------------+</span><br><span class="line">| 1 OR -1 | 1 OR 0 | 1 OR NULL | 0 || NULL | NULL || NULL |</span><br><span class="line">+---------+--------+-----------+-----------+--------------+</span><br><span class="line">|       1 |      1 |         1 |    NULL   |       NULL   |</span><br><span class="line">+---------+--------+-----------+-----------+--------------+</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询基本薪资不在9000-12000之间的员工编号和基本薪资</span><br><span class="line">SELECT employee_id,salary FROM employees </span><br><span class="line">WHERE NOT (salary &gt;= 9000 AND salary &lt;= 12000);</span><br><span class="line"></span><br><span class="line">SELECT employee_id,salary FROM employees </span><br><span class="line">WHERE salary &lt;9000 OR salary &gt; 12000;</span><br><span class="line"></span><br><span class="line">SELECT employee_id,salary FROM employees </span><br><span class="line">WHERE salary NOT BETWEEN 9000 AND 12000;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id, last_name, job_id, salary</span><br><span class="line">FROM   employees</span><br><span class="line">WHERE  salary &gt;= 10000</span><br><span class="line">OR     job_id LIKE &#x27;%MAN%&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>OR可以和AND一起使用，但是在使用时要注意两者的优先级，由于AND的优先级高于OR，因此先对AND两边的操作数进行操作，再与OR中的操作数结合。</p>
</blockquote>
<p><strong>4．逻辑异或运算符</strong><br>逻辑异或（XOR）运算符是当给定的值中任意一个值为NULL时，则返回NULL；如果两个非NULL的值都是0或者都不等于0时，则返回0；如果一个值为0，另一个值不为0时，则返回1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 XOR -1, 1 XOR 0, 0 XOR 0, 1 XOR NULL, 1 XOR 1 XOR 1, 0 XOR 0 XOR 0;</span><br><span class="line">+----------+---------+---------+------------+---------------+---------------+</span><br><span class="line">| 1 XOR -1 | 1 XOR 0 | 0 XOR 0 | 1 XOR NULL | 1 XOR 1 XOR 1 | 0 XOR 0 XOR 0 |</span><br><span class="line">+----------+---------+---------+------------+---------------+---------------+</span><br><span class="line">|        0 |       1 |       0 |       NULL |             1 |             0 |</span><br><span class="line">+----------+---------+---------+------------+---------------+---------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select last_name,department_id,salary </span><br><span class="line">from employees</span><br><span class="line">where department_id in (10,20) XOR salary &gt; 8000;</span><br></pre></td></tr></table></figure>

<h2 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4. 位运算符"></a>4. 位运算符</h2><p>位运算符是在二进制数上进行计算的运算符。位运算符会先将操作数变成二进制数，然后进行位运算，最后将计算结果从二进制变回十进制数。</p>
<p>MySQL支持的位运算符如下：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211012110511223.png"
                        alt="image-20211012110511223"
                 ></p>
<p><strong>1．按位与运算符</strong><br>按位与（&amp;）运算符将给定值对应的二进制数逐位进行逻辑与运算。当给定值对应的二进制位的数值都为1时，则该位返回1，否则返回0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 &amp; 10, 20 &amp; 30;</span><br><span class="line">+--------+---------+</span><br><span class="line">| 1 &amp; 10 | 20 &amp; 30 |</span><br><span class="line">+--------+---------+</span><br><span class="line">|      0 |      20 |</span><br><span class="line">+--------+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>1的二进制数为0001，10的二进制数为1010，所以1 &amp; 10的结果为0000，对应的十进制数为0。20的二进制数为10100，30的二进制数为11110，所以20 &amp; 30的结果为10100，对应的十进制数为20。</p>
<p><strong>2. 按位或运算符</strong><br>按位或（|）运算符将给定的值对应的二进制数逐位进行逻辑或运算。当给定值对应的二进制位的数值有一个或两个为1时，则该位返回1，否则返回0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 | 10, 20 | 30; </span><br><span class="line">+--------+---------+</span><br><span class="line">| 1 | 10 | 20 | 30 |</span><br><span class="line">+--------+---------+</span><br><span class="line">|     11 |      30 |</span><br><span class="line">+--------+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>1的二进制数为0001，10的二进制数为1010，所以1 | 10的结果为1011，对应的十进制数为11。20的二进制数为10100，30的二进制数为11110，所以20 | 30的结果为11110，对应的十进制数为30。</p>
<p><strong>3. 按位异或运算符</strong><br>按位异或（^）运算符将给定的值对应的二进制数逐位进行逻辑异或运算。当给定值对应的二进制位的数值不同时，则该位返回1，否则返回0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 ^ 10, 20 ^ 30; </span><br><span class="line">+--------+---------+</span><br><span class="line">| 1 ^ 10 | 20 ^ 30 |</span><br><span class="line">+--------+---------+</span><br><span class="line">|     11 |      10 |</span><br><span class="line">+--------+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>1的二进制数为0001，10的二进制数为1010，所以1 ^ 10的结果为1011，对应的十进制数为11。20的二进制数为10100，30的二进制数为11110，所以20 ^ 30的结果为01010，对应的十进制数为10。</p>
<p>再举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 12 &amp; 5, 12 | 5,12 ^ 5 FROM DUAL;</span><br><span class="line">+--------+--------+--------+</span><br><span class="line">| 12 &amp; 5 | 12 | 5 | 12 ^ 5 |</span><br><span class="line">+--------+--------+--------+</span><br><span class="line">|      4 |     13 |      9 |</span><br><span class="line">+--------+--------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211023115738415.png"
                         alt="image-20211023115738415" style="zoom:80%;" 
                 >

<p><strong>4. 按位取反运算符</strong><br>按位取反（~）运算符将给定的值的二进制数逐位进行取反操作，即将1变为0，将0变为1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 10 &amp; ~1;</span><br><span class="line">+---------+</span><br><span class="line">| 10 &amp; ~1 |</span><br><span class="line">+---------+</span><br><span class="line">|      10 |</span><br><span class="line">+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>由于按位取反（~）运算符的优先级高于按位与（&amp;）运算符的优先级，所以10 &amp; ~1，首先，对数字1进行按位取反操作，结果除了最低位为0，其他位都为1，然后与10进行按位与操作，结果为10。</p>
<p><strong>5. 按位右移运算符</strong><br>按位右移（&gt;&gt;）运算符将给定的值的二进制数的所有位右移指定的位数。右移指定的位数后，右边低位的数值被移出并丢弃，左边高位空出的位置用0补齐。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 &gt;&gt; 2, 4 &gt;&gt; 2;</span><br><span class="line">+--------+--------+</span><br><span class="line">| 1 &gt;&gt; 2 | 4 &gt;&gt; 2 |</span><br><span class="line">+--------+--------+</span><br><span class="line">|      0 |      1 |</span><br><span class="line">+--------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>1的二进制数为0000 0001，右移2位为0000 0000，对应的十进制数为0。4的二进制数为0000 0100，右移2位为0000 0001，对应的十进制数为1。</p>
<p><strong>6. 按位左移运算符</strong><br>按位左移（&lt;&lt;）运算符将给定的值的二进制数的所有位左移指定的位数。左移指定的位数后，左边高位的数值被移出并丢弃，右边低位空出的位置用0补齐。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT 1 &lt;&lt; 2, 4 &lt;&lt; 2;  </span><br><span class="line">+--------+--------+</span><br><span class="line">| 1 &lt;&lt; 2 | 4 &lt;&lt; 2 |</span><br><span class="line">+--------+--------+</span><br><span class="line">|      4 |     16 |</span><br><span class="line">+--------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>1的二进制数为0000 0001，左移两位为0000 0100，对应的十进制数为4。4的二进制数为0000 0100，左移两位为0001 0000，对应的十进制数为16。</p>
<h2 id="5-运算符的优先级"><a href="#5-运算符的优先级" class="headerlink" title="5. 运算符的优先级"></a>5. 运算符的优先级</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211012111042395.png"
                        alt="image-20211012111042395"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211012110731059.png"
                        alt="image-20211012110731059"
                 ></p>
<p>数字编号越大，优先级越高，优先级高的运算符先进行计算。可以看到，赋值运算符的优先级最低，使用“()”括起来的表达式的优先级最高。</p>
<h2 id="拓展：使用正则表达式查询"><a href="#拓展：使用正则表达式查询" class="headerlink" title="拓展：使用正则表达式查询"></a>拓展：使用正则表达式查询</h2><p>正则表达式通常被用来检索或替换那些符合某个模式的文本内容，根据指定的匹配模式匹配文本中符合要求的特殊字符串。例如，从一个文本文件中提取电话号码，查找一篇文章中重复的单词或者替换用户输入的某些敏感词语等，这些地方都可以使用正则表达式。正则表达式强大而且灵活，可以应用于非常复杂的查询。</p>
<p>MySQL中使用REGEXP关键字指定正则表达式的字符匹配模式。下表列出了REGEXP操作符中常用字符匹配列表。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20210926151249943.png"
                        alt="image-20210926151249943"
                 ></p>
<p><strong>1. 查询以特定字符或字符串开头的记录</strong><br>字符‘^’匹配以特定字符或者字符串开头的文本。</p>
<p>在fruits表中，查询f_name字段以字母‘b’开头的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;^b&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>2. 查询以特定字符或字符串结尾的记录</strong><br>字符‘$’匹配以特定字符或者字符串结尾的文本。</p>
<p>在fruits表中，查询f_name字段以字母‘y’结尾的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;y$&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>3. 用符号”.”来替代字符串中的任意一个字符</strong><br>字符‘.’匹配任意一个字符。<br>在fruits表中，查询f_name字段值包含字母‘a’与‘g’且两个字母之间只有一个字母的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;a.g&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>4. 使用”*”和”+”来匹配多个字符</strong><br>星号‘*’匹配前面的字符任意多次，包括0次。加号‘+’匹配前面的字符至少一次。</p>
<p>在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;^ba*&#x27;;</span><br></pre></td></tr></table></figure>

<p>在fruits表中，查询f_name字段值以字母‘b’开头且‘b’后面出现字母‘a’至少一次的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;^ba+&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>5. 匹配指定字符串</strong><br>正则表达式可以匹配指定字符串，只要这个字符串在查询文本中即可，如要匹配多个字符串，多个字符串之间使用分隔符‘|’隔开。</p>
<p>在fruits表中，查询f_name字段值包含字符串“on”的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;on&#x27;;</span><br></pre></td></tr></table></figure>

<p>在fruits表中，查询f_name字段值包含字符串“on”或者“ap”的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;on|ap&#x27;;</span><br></pre></td></tr></table></figure>

<p>之前介绍过，LIKE运算符也可以匹配指定的字符串，但与REGEXP不同，LIKE匹配的字符串如果在文本中间出现，则找不到它，相应的行也不会返回。REGEXP在文本内进行匹配，如果被匹配的字符串在文本中出现，REGEXP将会找到它，相应的行也会被返回。对比结果如下所示。</p>
<p>在fruits表中，使用LIKE运算符查询f_name字段值为“on”的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name like &#x27;on&#x27;;</span><br><span class="line">Empty set(0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>6. 匹配指定字符中的任意一个</strong><br>方括号“[]”指定一个字符集合，只匹配其中任何一个字符，即为所查找的文本。</p>
<p>在fruits表中，查找f_name字段中包含字母‘o’或者‘t’的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;[ot]&#x27;;</span><br></pre></td></tr></table></figure>

<p>在fruits表中，查询s_id字段中包含4、5或者6的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE s_id REGEXP &#x27;[456]&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>7. 匹配指定字符以外的字符</strong><br><code>“[^字符集合]”</code>匹配不在指定集合中的任何字符。</p>
<p>在fruits表中，查询f_id字段中包含字母a<del>e和数字1</del>2以外字符的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_id REGEXP &#x27;[^a-e1-2]&#x27;;</span><br></pre></td></tr></table></figure>

<p><strong>8. 使用{n,}或者{n,m}来指定字符串连续出现的次数</strong><br>“字符串{n,}”表示至少匹配n次前面的字符；“字符串{n,m}”表示匹配前面的字符串不少于n次，不多于m次。例如，a{2,}表示字母a连续出现至少2次，也可以大于2次；a{2,4}表示字母a连续出现最少2次，最多不能超过4次。</p>
<p>在fruits表中，查询f_name字段值出现字母‘x’至少2次的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;x&#123;2,&#125;&#x27;;</span><br></pre></td></tr></table></figure>

<p>在fruits表中，查询f_name字段值出现字符串“ba”最少1次、最多3次的记录，SQL语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM fruits WHERE f_name REGEXP &#x27;ba&#123;1,3&#125;&#x27;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="第05章-排序与分页"><a href="#第05章-排序与分页" class="headerlink" title="第05章_排序与分页"></a>第05章_排序与分页</h1><hr>
<h2 id="1-排序数据"><a href="#1-排序数据" class="headerlink" title="1. 排序数据"></a>1. 排序数据</h2><h3 id="1-1-排序规则"><a href="#1-1-排序规则" class="headerlink" title="1.1 排序规则"></a>1.1 排序规则</h3><ul>
<li>使用 ORDER BY 子句排序<ul>
<li><strong>ASC（ascend）: 升序</strong></li>
<li><strong>DESC（descend）:降序</strong></li>
</ul>
</li>
<li><strong>ORDER BY 子句在SELECT语句的结尾。</strong></li>
</ul>
<h3 id="1-2-单列排序"><a href="#1-2-单列排序" class="headerlink" title="1.2 单列排序"></a>1.2 单列排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT   last_name, job_id, department_id, hire_date</span><br><span class="line">FROM     employees</span><br><span class="line">ORDER BY hire_date ;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554974255957.png"
                        alt="1554974255957"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554974260133.png"
                        alt="1554974260133"
                 ></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT   last_name, job_id, department_id, hire_date</span><br><span class="line">FROM     employees</span><br><span class="line">ORDER BY hire_date DESC ;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554974822229.png"
                        alt="1554974822229"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554974827522.png"
                        alt="1554974827522"
                 ></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id, last_name, salary*12 annsal</span><br><span class="line">FROM   employees</span><br><span class="line">ORDER BY annsal;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554974853194.png"
                        alt="1554974853194"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554974858252.png"
                        alt="1554974858252"
                 ></p>
<h3 id="1-3-多列排序"><a href="#1-3-多列排序" class="headerlink" title="1.3 多列排序"></a>1.3 多列排序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last_name, department_id, salary</span><br><span class="line">FROM   employees</span><br><span class="line">ORDER BY department_id, salary DESC;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554974901572.png"
                        alt="1554974901572"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554974907498.png"
                        alt="1554974907498"
                 ></p>
<ul>
<li>可以使用不在SELECT列表中的列排序。</li>
<li>在对多列进行排序的时候，首先排序的第一列必须有相同的列值，才会对第二列进行排序。如果第一列数据中所有值都是唯一的，将不再对第二列进行排序。</li>
</ul>
<h2 id="2-分页"><a href="#2-分页" class="headerlink" title="2. 分页"></a>2. 分页</h2><h3 id="2-1-背景"><a href="#2-1-背景" class="headerlink" title="2.1 背景"></a>2.1 背景</h3><p>背景1：查询返回的记录太多了，查看起来很不方便，怎么样能够实现分页查询呢？</p>
<p>背景2：表里有 4 条数据，我们只想要显示第 2、3 条数据怎么办呢？</p>
<h3 id="2-2-实现规则"><a href="#2-2-实现规则" class="headerlink" title="2.2 实现规则"></a>2.2 实现规则</h3><ul>
<li><p>分页原理</p>
<p>所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件。</p>
</li>
<li><p><strong>MySQL中使用 LIMIT 实现分页</strong></p>
</li>
<li><p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LIMIT [位置偏移量,] 行数</span><br></pre></td></tr></table></figure>

<p>第一个“位置偏移量”参数指示MySQL从哪一行开始显示，是一个可选参数，如果不指定“位置偏移量”，将会从表中的第一条记录开始（第一条记录的位置偏移量是0，第二条记录的位置偏移量是1，以此类推）；第二个参数“行数”指示返回的记录条数。</p>
</li>
<li><p>举例</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--前10条记录：</span><br><span class="line">SELECT * FROM 表名 LIMIT 0,10;</span><br><span class="line">或者</span><br><span class="line">SELECT * FROM 表名 LIMIT 10;</span><br><span class="line"></span><br><span class="line">--第11至20条记录：</span><br><span class="line">SELECT * FROM 表名 LIMIT 10,10;</span><br><span class="line"></span><br><span class="line">--第21至30条记录： </span><br><span class="line">SELECT * FROM 表名 LIMIT 20,10;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>MySQL 8.0中可以使用“LIMIT 3 OFFSET 4”，意思是获取从第5条记录开始后面的3条记录，和“LIMIT 4,3;”返回的结果相同。</p>
</blockquote>
<ul>
<li>分页显式公式**：（当前页数-1）<em>每页条数，每页条数</em>*</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table </span><br><span class="line">LIMIT(PageNo - 1)*PageSize,PageSize;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意：LIMIT 子句必须放在整个SELECT语句的最后！</strong></li>
<li>使用 LIMIT 的好处</li>
</ul>
<p>约束返回结果的数量可以<code>减少数据表的网络传输量</code>，也可以<code>提升查询效率</code>。如果我们知道返回结果只有 1 条，就可以使用<code>LIMIT 1</code>，告诉 SELECT 语句只需要返回一条记录即可。这样的好处就是 SELECT 不需要扫描完整的表，只需要检索到一条符合条件的记录即可返回。</p>
<h3 id="2-3-拓展"><a href="#2-3-拓展" class="headerlink" title="2.3 拓展"></a>2.3 拓展</h3><p>在不同的 DBMS 中使用的关键字可能不同。在 MySQL、PostgreSQL、MariaDB 和 SQLite 中使用 LIMIT 关键字，而且需要放到 SELECT 语句的最后面。</p>
<ul>
<li>如果是 SQL Server 和 Access，需要使用 <code>TOP</code> 关键字，比如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT TOP 5 name, hp_max FROM heros ORDER BY hp_max DESC</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是 DB2，使用<code>FETCH FIRST 5 ROWS ONLY</code>这样的关键字：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT name, hp_max FROM heros ORDER BY hp_max DESC FETCH FIRST 5 ROWS ONLY</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是 Oracle，你需要基于 <code>ROWNUM</code> 来统计行数：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT rownum,last_name,salary FROM employees WHERE rownum &lt; 5 ORDER BY salary DESC;</span><br></pre></td></tr></table></figure>

<p>需要说明的是，这条语句是先取出来前 5 条数据行，然后再按照 hp_max 从高到低的顺序进行排序。但这样产生的结果和上述方法的并不一样。我会在后面讲到子查询，你可以使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT rownum, last_name,salary</span><br><span class="line">FROM (</span><br><span class="line">    SELECT last_name,salary</span><br><span class="line">    FROM employees</span><br><span class="line">    ORDER BY salary DESC)</span><br><span class="line">WHERE rownum &lt; 10;</span><br></pre></td></tr></table></figure>

<p>得到与上述方法一致的结果。</p>
<hr>
<h1 id="第06章-多表查询"><a href="#第06章-多表查询" class="headerlink" title="第06章_多表查询"></a>第06章_多表查询</h1><hr>
<p>多表查询，也称为关联查询，指两个或更多个表一起完成查询操作。</p>
<p>前提条件：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有关联字段，这个关联字段可能建立了外键，也可能没有建立外键。比如：员工表和部门表，这两个表依靠“部门编号”进行关联。</p>
<h2 id="1-一个案例引发的多表连接"><a href="#1-一个案例引发的多表连接" class="headerlink" title="1. 一个案例引发的多表连接"></a>1. 一个案例引发的多表连接</h2><h3 id="1-1-案例说明"><a href="#1-1-案例说明" class="headerlink" title="1.1 案例说明"></a>1.1 案例说明</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554974984600.png"
                        alt="1554974984600"
                 ></p>
<p>从多个表中获取数据：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554975020388.png"
                        alt="1554975020388"
                 ></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#案例：查询员工的姓名及其部门名称</span><br><span class="line">SELECT last_name, department_name</span><br><span class="line">FROM employees, departments;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554975097631.png"
                        alt="1554975097631"
                 ></p>
<p>查询结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-----------+----------------------+</span><br><span class="line">| last_name | department_name      |</span><br><span class="line">+-----------+----------------------+</span><br><span class="line">| King      | Administration       |</span><br><span class="line">| King      | Marketing            |</span><br><span class="line">| King      | Purchasing           |</span><br><span class="line">| King      | Human Resources      |</span><br><span class="line">| King      | Shipping             |</span><br><span class="line">| King      | IT                   |</span><br><span class="line">| King      | Public Relations     |</span><br><span class="line">| King      | Sales                |</span><br><span class="line">| King      | Executive            |</span><br><span class="line">| King      | Finance              |</span><br><span class="line">| King      | Accounting           |</span><br><span class="line">| King      | Treasury             |</span><br><span class="line">...</span><br><span class="line">| Gietz     | IT Support           |</span><br><span class="line">| Gietz     | NOC                  |</span><br><span class="line">| Gietz     | IT Helpdesk          |</span><br><span class="line">| Gietz     | Government Sales     |</span><br><span class="line">| Gietz     | Retail Sales         |</span><br><span class="line">| Gietz     | Recruiting           |</span><br><span class="line">| Gietz     | Payroll              |</span><br><span class="line">+-----------+----------------------+</span><br><span class="line">2889 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p><strong>分析错误情况：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(employee_id) FROM employees;</span><br><span class="line">#输出107行</span><br><span class="line"></span><br><span class="line">SELECT COUNT(department_id)FROM departments;</span><br><span class="line">#输出27行</span><br><span class="line"></span><br><span class="line">SELECT 107*27 FROM dual;</span><br></pre></td></tr></table></figure>

<p>我们把上述多表查询中出现的问题称为：笛卡尔积的错误。</p>
<h3 id="1-2-笛卡尔积（或交叉连接）的理解"><a href="#1-2-笛卡尔积（或交叉连接）的理解" class="headerlink" title="1.2 笛卡尔积（或交叉连接）的理解"></a>1.2 笛卡尔积（或交叉连接）的理解</h3><p>笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。组合的个数即为两个集合中元素个数的乘积数。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://images0.cnblogs.com/i/595518/201403/302046364841977.jpg"
                         alt="img" style="zoom:80%;" 
                 >

<p>SQL92中，笛卡尔积也称为<code>交叉连接</code>，英文是 <code>CROSS JOIN</code>。在 SQL99 中也是使用 CROSS JOIN表示交叉连接。它的作用就是可以把任意表进行连接，即使这两张表不相关。在MySQL中如下情况会出现笛卡尔积：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询员工姓名和所在部门名称</span><br><span class="line">SELECT last_name,department_name FROM employees,departments;</span><br><span class="line">SELECT last_name,department_name FROM employees CROSS JOIN departments;</span><br><span class="line">SELECT last_name,department_name FROM employees INNER JOIN departments;</span><br><span class="line">SELECT last_name,department_name FROM employees JOIN departments;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-案例分析与问题解决"><a href="#1-3-案例分析与问题解决" class="headerlink" title="1.3 案例分析与问题解决"></a>1.3 案例分析与问题解决</h3><ul>
<li><p><strong>笛卡尔积的错误会在下面条件下产生</strong>：</p>
<ul>
<li>省略多个表的连接条件（或关联条件）</li>
<li>连接条件（或关联条件）无效</li>
<li>所有表中的所有行互相连接</li>
</ul>
</li>
<li><p>为了避免笛卡尔积， 可以<strong>在 WHERE 加入有效的连接条件。</strong></p>
</li>
<li><p>加入连接条件后，查询语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT	table1.column, table2.column</span><br><span class="line">FROM	table1, table2</span><br><span class="line">WHERE	table1.column1 = table2.column2;  #连接条件</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>在 WHERE子句中写入连接条件。</strong></li>
</ul>
</li>
<li><p>正确写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#案例：查询员工的姓名及其部门名称</span><br><span class="line">SELECT last_name, department_name</span><br><span class="line">FROM employees, departments</span><br><span class="line">WHERE employees.department_id = departments.department_id;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在表中有相同列时，在列名之前加上表名前缀。</strong></p>
</li>
</ul>
<h2 id="2-多表查询分类讲解"><a href="#2-多表查询分类讲解" class="headerlink" title="2. 多表查询分类讲解"></a>2. 多表查询分类讲解</h2><h3 id="分类1：等值连接-vs-非等值连接"><a href="#分类1：等值连接-vs-非等值连接" class="headerlink" title="分类1：等值连接 vs 非等值连接"></a>分类1：等值连接 vs 非等值连接</h3><h4 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h4><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554975496900.png"
                        alt="1554975496900"
                 ></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employees.employee_id, employees.last_name, </span><br><span class="line">       employees.department_id, departments.department_id,</span><br><span class="line">       departments.location_id</span><br><span class="line">FROM   employees, departments</span><br><span class="line">WHERE  employees.department_id = departments.department_id;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554975522600.png"
                        alt="1554975522600"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554975526339.png"
                        alt="1554975526339"
                 ></p>
<p><strong>拓展1：多个连接条件与 AND 操作符</strong></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554975606231.png"
                        alt="1554975606231"
                 ></p>
<p><strong>拓展2：区分重复的列名</strong></p>
<ul>
<li><strong>多个表中有相同列时，必须在列名之前加上表名前缀。</strong></li>
<li>在不同表中具有相同列名的列可以用<code>表名</code>加以区分。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employees.last_name, departments.department_name,employees.department_id</span><br><span class="line">FROM employees, departments</span><br><span class="line">WHERE employees.department_id = departments.department_id;</span><br></pre></td></tr></table></figure>

<p><strong>拓展3：表的别名</strong></p>
<ul>
<li><p>使用别名可以简化查询。</p>
</li>
<li><p>列名前使用表名前缀可以提高查询效率。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT e.employee_id, e.last_name, e.department_id,</span><br><span class="line">       d.department_id, d.location_id</span><br><span class="line">FROM   employees e , departments d</span><br><span class="line">WHERE  e.department_id = d.department_id;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替，不能使用原有的表名，否则就会报错。</p>
</blockquote>
<blockquote>
<p><code>阿里开发规范</code>：</p>
<p>【<code>强制</code>】对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或 表名）进行限定。</p>
<p><code>说明</code>：对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表名），并且操作列在多个表中存在时，就会抛异常。</p>
<p><code>正例</code>：select t1.name from table_first as t1 , table_second as t2 where t1.id&#x3D;t2.id;</p>
<p><code>反例</code>：在某业务中，由于多表关联查询语句没有加表的别名（或表名）的限制，正常运行两年后，最近在 某个表中增加一个同名字段，在预发布环境做数据库变更后，线上查询语句出现出 1052 异常：Column  ‘name’ in field list is ambiguous。</p>
</blockquote>
<p><strong>拓展4：连接多个表</strong></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554978354431.png"
                        alt="1554978354431"
                 ></p>
<p>**总结：连接 n个表,至少需要n-1个连接条件。**比如，连接三个表，至少需要两个连接条件。</p>
<p>练习：查询出公司员工的 last_name,department_name, city</p>
<h4 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h4><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554978442447.png"
                        alt="1554978442447"
                 ></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT e.last_name, e.salary, j.grade_level</span><br><span class="line">FROM   employees e, job_grades j</span><br><span class="line">WHERE  e.salary BETWEEN j.lowest_sal AND j.highest_sal;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554978477013.png"
                        alt="1554978477013"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554978482652.png"
                        alt="1554978482652"
                 ></p>
<h3 id="分类2：自连接-vs-非自连接"><a href="#分类2：自连接-vs-非自连接" class="headerlink" title="分类2：自连接 vs 非自连接"></a>分类2：自连接 vs 非自连接</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554978514321.png"
                        alt="1554978514321"
                 ></p>
<ul>
<li>当table1和table2本质上是同一张表，只是用取别名的方式虚拟成两张表以代表不同的意义。然后两个表再进行内连接，外连接等查询。</li>
</ul>
<p><strong>题目：查询employees表，返回“Xxx  works for Xxx”</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT CONCAT(worker.last_name ,&#x27; works for &#x27; </span><br><span class="line">       , manager.last_name)</span><br><span class="line">FROM   employees worker, employees manager</span><br><span class="line">WHERE  worker.manager_id = manager.employee_id ;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554978684947.png"
                        alt="1554978684947"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554978690764.png"
                        alt="1554978690764"
                 ></p>
<p>练习：查询出last_name为 ‘Chen’ 的员工的 manager 的信息。</p>
<h3 id="分类3：内连接-vs-外连接"><a href="#分类3：内连接-vs-外连接" class="headerlink" title="分类3：内连接 vs 外连接"></a>分类3：内连接 vs 外连接</h3><p>除了查询满足条件的记录以外，外连接还可以查询某一方不满足条件的记录。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554978955659.png"
                        alt="1554978955659"
                 ></p>
<ul>
<li><p>内连接: 合并具有同一列的两个以上的表的行, <strong>结果集中不包含一个表与另一个表不匹配的行</strong></p>
</li>
<li><p>外连接: 两个表在连接过程中除了返回满足连接条件的行以外<strong>还返回左（或右）表中不满足条件的行</strong> <strong>，这种连接称为左（或右） 外连接</strong>。没有匹配的行时, 结果表中相应的列为空(NULL)。</p>
</li>
<li><p>如果是左外连接，则连接条件中左边的表也称为<code>主表</code>，右边的表称为<code>从表</code>。</p>
<p>如果是右外连接，则连接条件中右边的表也称为<code>主表</code>，左边的表称为<code>从表</code>。</p>
</li>
</ul>
<h4 id="SQL92：使用-创建连接"><a href="#SQL92：使用-创建连接" class="headerlink" title="SQL92：使用(+)创建连接"></a>SQL92：使用(+)创建连接</h4><ul>
<li><p>在 SQL92 中采用（+）代表从表所在的位置。即左或右外连接中，(+) 表示哪个是从表。</p>
</li>
<li><p>Oracle 对 SQL92 支持较好，而 MySQL 则不支持 SQL92 的外连接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#左外连接</span><br><span class="line">SELECT last_name,department_name</span><br><span class="line">FROM employees ,departments</span><br><span class="line">WHERE employees.department_id = departments.department_id(+);</span><br><span class="line"></span><br><span class="line">#右外连接</span><br><span class="line">SELECT last_name,department_name</span><br><span class="line">FROM employees ,departments</span><br><span class="line">WHERE employees.department_id(+) = departments.department_id;</span><br></pre></td></tr></table></figure>
</li>
<li><p>而且在 SQL92 中，只有左外连接和右外连接，没有满（或全）外连接。</p>
</li>
</ul>
<h2 id="3-SQL99语法实现多表查询"><a href="#3-SQL99语法实现多表查询" class="headerlink" title="3. SQL99语法实现多表查询"></a>3. SQL99语法实现多表查询</h2><h3 id="3-1-基本语法"><a href="#3-1-基本语法" class="headerlink" title="3.1 基本语法"></a>3.1 基本语法</h3><ul>
<li><p>使用JOIN…ON子句创建连接的语法结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT table1.column, table2.column,table3.column</span><br><span class="line">FROM table1</span><br><span class="line">    JOIN table2 ON table1 和 table2 的连接条件</span><br><span class="line">        JOIN table3 ON table2 和 table3 的连接条件</span><br></pre></td></tr></table></figure>

<p>它的嵌套逻辑类似我们使用的 FOR 循环：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for t1 in table1:</span><br><span class="line">    for t2 in table2:</span><br><span class="line">       if condition1:</span><br><span class="line">           for t3 in table3:</span><br><span class="line">              if condition2:</span><br><span class="line">                  output t1 + t2 + t3</span><br></pre></td></tr></table></figure>

<p>SQL99 采用的这种嵌套结构非常清爽、层次性更强、可读性更强，即使再多的表进行连接也都清晰可见。如果你采用 SQL92，可读性就会大打折扣。</p>
</li>
<li><p>语法说明：</p>
<ul>
<li><strong>可以使用</strong> <strong>ON</strong> <strong>子句指定额外的连接条件</strong>。</li>
<li>这个连接条件是与其它条件分开的。</li>
<li><strong>ON</strong> <strong>子句使语句具有更高的易读性</strong>。</li>
<li>关键字 JOIN、INNER JOIN、CROSS JOIN 的含义是一样的，都表示内连接</li>
</ul>
</li>
</ul>
<h3 id="3-2-内连接-INNER-JOIN-的实现"><a href="#3-2-内连接-INNER-JOIN-的实现" class="headerlink" title="3.2 内连接(INNER JOIN)的实现"></a>3.2 内连接(INNER JOIN)的实现</h3><ul>
<li>语法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表</span><br><span class="line">FROM A表 INNER JOIN B表</span><br><span class="line">ON 关联条件</span><br><span class="line">WHERE 等其他子句;</span><br></pre></td></tr></table></figure>

<p>题目1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT e.employee_id, e.last_name, e.department_id, </span><br><span class="line">       d.department_id, d.location_id</span><br><span class="line">FROM   employees e JOIN departments d</span><br><span class="line">ON     (e.department_id = d.department_id);</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554979073996.png"
                        alt="1554979073996"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554979079395.png"
                        alt="1554979079395"
                 ></p>
<p>题目2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id, city, department_name</span><br><span class="line">FROM   employees e </span><br><span class="line">JOIN   departments d</span><br><span class="line">ON     d.department_id = e.department_id </span><br><span class="line">JOIN   locations l</span><br><span class="line">ON     d.location_id = l.location_id;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554979110008.png"
                        alt="1554979110008"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554979115642.png"
                        alt="1554979115642"
                 ></p>
<h3 id="3-3-外连接-OUTER-JOIN-的实现"><a href="#3-3-外连接-OUTER-JOIN-的实现" class="headerlink" title="3.3 外连接(OUTER JOIN)的实现"></a>3.3 外连接(OUTER JOIN)的实现</h3><h4 id="3-3-1-左外连接-LEFT-OUTER-JOIN"><a href="#3-3-1-左外连接-LEFT-OUTER-JOIN" class="headerlink" title="3.3.1 左外连接(LEFT OUTER JOIN)"></a>3.3.1 左外连接(LEFT OUTER JOIN)</h4><ul>
<li>语法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#实现查询结果是A</span><br><span class="line">SELECT 字段列表</span><br><span class="line">FROM A表 LEFT JOIN B表</span><br><span class="line">ON 关联条件</span><br><span class="line">WHERE 等其他子句;</span><br></pre></td></tr></table></figure>

<ul>
<li>举例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT e.last_name, e.department_id, d.department_name</span><br><span class="line">FROM   employees e</span><br><span class="line">LEFT OUTER JOIN departments d</span><br><span class="line">ON   (e.department_id = d.department_id) ;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554979200961.png"
                        alt="1554979200961"
                 ></p>
<h4 id="3-3-2-右外连接-RIGHT-OUTER-JOIN"><a href="#3-3-2-右外连接-RIGHT-OUTER-JOIN" class="headerlink" title="3.3.2 右外连接(RIGHT OUTER JOIN)"></a>3.3.2 右外连接(RIGHT OUTER JOIN)</h4><ul>
<li>语法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#实现查询结果是B</span><br><span class="line">SELECT 字段列表</span><br><span class="line">FROM A表 RIGHT JOIN B表</span><br><span class="line">ON 关联条件</span><br><span class="line">WHERE 等其他子句;</span><br></pre></td></tr></table></figure>

<ul>
<li>举例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT e.last_name, e.department_id, d.department_name</span><br><span class="line">FROM   employees e</span><br><span class="line">RIGHT OUTER JOIN departments d</span><br><span class="line">ON    (e.department_id = d.department_id) ;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554979243194.png"
                        alt="1554979243194"
                 ></p>
<blockquote>
<p>需要注意的是，LEFT JOIN 和 RIGHT JOIN 只存在于 SQL99 及以后的标准中，在 SQL92 中不存在，只能用 (+) 表示。</p>
</blockquote>
<h4 id="3-3-3-满外连接-FULL-OUTER-JOIN"><a href="#3-3-3-满外连接-FULL-OUTER-JOIN" class="headerlink" title="3.3.3 满外连接(FULL OUTER JOIN)"></a>3.3.3 满外连接(FULL OUTER JOIN)</h4><ul>
<li>满外连接的结果 &#x3D; 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。</li>
<li>SQL99是支持满外连接的。使用FULL JOIN 或 FULL OUTER JOIN来实现。</li>
<li>需要注意的是，MySQL不支持FULL JOIN，但是可以用 LEFT JOIN <strong>UNION</strong> RIGHT join代替。</li>
</ul>
<h2 id="4-UNION的使用"><a href="#4-UNION的使用" class="headerlink" title="4. UNION的使用"></a>4. UNION的使用</h2><p><strong>合并查询结果</strong><br>利用UNION关键字，可以给出多条SELECT语句，并将它们的结果组合成单个结果集。合并时，两个表对应的列数和数据类型必须相同，并且相互对应。各个SELECT语句之间使用UNION或UNION ALL关键字分隔。</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column,... FROM table1</span><br><span class="line">UNION [ALL]</span><br><span class="line">SELECT column,... FROM table2</span><br></pre></td></tr></table></figure>

<p><strong>UNION操作符</strong></p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/1554979317187.png"
                         alt="1554979317187" style="zoom: 67%;" 
                 >

<p>UNION 操作符返回两个查询的结果集的并集，去除重复记录。</p>
<p><strong>UNION ALL操作符</strong></p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/1554979343634.png"
                         alt="1554979343634" style="zoom: 67%;" 
                 >

<p>UNION ALL操作符返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。</p>
<blockquote>
<p>注意：执行UNION ALL语句时所需要的资源比UNION语句少。如果明确知道合并数据后的结果数据不存在重复数据，或者不需要去除重复的数据，则尽量使用UNION ALL语句，以提高数据查询的效率。</p>
</blockquote>
<p>举例：查询部门编号&gt;90或邮箱包含a的员工信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式1</span><br><span class="line">SELECT * FROM employees WHERE email LIKE &#x27;%a%&#x27; OR department_id&gt;90;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式2</span><br><span class="line">SELECT * FROM employees  WHERE email LIKE &#x27;%a%&#x27;</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM employees  WHERE department_id&gt;90;</span><br></pre></td></tr></table></figure>

<p>举例：查询中国用户中男性的信息以及美国用户中年男性的用户信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id,cname FROM t_chinamale WHERE csex=&#x27;男&#x27;</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT id,tname FROM t_usmale WHERE tGender=&#x27;male&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="5-7种SQL-JOINS的实现"><a href="#5-7种SQL-JOINS的实现" class="headerlink" title="5. 7种SQL JOINS的实现"></a>5. 7种SQL JOINS的实现</h2><img    
                       lazyload
                       alt="image"
                       data-src="MySQL/1554979255233.png"
                         alt="1554979255233" style="zoom:80%;" 
                 >

<h3 id="5-7-1-代码实现"><a href="#5-7-1-代码实现" class="headerlink" title="5.7.1 代码实现"></a>5.7.1 代码实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#中图：内连接 A∩B</span><br><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">ON e.`department_id` = d.`department_id`;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#左上图：左外连接</span><br><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e LEFT JOIN departments d</span><br><span class="line">ON e.`department_id` = d.`department_id`;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#右上图：右外连接</span><br><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e RIGHT JOIN departments d</span><br><span class="line">ON e.`department_id` = d.`department_id`;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#左中图：A - A∩B</span><br><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e LEFT JOIN departments d</span><br><span class="line">ON e.`department_id` = d.`department_id`</span><br><span class="line">WHERE d.`department_id` IS NULL</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#右中图：B-A∩B</span><br><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e RIGHT JOIN departments d</span><br><span class="line">ON e.`department_id` = d.`department_id`</span><br><span class="line">WHERE e.`department_id` IS NULL</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#左下图：满外连接</span><br><span class="line"># 左中图 + 右上图  A∪B</span><br><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e LEFT JOIN departments d</span><br><span class="line">ON e.`department_id` = d.`department_id`</span><br><span class="line">WHERE d.`department_id` IS NULL</span><br><span class="line">UNION ALL  #没有去重操作，效率高</span><br><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e RIGHT JOIN departments d</span><br><span class="line">ON e.`department_id` = d.`department_id`;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#右下图</span><br><span class="line">#左中图 + 右中图  A ∪B- A∩B 或者 (A -  A∩B) ∪ （B - A∩B）</span><br><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e LEFT JOIN departments d</span><br><span class="line">ON e.`department_id` = d.`department_id`</span><br><span class="line">WHERE d.`department_id` IS NULL</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e RIGHT JOIN departments d</span><br><span class="line">ON e.`department_id` = d.`department_id`</span><br><span class="line">WHERE e.`department_id` IS NULL</span><br></pre></td></tr></table></figure>

<h3 id="5-7-2-语法格式小结"><a href="#5-7-2-语法格式小结" class="headerlink" title="5.7.2 语法格式小结"></a>5.7.2 语法格式小结</h3><ul>
<li>左中图</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#实现A -  A∩B</span><br><span class="line">select 字段列表</span><br><span class="line">from A表 left join B表</span><br><span class="line">on 关联条件</span><br><span class="line">where 从表关联字段 is null and 等其他子句;</span><br></pre></td></tr></table></figure>

<ul>
<li>右中图</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#实现B -  A∩B</span><br><span class="line">select 字段列表</span><br><span class="line">from A表 right join B表</span><br><span class="line">on 关联条件</span><br><span class="line">where 从表关联字段 is null and 等其他子句;</span><br></pre></td></tr></table></figure>

<ul>
<li>左下图</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#实现查询结果是A∪B</span><br><span class="line">#用左外的A，union 右外的B</span><br><span class="line">select 字段列表</span><br><span class="line">from A表 left join B表</span><br><span class="line">on 关联条件</span><br><span class="line">where 等其他子句</span><br><span class="line"></span><br><span class="line">union </span><br><span class="line"></span><br><span class="line">select 字段列表</span><br><span class="line">from A表 right join B表</span><br><span class="line">on 关联条件</span><br><span class="line">where 等其他子句;</span><br></pre></td></tr></table></figure>

<ul>
<li>右下图</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#实现A∪B -  A∩B  或   (A -  A∩B) ∪ （B - A∩B）</span><br><span class="line">#使用左外的 (A -  A∩B)  union 右外的（B - A∩B）</span><br><span class="line">select 字段列表</span><br><span class="line">from A表 left join B表</span><br><span class="line">on 关联条件</span><br><span class="line">where 从表关联字段 is null and 等其他子句</span><br><span class="line"></span><br><span class="line">union</span><br><span class="line"></span><br><span class="line">select 字段列表</span><br><span class="line">from A表 right join B表</span><br><span class="line">on 关联条件</span><br><span class="line">where 从表关联字段 is null and 等其他子句</span><br></pre></td></tr></table></figure>



<h2 id="6-SQL99语法新特性"><a href="#6-SQL99语法新特性" class="headerlink" title="6. SQL99语法新特性"></a>6. SQL99语法新特性</h2><h3 id="6-1-自然连接"><a href="#6-1-自然连接" class="headerlink" title="6.1 自然连接"></a>6.1 自然连接</h3><p>SQL99 在 SQL92 的基础上提供了一些特殊语法，比如 <code>NATURAL JOIN</code> 用来表示自然连接。我们可以把自然连接理解为 SQL92 中的等值连接。它会帮你自动查询两张连接表中<code>所有相同的字段</code>，然后进行<code>等值连接</code>。</p>
<p>在SQL92标准中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">ON e.`department_id` = d.`department_id`</span><br><span class="line">AND e.`manager_id` = d.`manager_id`;</span><br></pre></td></tr></table></figure>

<p>在 SQL99 中你可以写成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e NATURAL JOIN departments d;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-USING连接"><a href="#6-2-USING连接" class="headerlink" title="6.2 USING连接"></a>6.2 USING连接</h3><p>当我们进行连接的时候，SQL99还支持使用 USING 指定数据表里的<code>同名字段</code>进行等值连接。但是只能配合JOIN一起使用。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">USING (department_id);</span><br></pre></td></tr></table></figure>

<p>你能看出与自然连接 NATURAL JOIN 不同的是，USING 指定了具体的相同的字段名称，你需要在 USING 的括号 () 中填入要指定的同名字段。同时使用 <code>JOIN...USING</code> 可以简化 JOIN ON 的等值连接。它与下面的 SQL 查询结果是相同的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id,last_name,department_name</span><br><span class="line">FROM employees e ,departments d</span><br><span class="line">WHERE e.department_id = d.department_id;</span><br></pre></td></tr></table></figure>

<h2 id="7-章节小结"><a href="#7-章节小结" class="headerlink" title="7. 章节小结"></a>7. 章节小结</h2><p>表连接的约束条件可以有三种方式：WHERE, ON, USING</p>
<ul>
<li><p>WHERE：适用于所有关联查询</p>
</li>
<li><p><code>ON</code>：只能和JOIN一起使用，只能写关联条件。虽然关联条件可以并到WHERE中和其他条件一起写，但分开写可读性更好。</p>
</li>
<li><p>USING：只能和JOIN一起使用，而且要求<strong>两个</strong>关联字段在关联表中名称一致，而且只能表示关联字段值相等</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#关联条件</span><br><span class="line">#把关联条件写在where后面</span><br><span class="line">SELECT last_name,department_name </span><br><span class="line">FROM employees,departments </span><br><span class="line">WHERE employees.department_id = departments.department_id;</span><br><span class="line"></span><br><span class="line">#把关联条件写在on后面，只能和JOIN一起使用</span><br><span class="line">SELECT last_name,department_name </span><br><span class="line">FROM employees INNER JOIN departments </span><br><span class="line">ON employees.department_id = departments.department_id;</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name </span><br><span class="line">FROM employees CROSS JOIN departments </span><br><span class="line">ON employees.department_id = departments.department_id;</span><br><span class="line"></span><br><span class="line">SELECT last_name,department_name  </span><br><span class="line">FROM employees JOIN departments </span><br><span class="line">ON employees.department_id = departments.department_id;</span><br><span class="line"></span><br><span class="line">#把关联字段写在using()中，只能和JOIN一起使用</span><br><span class="line">#而且两个表中的关联字段必须名称相同，而且只能表示=</span><br><span class="line">#查询员工姓名与基本工资</span><br><span class="line">SELECT last_name,job_title</span><br><span class="line">FROM employees INNER JOIN jobs USING(job_id);</span><br><span class="line"></span><br><span class="line">#n张表关联，需要n-1个关联条件</span><br><span class="line">#查询员工姓名，基本工资，部门名称</span><br><span class="line">SELECT last_name,job_title,department_name FROM employees,departments,jobs </span><br><span class="line">WHERE employees.department_id = departments.department_id </span><br><span class="line">AND employees.job_id = jobs.job_id;</span><br><span class="line"></span><br><span class="line">SELECT last_name,job_title,department_name </span><br><span class="line">FROM employees INNER JOIN departments INNER JOIN jobs </span><br><span class="line">ON employees.department_id = departments.department_id </span><br><span class="line">AND employees.job_id = jobs.job_id;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>我们要<code>控制连接表的数量</code>。多表连接就相当于嵌套 for 循环一样，非常消耗资源，会让 SQL 查询性能下降得很严重，因此不要连接不必要的表。在许多 DBMS 中，也都会有最大连接表的限制。</p>
<blockquote>
<p>【强制】超过三个表禁止 join。需要 join 的字段，数据类型保持绝对一致；多表关联查询时， 保证被关联的字段需要有索引。</p>
<p>说明：即使双表 join 也要注意表索引、SQL 性能。</p>
<p>来源：阿里巴巴《Java开发手册》</p>
</blockquote>
<h2 id="附录：常用的-SQL-标准有哪些"><a href="#附录：常用的-SQL-标准有哪些" class="headerlink" title="附录：常用的 SQL 标准有哪些"></a>附录：常用的 SQL 标准有哪些</h2><p>在正式开始讲连接表的种类时，我们首先需要知道 SQL 存在不同版本的标准规范，因为不同规范下的表连接操作是有区别的。</p>
<p>SQL 有两个主要的标准，分别是 <code>SQL92</code> 和 <code>SQL99</code>。92 和 99 代表了标准提出的时间，SQL92 就是 92 年提出的标准规范。当然除了 SQL92 和 SQL99 以外，还存在 SQL-86、SQL-89、SQL:2003、SQL:2008、SQL:2011 和 SQL:2016 等其他的标准。</p>
<p>这么多标准，到底该学习哪个呢？<strong>实际上最重要的 SQL 标准就是 SQL92 和 SQL99</strong>。一般来说 SQL92 的形式更简单，但是写的 SQL 语句会比较长，可读性较差。而 SQL99 相比于 SQL92 来说，语法更加复杂，但可读性更强。我们从这两个标准发布的页数也能看出，SQL92 的标准有 500 页，而 SQL99 标准超过了 1000 页。实际上从 SQL99 之后，很少有人能掌握所有内容，因为确实太多了。就好比我们使用 Windows、Linux 和 Office 的时候，很少有人能掌握全部内容一样。我们只需要掌握一些核心的功能，满足日常工作的需求即可。</p>
<p>**SQL92 和 SQL99 是经典的 SQL 标准，也分别叫做 SQL-2 和 SQL-3 标准。**也正是在这两个标准发布之后，SQL 影响力越来越大，甚至超越了数据库领域。现如今 SQL 已经不仅仅是数据库领域的主流语言，还是信息领域中信息处理的主流语言。在图形检索、图像检索以及语音检索中都能看到 SQL 语言的使用。</p>
<hr>
<h1 id="第07章-单行函数"><a href="#第07章-单行函数" class="headerlink" title="第07章_单行函数"></a>第07章_单行函数</h1><hr>
<h2 id="1-函数的理解"><a href="#1-函数的理解" class="headerlink" title="1. 函数的理解"></a>1. 函数的理解</h2><h3 id="1-1-什么是函数"><a href="#1-1-什么是函数" class="headerlink" title="1.1 什么是函数"></a>1.1 什么是函数</h3><p>函数在计算机语言的使用中贯穿始终，函数的作用是什么呢？它可以把我们经常使用的代码封装起来，需要的时候直接调用即可。这样既<code>提高了代码效率</code>，又<code>提高了可维护性</code>。在 SQL 中我们也可以使用函数对检索出来的数据进行函数操作。使用这些函数，可以极大地<code>提高用户对数据库的管理效率</code>。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554979529525.png"
                        alt="1554979529525"
                 ></p>
<p>从函数定义的角度出发，我们可以将函数分成<code>内置函数</code>和<code>自定义函数</code>。在 SQL 语言中，同样也包括了内置函数和自定义函数。内置函数是系统内置的通用函数，而自定义函数是我们根据自己的需要编写的，本章及下一章讲解的是 SQL 的内置函数。</p>
<h3 id="1-2-不同DBMS函数的差异"><a href="#1-2-不同DBMS函数的差异" class="headerlink" title="1.2 不同DBMS函数的差异"></a>1.2 不同DBMS函数的差异</h3><p>我们在使用 SQL 语言的时候，不是直接和这门语言打交道，而是通过它使用不同的数据库软件，即 DBMS。<strong>DBMS 之间的差异性很大，远大于同一个语言不同版本之间的差异。<strong>实际上，只有很少的函数是被 DBMS 同时支持的。比如，大多数 DBMS 使用（||）或者（+）来做拼接符，而在 MySQL 中的字符串拼接函数为concat()。大部分 DBMS 会有自己特定的函数，这就意味着</strong>采用 SQL 函数的代码可移植性是很差的</strong>，因此在使用函数的时候需要特别注意。</p>
<h3 id="1-3-MySQL的内置函数及分类"><a href="#1-3-MySQL的内置函数及分类" class="headerlink" title="1.3 MySQL的内置函数及分类"></a>1.3 MySQL的内置函数及分类</h3><p>MySQL提供了丰富的内置函数，这些函数使得数据的维护与管理更加方便，能够更好地提供数据的分析与统计功能，在一定程度上提高了开发人员进行数据分析与统计的效率。</p>
<p>MySQL提供的内置函数从<code>实现的功能角度</code>可以分为数值函数、字符串函数、日期和时间函数、流程控制函数、加密与解密函数、获取MySQL信息函数、聚合函数等。这里，我将这些丰富的内置函数再分为两类：<code>单行函数</code>、<code>聚合函数（或分组函数）</code>。</p>
<p><strong>两种SQL函数</strong></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1555433204337.png"
                        alt="1555433204337"
                 ></p>
<p><strong>单行函数</strong></p>
<ul>
<li>操作数据对象</li>
<li>接受参数返回一个结果</li>
<li><strong>只对一行进行变换</strong></li>
<li><strong>每行返回一个结果</strong></li>
<li>可以嵌套</li>
<li>参数可以是一列或一个值</li>
</ul>
<h2 id="2-数值函数"><a href="#2-数值函数" class="headerlink" title="2. 数值函数"></a>2. 数值函数</h2><h3 id="2-1-基本函数"><a href="#2-1-基本函数" class="headerlink" title="2.1 基本函数"></a>2.1 基本函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>ABS(x)</td>
<td>返回x的绝对值</td>
</tr>
<tr>
<td>SIGN(X)</td>
<td>返回X的符号。正数返回1，负数返回-1，0返回0</td>
</tr>
<tr>
<td>PI()</td>
<td>返回圆周率的值</td>
</tr>
<tr>
<td>CEIL(x)，CEILING(x)</td>
<td>返回大于或等于某个值的最小整数</td>
</tr>
<tr>
<td>FLOOR(x)</td>
<td>返回小于或等于某个值的最大整数</td>
</tr>
<tr>
<td>LEAST(e1,e2,e3…)</td>
<td>返回列表中的最小值</td>
</tr>
<tr>
<td>GREATEST(e1,e2,e3…)</td>
<td>返回列表中的最大值</td>
</tr>
<tr>
<td>MOD(x,y)</td>
<td>返回X除以Y后的余数</td>
</tr>
<tr>
<td>RAND()</td>
<td>返回0~1的随机值</td>
</tr>
<tr>
<td>RAND(x)</td>
<td>返回0~1的随机值，其中x的值用作种子值，相同的X值会产生相同的随机数</td>
</tr>
<tr>
<td>ROUND(x)</td>
<td>返回一个对x的值进行四舍五入后，最接近于X的整数</td>
</tr>
<tr>
<td>ROUND(x,y)</td>
<td>返回一个对x的值进行四舍五入后最接近X的值，并保留到小数点后面Y位</td>
</tr>
<tr>
<td>TRUNCATE(x,y)</td>
<td>返回数字x截断为y位小数的结果</td>
</tr>
<tr>
<td>SQRT(x)</td>
<td>返回x的平方根。当X的值为负数时，返回NULL</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ABS(-123),ABS(32),SIGN(-23),SIGN(43),PI(),CEIL(32.32),CEILING(-43.23),FLOOR(32.32),</span><br><span class="line">FLOOR(-43.23),MOD(12,5)</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211025162304844.png"
                        alt="image-20211025162304844"
                 ></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT RAND(),RAND(),RAND(10),RAND(10),RAND(-1),RAND(-1)</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211025162538958.png"
                        alt="image-20211025162538958"
                 ></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ROUND(12.33),ROUND(12.343,2),ROUND(12.324,-1),TRUNCATE(12.66,1),TRUNCATE(12.66,-1)</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211025162730421.png"
                        alt="image-20211025162730421"
                 ></p>
<h3 id="2-2-角度与弧度互换函数"><a href="#2-2-角度与弧度互换函数" class="headerlink" title="2.2 角度与弧度互换函数"></a>2.2 角度与弧度互换函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>RADIANS(x)</td>
<td>将角度转化为弧度，其中，参数x为角度值</td>
</tr>
<tr>
<td>DEGREES(x)</td>
<td>将弧度转化为角度，其中，参数x为弧度值</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT RADIANS(30),RADIANS(60),RADIANS(90),DEGREES(2*PI()),DEGREES(RADIANS(90))</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure>



<h3 id="2-3-三角函数"><a href="#2-3-三角函数" class="headerlink" title="2.3 三角函数"></a>2.3 三角函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>SIN(x)</td>
<td>返回x的正弦值，其中，参数x为弧度值</td>
</tr>
<tr>
<td>ASIN(x)</td>
<td>返回x的反正弦值，即获取正弦为x的值。如果x的值不在-1到1之间，则返回NULL</td>
</tr>
<tr>
<td>COS(x)</td>
<td>返回x的余弦值，其中，参数x为弧度值</td>
</tr>
<tr>
<td>ACOS(x)</td>
<td>返回x的反余弦值，即获取余弦为x的值。如果x的值不在-1到1之间，则返回NULL</td>
</tr>
<tr>
<td>TAN(x)</td>
<td>返回x的正切值，其中，参数x为弧度值</td>
</tr>
<tr>
<td>ATAN(x)</td>
<td>返回x的反正切值，即返回正切值为x的值</td>
</tr>
<tr>
<td>ATAN2(m,n)</td>
<td>返回两个参数的反正切值</td>
</tr>
<tr>
<td>COT(x)</td>
<td>返回x的余切值，其中，X为弧度值</td>
</tr>
</tbody></table>
<p>举例：</p>
<p>ATAN2(M,N)函数返回两个参数的反正切值。<br>与ATAN(X)函数相比，ATAN2(M,N)需要两个参数，例如有两个点point(x1,y1)和point(x2,y2)，使用ATAN(X)函数计算反正切值为ATAN((y2-y1)&#x2F;(x2-x1))，使用ATAN2(M,N)计算反正切值则为ATAN2(y2-y1,x2-x1)。由使用方式可以看出，当x2-x1等于0时，ATAN(X)函数会报错，而ATAN2(M,N)函数则仍然可以计算。</p>
<p>ATAN2(M,N)函数的使用示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT SIN(RADIANS(30)),DEGREES(ASIN(1)),TAN(RADIANS(45)),DEGREES(ATAN(1)),DEGREES(ATAN2(1,1))</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211025163846974.png"
                        alt="image-20211025163846974"
                 ></p>
<h3 id="2-4-指数与对数"><a href="#2-4-指数与对数" class="headerlink" title="2.4 指数与对数"></a>2.4 指数与对数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>POW(x,y)，POWER(X,Y)</td>
<td>返回x的y次方</td>
</tr>
<tr>
<td>EXP(X)</td>
<td>返回e的X次方，其中e是一个常数，2.718281828459045</td>
</tr>
<tr>
<td>LN(X)，LOG(X)</td>
<td>返回以e为底的X的对数，当X &lt;&#x3D; 0 时，返回的结果为NULL</td>
</tr>
<tr>
<td>LOG10(X)</td>
<td>返回以10为底的X的对数，当X &lt;&#x3D; 0 时，返回的结果为NULL</td>
</tr>
<tr>
<td>LOG2(X)</td>
<td>返回以2为底的X的对数，当X &lt;&#x3D; 0 时，返回NULL</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT POW(2,5),POWER(2,4),EXP(2),LN(10),LOG10(10),LOG2(4)</span><br><span class="line">    -&gt; FROM DUAL;</span><br><span class="line">+----------+------------+------------------+-------------------+-----------+---------+</span><br><span class="line">| POW(2,5) | POWER(2,4) | EXP(2)           | LN(10)            | LOG10(10) | LOG2(4) |</span><br><span class="line">+----------+------------+------------------+-------------------+-----------+---------+</span><br><span class="line">|       32 |         16 | 7.38905609893065 | 2.302585092994046 |         1 |       2 |</span><br><span class="line">+----------+------------+------------------+-------------------+-----------+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="2-5-进制间的转换"><a href="#2-5-进制间的转换" class="headerlink" title="2.5 进制间的转换"></a>2.5 进制间的转换</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>BIN(x)</td>
<td>返回x的二进制编码</td>
</tr>
<tr>
<td>HEX(x)</td>
<td>返回x的十六进制编码</td>
</tr>
<tr>
<td>OCT(x)</td>
<td>返回x的八进制编码</td>
</tr>
<tr>
<td>CONV(x,f1,f2)</td>
<td>返回f1进制数变成f2进制数</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT BIN(10),HEX(10),OCT(10),CONV(10,2,8)</span><br><span class="line">    -&gt; FROM DUAL;</span><br><span class="line">+---------+---------+---------+--------------+</span><br><span class="line">| BIN(10) | HEX(10) | OCT(10) | CONV(10,2,8) |</span><br><span class="line">+---------+---------+---------+--------------+</span><br><span class="line">| 1010    | A       | 12      | 2            |</span><br><span class="line">+---------+---------+---------+--------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="3-字符串函数"><a href="#3-字符串函数" class="headerlink" title="3. 字符串函数"></a>3. 字符串函数</h2><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>ASCII(S)</td>
<td>返回字符串S中的第一个字符的ASCII码值</td>
</tr>
<tr>
<td>CHAR_LENGTH(s)</td>
<td>返回字符串s的字符数。作用与CHARACTER_LENGTH(s)相同</td>
</tr>
<tr>
<td>LENGTH(s)</td>
<td>返回字符串s的字节数，和字符集有关</td>
</tr>
<tr>
<td>CONCAT(s1,s2,……,sn)</td>
<td>连接s1,s2,……,sn为一个字符串</td>
</tr>
<tr>
<td>CONCAT_WS(x, s1,s2,……,sn)</td>
<td>同CONCAT(s1,s2,…)函数，但是每个字符串之间要加上x</td>
</tr>
<tr>
<td>INSERT(str, idx, len, replacestr)</td>
<td>将字符串str从第idx位置开始，len个字符长的子串替换为字符串replacestr</td>
</tr>
<tr>
<td>REPLACE(str, a, b)</td>
<td>用字符串b替换字符串str中所有出现的字符串a</td>
</tr>
<tr>
<td>UPPER(s) 或 UCASE(s)</td>
<td>将字符串s的所有字母转成大写字母</td>
</tr>
<tr>
<td>LOWER(s)  或LCASE(s)</td>
<td>将字符串s的所有字母转成小写字母</td>
</tr>
<tr>
<td>LEFT(str,n)</td>
<td>返回字符串str最左边的n个字符</td>
</tr>
<tr>
<td>RIGHT(str,n)</td>
<td>返回字符串str最右边的n个字符</td>
</tr>
<tr>
<td>LPAD(str, len, pad)</td>
<td>用字符串pad对str最左边进行填充，直到str的长度为len个字符</td>
</tr>
<tr>
<td>RPAD(str ,len, pad)</td>
<td>用字符串pad对str最右边进行填充，直到str的长度为len个字符</td>
</tr>
<tr>
<td>LTRIM(s)</td>
<td>去掉字符串s左侧的空格</td>
</tr>
<tr>
<td>RTRIM(s)</td>
<td>去掉字符串s右侧的空格</td>
</tr>
<tr>
<td>TRIM(s)</td>
<td>去掉字符串s开始与结尾的空格</td>
</tr>
<tr>
<td>TRIM(s1 FROM s)</td>
<td>去掉字符串s开始与结尾的s1</td>
</tr>
<tr>
<td>TRIM(LEADING s1 FROM s)</td>
<td>去掉字符串s开始处的s1</td>
</tr>
<tr>
<td>TRIM(TRAILING s1 FROM s)</td>
<td>去掉字符串s结尾处的s1</td>
</tr>
<tr>
<td>REPEAT(str, n)</td>
<td>返回str重复n次的结果</td>
</tr>
<tr>
<td>SPACE(n)</td>
<td>返回n个空格</td>
</tr>
<tr>
<td>STRCMP(s1,s2)</td>
<td>比较字符串s1,s2的ASCII码值的大小</td>
</tr>
<tr>
<td>SUBSTR(s,index,len)</td>
<td>返回从字符串s的index位置其len个字符，作用与SUBSTRING(s,n,len)、MID(s,n,len)相同</td>
</tr>
<tr>
<td>LOCATE(substr,str)</td>
<td>返回字符串substr在字符串str中首次出现的位置，作用于POSITION(substr IN str)、INSTR(str,substr)相同。未找到，返回0</td>
</tr>
<tr>
<td>ELT(m,s1,s2,…,sn)</td>
<td>返回指定位置的字符串，如果m&#x3D;1，则返回s1，如果m&#x3D;2，则返回s2，如果m&#x3D;n，则返回sn</td>
</tr>
<tr>
<td>FIELD(s,s1,s2,…,sn)</td>
<td>返回字符串s在字符串列表中第一次出现的位置</td>
</tr>
<tr>
<td>FIND_IN_SET(s1,s2)</td>
<td>返回字符串s1在字符串s2中出现的位置。其中，字符串s2是一个以逗号分隔的字符串</td>
</tr>
<tr>
<td>REVERSE(s)</td>
<td>返回s反转后的字符串</td>
</tr>
<tr>
<td>NULLIF(value1,value2)</td>
<td>比较两个字符串，如果value1与value2相等，则返回NULL，否则返回value1</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：MySQL中，字符串的位置是从1开始的。</p>
</blockquote>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT FIELD(&#x27;mm&#x27;,&#x27;hello&#x27;,&#x27;msm&#x27;,&#x27;amma&#x27;),FIND_IN_SET(&#x27;mm&#x27;,&#x27;hello,mm,amma&#x27;)</span><br><span class="line">    -&gt; FROM DUAL;</span><br><span class="line">+----------------------------------+-----------------------------------+</span><br><span class="line">| FIELD(&#x27;mm&#x27;,&#x27;hello&#x27;,&#x27;msm&#x27;,&#x27;amma&#x27;) | FIND_IN_SET(&#x27;mm&#x27;,&#x27;hello,mm,amma&#x27;) |</span><br><span class="line">+----------------------------------+-----------------------------------+</span><br><span class="line">|                                0 |                                 2 |</span><br><span class="line">+----------------------------------+-----------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT NULLIF(&#x27;mysql&#x27;,&#x27;mysql&#x27;),NULLIF(&#x27;mysql&#x27;, &#x27;&#x27;);</span><br><span class="line">+-------------------------+---------------------+</span><br><span class="line">| NULLIF(&#x27;mysql&#x27;,&#x27;mysql&#x27;) | NULLIF(&#x27;mysql&#x27;, &#x27;&#x27;) |</span><br><span class="line">+-------------------------+---------------------+</span><br><span class="line">| NULL                    | mysql               |</span><br><span class="line">+-------------------------+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="4-日期和时间函数"><a href="#4-日期和时间函数" class="headerlink" title="4. 日期和时间函数"></a>4. 日期和时间函数</h2><h3 id="4-1-获取日期、时间"><a href="#4-1-获取日期、时间" class="headerlink" title="4.1 获取日期、时间"></a>4.1 获取日期、时间</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CURDATE()</strong> ，CURRENT_DATE()</td>
<td>返回当前日期，只包含年、月、日</td>
</tr>
<tr>
<td><strong>CURTIME()</strong> ， CURRENT_TIME()</td>
<td>返回当前时间，只包含时、分、秒</td>
</tr>
<tr>
<td><strong>NOW()</strong> &#x2F; SYSDATE() &#x2F; CURRENT_TIMESTAMP() &#x2F; LOCALTIME() &#x2F; LOCALTIMESTAMP()</td>
<td>返回当前系统日期和时间</td>
</tr>
<tr>
<td>UTC_DATE()</td>
<td>返回UTC（世界标准时间）日期</td>
</tr>
<tr>
<td>UTC_TIME()</td>
<td>返回UTC（世界标准时间）时间</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT CURDATE(),CURTIME(),NOW(),SYSDATE()+0,UTC_DATE(),UTC_DATE()+0,UTC_TIME(),UTC_TIME()+0</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211025193742633.png"
                        alt="image-20211025193742633"
                 ></p>
<h3 id="4-2-日期与时间戳的转换"><a href="#4-2-日期与时间戳的转换" class="headerlink" title="4.2 日期与时间戳的转换"></a>4.2 日期与时间戳的转换</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>UNIX_TIMESTAMP()</td>
<td>以UNIX时间戳的形式返回当前时间。SELECT UNIX_TIMESTAMP() -&gt;1634348884</td>
</tr>
<tr>
<td>UNIX_TIMESTAMP(date)</td>
<td>将时间date以UNIX时间戳的形式返回。</td>
</tr>
<tr>
<td>FROM_UNIXTIME(timestamp)</td>
<td>将UNIX时间戳的时间转换为普通格式的时间</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT UNIX_TIMESTAMP(now());</span><br><span class="line">+-----------------------+</span><br><span class="line">| UNIX_TIMESTAMP(now()) |</span><br><span class="line">+-----------------------+</span><br><span class="line">|            1576380910 |</span><br><span class="line">+-----------------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT UNIX_TIMESTAMP(CURDATE());</span><br><span class="line">+---------------------------+</span><br><span class="line">| UNIX_TIMESTAMP(CURDATE()) |</span><br><span class="line">+---------------------------+</span><br><span class="line">|                1576339200 |</span><br><span class="line">+---------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT UNIX_TIMESTAMP(CURTIME());</span><br><span class="line">+---------------------------+</span><br><span class="line">| UNIX_TIMESTAMP(CURTIME()) |</span><br><span class="line">+---------------------------+</span><br><span class="line">|                1576380969 |</span><br><span class="line">+---------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT UNIX_TIMESTAMP(&#x27;2011-11-11 11:11:11&#x27;)</span><br><span class="line">+---------------------------------------+</span><br><span class="line">| UNIX_TIMESTAMP(&#x27;2011-11-11 11:11:11&#x27;) |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">|                            1320981071 |</span><br><span class="line">+---------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT FROM_UNIXTIME(1576380910);</span><br><span class="line">+---------------------------+</span><br><span class="line">| FROM_UNIXTIME(1576380910) |</span><br><span class="line">+---------------------------+</span><br><span class="line">| 2019-12-15 11:35:10       |</span><br><span class="line">+---------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="4-3-获取月份、星期、星期数、天数等函数"><a href="#4-3-获取月份、星期、星期数、天数等函数" class="headerlink" title="4.3 获取月份、星期、星期数、天数等函数"></a>4.3 获取月份、星期、星期数、天数等函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR(date) &#x2F; MONTH(date) &#x2F; DAY(date)</td>
<td>返回具体的日期值</td>
</tr>
<tr>
<td>HOUR(time) &#x2F; MINUTE(time) &#x2F; SECOND(time)</td>
<td>返回具体的时间值</td>
</tr>
<tr>
<td>MONTHNAME(date)</td>
<td>返回月份：January，…</td>
</tr>
<tr>
<td>DAYNAME(date)</td>
<td>返回星期几：MONDAY，TUESDAY…..SUNDAY</td>
</tr>
<tr>
<td>WEEKDAY(date)</td>
<td>返回周几，注意，周1是0，周2是1，。。。周日是6</td>
</tr>
<tr>
<td>QUARTER(date)</td>
<td>返回日期对应的季度，范围为1～4</td>
</tr>
<tr>
<td>WEEK(date) ， WEEKOFYEAR(date)</td>
<td>返回一年中的第几周</td>
</tr>
<tr>
<td>DAYOFYEAR(date)</td>
<td>返回日期是一年中的第几天</td>
</tr>
<tr>
<td>DAYOFMONTH(date)</td>
<td>返回日期位于所在月份的第几天</td>
</tr>
<tr>
<td>DAYOFWEEK(date)</td>
<td>返回周几，注意：周日是1，周一是2，。。。周六是7</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT YEAR(CURDATE()),MONTH(CURDATE()),DAY(CURDATE()),</span><br><span class="line">HOUR(CURTIME()),MINUTE(NOW()),SECOND(SYSDATE())</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211025213504115.png"
                        alt="image-20211025213504115"
                 ></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT MONTHNAME(&#x27;2021-10-26&#x27;),DAYNAME(&#x27;2021-10-26&#x27;),WEEKDAY(&#x27;2021-10-26&#x27;),</span><br><span class="line">QUARTER(CURDATE()),WEEK(CURDATE()),DAYOFYEAR(NOW()),</span><br><span class="line">DAYOFMONTH(NOW()),DAYOFWEEK(NOW())</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211025214818623.png"
                        alt="image-20211025214818623"
                 ></p>
<h3 id="4-4-日期的操作函数"><a href="#4-4-日期的操作函数" class="headerlink" title="4.4 日期的操作函数"></a>4.4 日期的操作函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>EXTRACT(type FROM date)</td>
<td>返回指定日期中特定的部分，type指定返回的值</td>
</tr>
</tbody></table>
<p>EXTRACT(type FROM date)函数中type的取值与含义：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211012142639469.png"
                        alt="image-20211012142639469"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211012142746444.png"
                        alt="image-20211012142746444"
                 ></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT EXTRACT(MINUTE FROM NOW()),EXTRACT( WEEK FROM NOW()),</span><br><span class="line">EXTRACT( QUARTER FROM NOW()),EXTRACT( MINUTE_SECOND FROM NOW())</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-时间和秒钟转换的函数"><a href="#4-5-时间和秒钟转换的函数" class="headerlink" title="4.5 时间和秒钟转换的函数"></a>4.5 时间和秒钟转换的函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>TIME_TO_SEC(time)</td>
<td>将 time 转化为秒并返回结果值。转化的公式为：<code>小时*3600+分钟*60+秒</code></td>
</tr>
<tr>
<td>SEC_TO_TIME(seconds)</td>
<td>将 seconds 描述转化为包含小时、分钟和秒的时间</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT TIME_TO_SEC(NOW());</span><br><span class="line">+--------------------+</span><br><span class="line">| TIME_TO_SEC(NOW()) |</span><br><span class="line">+--------------------+</span><br><span class="line">|               78774 |</span><br><span class="line">+--------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT SEC_TO_TIME(78774);</span><br><span class="line">+--------------------+</span><br><span class="line">| SEC_TO_TIME(78774) |</span><br><span class="line">+--------------------+</span><br><span class="line">| 21:52:54            |</span><br><span class="line">+--------------------+</span><br><span class="line">1 row in set (0.12 sec)</span><br></pre></td></tr></table></figure>

<h3 id="4-6-计算日期和时间的函数"><a href="#4-6-计算日期和时间的函数" class="headerlink" title="4.6 计算日期和时间的函数"></a>4.6 计算日期和时间的函数</h3><p><strong>第1组：</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>DATE_ADD(datetime, INTERVAL  expr type)，ADDDATE(date,INTERVAL expr type)</td>
<td>返回与给定日期时间相差INTERVAL时间段的日期时间</td>
</tr>
<tr>
<td>DATE_SUB(date,INTERVAL expr type)，SUBDATE(date,INTERVAL expr type)</td>
<td>返回与date相差INTERVAL时间间隔的日期</td>
</tr>
</tbody></table>
<p>上述函数中type的取值：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211012143203355.png"
                        alt="image-20211012143203355"
                 ></p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DATE_ADD(NOW(), INTERVAL 1 DAY) AS col1,DATE_ADD(&#x27;2021-10-21 23:32:12&#x27;,INTERVAL 1 SECOND) AS col2,</span><br><span class="line">ADDDATE(&#x27;2021-10-21 23:32:12&#x27;,INTERVAL 1 SECOND) AS col3,</span><br><span class="line">DATE_ADD(&#x27;2021-10-21 23:32:12&#x27;,INTERVAL &#x27;1_1&#x27; MINUTE_SECOND) AS col4,</span><br><span class="line">DATE_ADD(NOW(), INTERVAL -1 YEAR) AS col5, #可以是负数</span><br><span class="line">DATE_ADD(NOW(), INTERVAL &#x27;1_1&#x27; YEAR_MONTH) AS col6 #需要单引号</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DATE_SUB(&#x27;2021-01-21&#x27;,INTERVAL 31 DAY) AS col1,</span><br><span class="line">SUBDATE(&#x27;2021-01-21&#x27;,INTERVAL 31 DAY) AS col2,</span><br><span class="line">DATE_SUB(&#x27;2021-01-21 02:01:01&#x27;,INTERVAL &#x27;1 1&#x27; DAY_HOUR) AS col3</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure>

<p><strong>第2组：</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>ADDTIME(time1,time2)</td>
<td>返回time1加上time2的时间。当time2为一个数字时，代表的是<code>秒</code>，可以为负数</td>
</tr>
<tr>
<td>SUBTIME(time1,time2)</td>
<td>返回time1减去time2后的时间。当time2为一个数字时，代表的是<code>秒</code>，可以为负数</td>
</tr>
<tr>
<td>DATEDIFF(date1,date2)</td>
<td>返回date1 - date2的日期间隔天数</td>
</tr>
<tr>
<td>TIMEDIFF(time1, time2)</td>
<td>返回time1 - time2的时间间隔</td>
</tr>
<tr>
<td>FROM_DAYS(N)</td>
<td>返回从0000年1月1日起，N天以后的日期</td>
</tr>
<tr>
<td>TO_DAYS(date)</td>
<td>返回日期date距离0000年1月1日的天数</td>
</tr>
<tr>
<td>LAST_DAY(date)</td>
<td>返回date所在月份的最后一天的日期</td>
</tr>
<tr>
<td>MAKEDATE(year,n)</td>
<td>针对给定年份与所在年份中的天数返回一个日期</td>
</tr>
<tr>
<td>MAKETIME(hour,minute,second)</td>
<td>将给定的小时、分钟和秒组合成时间并返回</td>
</tr>
<tr>
<td>PERIOD_ADD(time,n)</td>
<td>返回time加上n后的时间</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ADDTIME(NOW(),20),SUBTIME(NOW(),30),SUBTIME(NOW(),&#x27;1:1:3&#x27;),DATEDIFF(NOW(),&#x27;2021-10-01&#x27;),</span><br><span class="line">TIMEDIFF(NOW(),&#x27;2021-10-25 22:10:10&#x27;),FROM_DAYS(366),TO_DAYS(&#x27;0000-12-25&#x27;),</span><br><span class="line">LAST_DAY(NOW()),MAKEDATE(YEAR(NOW()),12),MAKETIME(10,21,23),PERIOD_ADD(20200101010101,10)</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT ADDTIME(NOW(), 50);</span><br><span class="line">+---------------------+</span><br><span class="line">| ADDTIME(NOW(), 50)  |</span><br><span class="line">+---------------------+</span><br><span class="line">| 2019-12-15 22:17:47 |</span><br><span class="line">+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT ADDTIME(NOW(), &#x27;1:1:1&#x27;);</span><br><span class="line">+-------------------------+</span><br><span class="line">| ADDTIME(NOW(), &#x27;1:1:1&#x27;) |</span><br><span class="line">+-------------------------+</span><br><span class="line">| 2019-12-15 23:18:46     |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT SUBTIME(NOW(), &#x27;1:1:1&#x27;);</span><br><span class="line">+-------------------------+</span><br><span class="line">| SUBTIME(NOW(), &#x27;1:1:1&#x27;) |</span><br><span class="line">+-------------------------+</span><br><span class="line">| 2019-12-15 21:23:50     |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT SUBTIME(NOW(), &#x27;-1:-1:-1&#x27;); </span><br><span class="line">+----------------------------+</span><br><span class="line">| SUBTIME(NOW(), &#x27;-1:-1:-1&#x27;) |</span><br><span class="line">+----------------------------+</span><br><span class="line">| 2019-12-15 22:25:11        |</span><br><span class="line">+----------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT FROM_DAYS(366);</span><br><span class="line">+----------------+</span><br><span class="line">| FROM_DAYS(366) |</span><br><span class="line">+----------------+</span><br><span class="line">| 0001-01-01     |</span><br><span class="line">+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT MAKEDATE(2020,1);</span><br><span class="line">+------------------+</span><br><span class="line">| MAKEDATE(2020,1) |</span><br><span class="line">+------------------+</span><br><span class="line">| 2020-01-01       |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT MAKEDATE(2020,32);</span><br><span class="line">+-------------------+</span><br><span class="line">| MAKEDATE(2020,32) |</span><br><span class="line">+-------------------+</span><br><span class="line">| 2020-02-01        |</span><br><span class="line">+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT MAKETIME(1,1,1);</span><br><span class="line">+-----------------+</span><br><span class="line">| MAKETIME(1,1,1) |</span><br><span class="line">+-----------------+</span><br><span class="line">| 01:01:01        |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT PERIOD_ADD(20200101010101,1);</span><br><span class="line">+------------------------------+</span><br><span class="line">| PERIOD_ADD(20200101010101,1) |</span><br><span class="line">+------------------------------+</span><br><span class="line">|               20200101010102 |</span><br><span class="line">+------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT TO_DAYS(NOW());</span><br><span class="line">+----------------+</span><br><span class="line">| TO_DAYS(NOW()) |</span><br><span class="line">+----------------+</span><br><span class="line">|          737773 |</span><br><span class="line">+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>举例：查询 7 天内的新增用户数有多少？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*) as num FROM new_user WHERE TO_DAYS(NOW())-TO_DAYS(regist_time)&lt;=7</span><br></pre></td></tr></table></figure>

<h3 id="4-7-日期的格式化与解析"><a href="#4-7-日期的格式化与解析" class="headerlink" title="4.7 日期的格式化与解析"></a>4.7 日期的格式化与解析</h3><table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>DATE_FORMAT(date,fmt)</td>
<td>按照字符串fmt格式化日期date值</td>
</tr>
<tr>
<td>TIME_FORMAT(time,fmt)</td>
<td>按照字符串fmt格式化时间time值</td>
</tr>
<tr>
<td>GET_FORMAT(date_type,format_type)</td>
<td>返回日期字符串的显示格式</td>
</tr>
<tr>
<td>STR_TO_DATE(str, fmt)</td>
<td>按照字符串fmt对str进行解析，解析为一个日期</td>
</tr>
</tbody></table>
<p>上述<code>非GET_FORMAT</code>函数中fmt参数常用的格式符：</p>
<table>
<thead>
<tr>
<th>格式符</th>
<th>说明</th>
<th>格式符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%Y</td>
<td>4位数字表示年份</td>
<td>%y</td>
<td>表示两位数字表示年份</td>
</tr>
<tr>
<td>%M</td>
<td>月名表示月份（January,….）</td>
<td>%m</td>
<td>两位数字表示月份（01,02,03。。。）</td>
</tr>
<tr>
<td>%b</td>
<td>缩写的月名（Jan.，Feb.，….）</td>
<td>%c</td>
<td>数字表示月份（1,2,3,…）</td>
</tr>
<tr>
<td>%D</td>
<td>英文后缀表示月中的天数（1st,2nd,3rd,…）</td>
<td>%d</td>
<td>两位数字表示月中的天数(01,02…)</td>
</tr>
<tr>
<td>%e</td>
<td>数字形式表示月中的天数（1,2,3,4,5…..）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>%H</td>
<td>两位数字表示小数，24小时制（01,02..）</td>
<td>%h和%I</td>
<td>两位数字表示小时，12小时制（01,02..）</td>
</tr>
<tr>
<td>%k</td>
<td>数字形式的小时，24小时制(1,2,3)</td>
<td>%l</td>
<td>数字形式表示小时，12小时制（1,2,3,4….）</td>
</tr>
<tr>
<td>%i</td>
<td>两位数字表示分钟（00,01,02）</td>
<td>%S和%s</td>
<td>两位数字表示秒(00,01,02…)</td>
</tr>
<tr>
<td>%W</td>
<td>一周中的星期名称（Sunday…）</td>
<td>%a</td>
<td>一周中的星期缩写（Sun.，Mon.,Tues.，..）</td>
</tr>
<tr>
<td>%w</td>
<td>以数字表示周中的天数(0&#x3D;Sunday,1&#x3D;Monday….)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>%j</td>
<td>以3位数字表示年中的天数(001,002…)</td>
<td>%U</td>
<td>以数字表示年中的第几周，（1,2,3。。）其中Sunday为周中第一天</td>
</tr>
<tr>
<td>%u</td>
<td>以数字表示年中的第几周，（1,2,3。。）其中Monday为周中第一天</td>
<td></td>
<td></td>
</tr>
<tr>
<td>%T</td>
<td>24小时制</td>
<td>%r</td>
<td>12小时制</td>
</tr>
<tr>
<td>%p</td>
<td>AM或PM</td>
<td>%%</td>
<td>表示%</td>
</tr>
</tbody></table>
<p>GET_FORMAT函数中date_type和format_type参数取值如下：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211012145231321.png"
                        alt="image-20211012145231321"
                 ></p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT DATE_FORMAT(NOW(), &#x27;%H:%i:%s&#x27;);</span><br><span class="line">+--------------------------------+</span><br><span class="line">| DATE_FORMAT(NOW(), &#x27;%H:%i:%s&#x27;) |</span><br><span class="line">+--------------------------------+</span><br><span class="line">| 22:57:34                        |</span><br><span class="line">+--------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT STR_TO_DATE(&#x27;09/01/2009&#x27;,&#x27;%m/%d/%Y&#x27;)</span><br><span class="line">FROM DUAL;</span><br><span class="line"></span><br><span class="line">SELECT STR_TO_DATE(&#x27;20140422154706&#x27;,&#x27;%Y%m%d%H%i%s&#x27;)</span><br><span class="line">FROM DUAL;</span><br><span class="line"></span><br><span class="line">SELECT STR_TO_DATE(&#x27;2014-04-22 15:47:06&#x27;,&#x27;%Y-%m-%d %H:%i:%s&#x27;)</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT GET_FORMAT(DATE, &#x27;USA&#x27;);</span><br><span class="line">+-------------------------+</span><br><span class="line">| GET_FORMAT(DATE, &#x27;USA&#x27;) |</span><br><span class="line">+-------------------------+</span><br><span class="line">| %m.%d.%Y                |</span><br><span class="line">+-------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">SELECT DATE_FORMAT(NOW(),GET_FORMAT(DATE,&#x27;USA&#x27;)),</span><br><span class="line">FROM DUAL;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT STR_TO_DATE(&#x27;2020-01-01 00:00:00&#x27;,&#x27;%Y-%m-%d&#x27;); </span><br><span class="line">+-----------------------------------------------+</span><br><span class="line">| STR_TO_DATE(&#x27;2020-01-01 00:00:00&#x27;,&#x27;%Y-%m-%d&#x27;) |</span><br><span class="line">+-----------------------------------------------+</span><br><span class="line">| 2020-01-01                                    |</span><br><span class="line">+-----------------------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="5-流程控制函数"><a href="#5-流程控制函数" class="headerlink" title="5. 流程控制函数"></a>5. 流程控制函数</h2><p>流程处理函数可以根据不同的条件，执行不同的处理流程，可以在SQL语句中实现不同的条件选择。MySQL中的流程处理函数主要包括IF()、IFNULL()和CASE()函数。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>IF(value,value1,value2)</td>
<td>如果value的值为TRUE，返回value1，否则返回value2</td>
</tr>
<tr>
<td>IFNULL(value1, value2)</td>
<td>如果value1不为NULL，返回value1，否则返回value2</td>
</tr>
<tr>
<td>CASE WHEN 条件1 THEN 结果1 WHEN 条件2 THEN 结果2 …. [ELSE resultn] END</td>
<td>相当于Java的if…else if…else…</td>
</tr>
<tr>
<td>CASE  expr WHEN 常量值1 THEN 值1 WHEN 常量值1 THEN 值1 …. [ELSE 值n] END</td>
<td>相当于Java的switch…case…</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT IF(1 &gt; 0,&#x27;正确&#x27;,&#x27;错误&#x27;)    </span><br><span class="line">-&gt;正确</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT IFNULL(null,&#x27;Hello Word&#x27;)</span><br><span class="line">-&gt;Hello Word</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT CASE </span><br><span class="line">　　WHEN 1 &gt; 0</span><br><span class="line">　　THEN &#x27;1 &gt; 0&#x27;</span><br><span class="line">　　WHEN 2 &gt; 0</span><br><span class="line">　　THEN &#x27;2 &gt; 0&#x27;</span><br><span class="line">　　ELSE &#x27;3 &gt; 0&#x27;</span><br><span class="line">　　END</span><br><span class="line">-&gt;1 &gt; 0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT CASE 1 </span><br><span class="line">　　WHEN 1 THEN &#x27;我是1&#x27;</span><br><span class="line">　　WHEN 2 THEN &#x27;我是2&#x27;</span><br><span class="line">ELSE &#x27;你是谁&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id,salary, CASE WHEN salary&gt;=15000 THEN &#x27;高薪&#x27; </span><br><span class="line">				  WHEN salary&gt;=10000 THEN &#x27;潜力股&#x27;  </span><br><span class="line">				  WHEN salary&gt;=8000 THEN &#x27;屌丝&#x27; </span><br><span class="line">				  ELSE &#x27;草根&#x27; END  &quot;描述&quot;</span><br><span class="line">FROM employees; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT oid,`status`, CASE `status` WHEN 1 THEN &#x27;未付款&#x27; </span><br><span class="line">								   WHEN 2 THEN &#x27;已付款&#x27; </span><br><span class="line">								   WHEN 3 THEN &#x27;已发货&#x27;  </span><br><span class="line">								   WHEN 4 THEN &#x27;确认收货&#x27;  </span><br><span class="line">								   ELSE &#x27;无效订单&#x27; END </span><br><span class="line">FROM t_order;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT CASE WHEN 1 &gt; 0 THEN &#x27;yes&#x27; WHEN 1 &lt;= 0 THEN &#x27;no&#x27; ELSE &#x27;unknown&#x27; END;</span><br><span class="line">+---------------------------------------------------------------------+</span><br><span class="line">| CASE WHEN 1 &gt; 0 THEN &#x27;yes&#x27; WHEN 1 &lt;= 0 THEN &#x27;no&#x27; ELSE &#x27;unknown&#x27; END |</span><br><span class="line">+---------------------------------------------------------------------+</span><br><span class="line">| yes                                                                  |</span><br><span class="line">+---------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT CASE WHEN 1 &lt; 0 THEN &#x27;yes&#x27; WHEN 1 = 0 THEN &#x27;no&#x27; ELSE &#x27;unknown&#x27; END;  </span><br><span class="line">+--------------------------------------------------------------------+</span><br><span class="line">| CASE WHEN 1 &lt; 0 THEN &#x27;yes&#x27; WHEN 1 = 0 THEN &#x27;no&#x27; ELSE &#x27;unknown&#x27; END |</span><br><span class="line">+--------------------------------------------------------------------+</span><br><span class="line">| unknown                                                             |</span><br><span class="line">+--------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT CASE 1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE -1 END;</span><br><span class="line">+------------------------------------------------+</span><br><span class="line">| CASE 1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE -1 END |</span><br><span class="line">+------------------------------------------------+</span><br><span class="line">|                                               1 |</span><br><span class="line">+------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT CASE -1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE -1 END;</span><br><span class="line">+-------------------------------------------------+</span><br><span class="line">| CASE -1 WHEN 0 THEN 0 WHEN 1 THEN 1 ELSE -1 END |</span><br><span class="line">+-------------------------------------------------+</span><br><span class="line">|                                               -1 |</span><br><span class="line">+-------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id,12 * salary * (1 + IFNULL(commission_pct,0))</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last_name, job_id, salary,</span><br><span class="line">       CASE job_id WHEN &#x27;IT_PROG&#x27;  THEN  1.10*salary</span><br><span class="line">                   WHEN &#x27;ST_CLERK&#x27; THEN  1.15*salary</span><br><span class="line">                   WHEN &#x27;SA_REP&#x27;   THEN  1.20*salary</span><br><span class="line">       			   ELSE      salary END     &quot;REVISED_SALARY&quot;</span><br><span class="line">FROM   employees;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554980865631.png"
                        alt="1554980865631"
                 ></p>
<p><strong>练习：查询部门号为 10,20, 30 的员工信息, 若部门号为 10, 则打印其工资的 1.1 倍, 20 号部门, 则打印其工资的 1.2 倍, 30 号部门打印其工资的 1.3 倍数。</strong></p>
<h2 id="6-加密与解密函数"><a href="#6-加密与解密函数" class="headerlink" title="6. 加密与解密函数"></a>6. 加密与解密函数</h2><p>加密与解密函数主要用于对数据库中的数据进行加密和解密处理，以防止数据被他人窃取。这些函数在保证数据库安全时非常有用。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>PASSWORD(str)</td>
<td>返回字符串str的加密版本，41位长的字符串。加密结果<code>不可逆</code>，常用于用户的密码加密</td>
</tr>
<tr>
<td>MD5(str)</td>
<td>返回字符串str的md5加密后的值，也是一种加密方式。若参数为NULL，则会返回NULL</td>
</tr>
<tr>
<td>SHA(str)</td>
<td>从原明文密码str计算并返回加密后的密码字符串，当参数为NULL时，返回NULL。<code>SHA加密算法比MD5更加安全</code>。</td>
</tr>
<tr>
<td>ENCODE(value,password_seed)</td>
<td>返回使用password_seed作为加密密码加密value</td>
</tr>
<tr>
<td>DECODE(value,password_seed)</td>
<td>返回使用password_seed作为加密密码解密value</td>
</tr>
</tbody></table>
<p>可以看到，ENCODE(value,password_seed)函数与DECODE(value,password_seed)函数互为反函数。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT PASSWORD(&#x27;mysql&#x27;), PASSWORD(NULL);</span><br><span class="line">+-------------------------------------------+----------------+</span><br><span class="line">| PASSWORD(&#x27;mysql&#x27;)                         | PASSWORD(NULL) |</span><br><span class="line">+-------------------------------------------+----------------+</span><br><span class="line">| *E74858DB86EBA20BC33D0AECAE8A8108C56B17FA |                |</span><br><span class="line">+-------------------------------------------+----------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT md5(&#x27;123&#x27;)</span><br><span class="line">-&gt;202cb962ac59075b964b07152d234b70</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT SHA(&#x27;Tom123&#x27;)</span><br><span class="line">-&gt;c7c506980abc31cc390a2438c90861d0f1216d50</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT ENCODE(&#x27;mysql&#x27;, &#x27;mysql&#x27;);</span><br><span class="line">+--------------------------+</span><br><span class="line">| ENCODE(&#x27;mysql&#x27;, &#x27;mysql&#x27;) |</span><br><span class="line">+--------------------------+</span><br><span class="line">| íg　¼　ìÉ                  |</span><br><span class="line">+--------------------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT DECODE(ENCODE(&#x27;mysql&#x27;,&#x27;mysql&#x27;),&#x27;mysql&#x27;);</span><br><span class="line">+-----------------------------------------+</span><br><span class="line">| DECODE(ENCODE(&#x27;mysql&#x27;,&#x27;mysql&#x27;),&#x27;mysql&#x27;) |</span><br><span class="line">+-----------------------------------------+</span><br><span class="line">| mysql                                   |</span><br><span class="line">+-----------------------------------------+</span><br><span class="line">1 row in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="7-MySQL信息函数"><a href="#7-MySQL信息函数" class="headerlink" title="7. MySQL信息函数"></a>7. MySQL信息函数</h2><p>MySQL中内置了一些可以查询MySQL信息的函数，这些函数主要用于帮助数据库开发或运维人员更好地对数据库进行维护工作。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>VERSION()</td>
<td>返回当前MySQL的版本号</td>
</tr>
<tr>
<td>CONNECTION_ID()</td>
<td>返回当前MySQL服务器的连接数</td>
</tr>
<tr>
<td>DATABASE()，SCHEMA()</td>
<td>返回MySQL命令行当前所在的数据库</td>
</tr>
<tr>
<td>USER()，CURRENT_USER()、SYSTEM_USER()，SESSION_USER()</td>
<td>返回当前连接MySQL的用户名，返回结果格式为“主机名@用户名”</td>
</tr>
<tr>
<td>CHARSET(value)</td>
<td>返回字符串value自变量的字符集</td>
</tr>
<tr>
<td>COLLATION(value)</td>
<td>返回字符串value的比较规则</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT DATABASE();</span><br><span class="line">+------------+</span><br><span class="line">| DATABASE() |</span><br><span class="line">+------------+</span><br><span class="line">| test       |</span><br><span class="line">+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT DATABASE();</span><br><span class="line">+------------+</span><br><span class="line">| DATABASE() |</span><br><span class="line">+------------+</span><br><span class="line">| test       |</span><br><span class="line">+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT USER(), CURRENT_USER(), SYSTEM_USER(),SESSION_USER();</span><br><span class="line">+----------------+----------------+----------------+----------------+</span><br><span class="line">| USER()         | CURRENT_USER() | SYSTEM_USER()  | SESSION_USER() |</span><br><span class="line">+----------------+----------------+----------------+----------------+</span><br><span class="line">| root@localhost | root@localhost | root@localhost | root@localhost |</span><br><span class="line">+----------------+----------------+----------------+----------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT CHARSET(&#x27;ABC&#x27;);</span><br><span class="line">+----------------+</span><br><span class="line">| CHARSET(&#x27;ABC&#x27;) |</span><br><span class="line">+----------------+</span><br><span class="line">| utf8mb4        |</span><br><span class="line">+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT COLLATION(&#x27;ABC&#x27;);</span><br><span class="line">+--------------------+</span><br><span class="line">| COLLATION(&#x27;ABC&#x27;)   |</span><br><span class="line">+--------------------+</span><br><span class="line">| utf8mb4_general_ci |</span><br><span class="line">+--------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="8-其他函数"><a href="#8-其他函数" class="headerlink" title="8. 其他函数"></a>8. 其他函数</h2><p>MySQL中有些函数无法对其进行具体的分类，但是这些函数在MySQL的开发和运维过程中也是不容忽视的。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>FORMAT(value,n)</td>
<td>返回对数字value进行格式化后的结果数据。n表示<code>四舍五入</code>后保留到小数点后n位</td>
</tr>
<tr>
<td>CONV(value,from,to)</td>
<td>将value的值进行不同进制之间的转换</td>
</tr>
<tr>
<td>INET_ATON(ipvalue)</td>
<td>将以点分隔的IP地址转化为一个数字</td>
</tr>
<tr>
<td>INET_NTOA(value)</td>
<td>将数字形式的IP地址转化为以点分隔的IP地址</td>
</tr>
<tr>
<td>BENCHMARK(n,expr)</td>
<td>将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费的时间</td>
</tr>
<tr>
<td>CONVERT(value USING char_code)</td>
<td>将value所使用的字符编码修改为char_code</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 如果n的值小于或者等于0，则只保留整数部分</span><br><span class="line">mysql&gt; SELECT FORMAT(123.123, 2), FORMAT(123.523, 0), FORMAT(123.123, -2); </span><br><span class="line">+--------------------+--------------------+---------------------+</span><br><span class="line">| FORMAT(123.123, 2) | FORMAT(123.523, 0) | FORMAT(123.123, -2) |</span><br><span class="line">+--------------------+--------------------+---------------------+</span><br><span class="line">| 123.12             | 124                | 123                 |</span><br><span class="line">+--------------------+--------------------+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT CONV(16, 10, 2), CONV(8888,10,16), CONV(NULL, 10, 2);</span><br><span class="line">+-----------------+------------------+-------------------+</span><br><span class="line">| CONV(16, 10, 2) | CONV(8888,10,16) | CONV(NULL, 10, 2) |</span><br><span class="line">+-----------------+------------------+-------------------+</span><br><span class="line">| 10000           | 22B8             | NULL              |</span><br><span class="line">+-----------------+------------------+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT INET_ATON(&#x27;192.168.1.100&#x27;);</span><br><span class="line">+----------------------------+</span><br><span class="line">| INET_ATON(&#x27;192.168.1.100&#x27;) |</span><br><span class="line">+----------------------------+</span><br><span class="line">|                 3232235876 |</span><br><span class="line">+----------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 以“192.168.1.100”为例，计算方式为192乘以256的3次方，加上168乘以256的2次方，加上1乘以256，再加上100。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT INET_NTOA(3232235876);</span><br><span class="line">+-----------------------+</span><br><span class="line">| INET_NTOA(3232235876) |</span><br><span class="line">+-----------------------+</span><br><span class="line">| 192.168.1.100         |</span><br><span class="line">+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT BENCHMARK(1, MD5(&#x27;mysql&#x27;));</span><br><span class="line">+----------------------------+</span><br><span class="line">| BENCHMARK(1, MD5(&#x27;mysql&#x27;)) |</span><br><span class="line">+----------------------------+</span><br><span class="line">|                          0 |</span><br><span class="line">+----------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT BENCHMARK(1000000, MD5(&#x27;mysql&#x27;)); </span><br><span class="line">+----------------------------------+</span><br><span class="line">| BENCHMARK(1000000, MD5(&#x27;mysql&#x27;)) |</span><br><span class="line">+----------------------------------+</span><br><span class="line">|                                0 |</span><br><span class="line">+----------------------------------+</span><br><span class="line">1 row in set (0.20 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT CHARSET(&#x27;mysql&#x27;), CHARSET(CONVERT(&#x27;mysql&#x27; USING &#x27;utf8&#x27;));</span><br><span class="line">+------------------+----------------------------------------+</span><br><span class="line">| CHARSET(&#x27;mysql&#x27;) | CHARSET(CONVERT(&#x27;mysql&#x27; USING &#x27;utf8&#x27;)) |</span><br><span class="line">+------------------+----------------------------------------+</span><br><span class="line">| utf8mb4          | utf8                                   |</span><br><span class="line">+------------------+----------------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="第08章-聚合函数"><a href="#第08章-聚合函数" class="headerlink" title="第08章_聚合函数"></a>第08章_聚合函数</h1><hr>
<p>我们上一章讲到了 SQL 单行函数。实际上 SQL 函数还有一类，叫做聚合（或聚集、分组）函数，它是对一组数据进行汇总的函数，输入的是一组数据的集合，输出的是单个值。</p>
<h2 id="1-聚合函数介绍"><a href="#1-聚合函数介绍" class="headerlink" title="1. 聚合函数介绍"></a>1. 聚合函数介绍</h2><ul>
<li><strong>什么是聚合函数</strong></li>
</ul>
<p>聚合函数作用于一组数据，并对一组数据返回一个值。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554980924940.png"
                        alt="1554980924940"
                 ></p>
<ul>
<li><p><strong>聚合函数类型</strong></p>
<ul>
<li><strong>AVG()</strong></li>
<li><strong>SUM()</strong></li>
<li><strong>MAX()</strong></li>
<li><strong>MIN()</strong></li>
<li>**COUNT() **</li>
</ul>
</li>
<li><p>聚合函数语法</p>
</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554981029920.png"
                        alt="1554981029920"
                 ></p>
<ul>
<li>聚合函数不能嵌套调用。比如不能出现类似“AVG(SUM(字段名称))”形式的调用。</li>
</ul>
<h3 id="1-1-AVG和SUM函数"><a href="#1-1-AVG和SUM函数" class="headerlink" title="1.1 AVG和SUM函数"></a>1.1 AVG和SUM函数</h3><p>可以对<strong>数值型数据</strong>使用AVG 和 SUM 函数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary), <span class="built_in">MAX</span>(salary),<span class="built_in">MIN</span>(salary), <span class="built_in">SUM</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span>   employees</span><br><span class="line"><span class="keyword">WHERE</span>  job_id <span class="keyword">LIKE</span> <span class="string">&#x27;%REP%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554981279723.png"
                        alt="1554981279723"
                 ></p>
<h3 id="1-2-MIN和MAX函数"><a href="#1-2-MIN和MAX函数" class="headerlink" title="1.2 MIN和MAX函数"></a>1.2 MIN和MAX函数</h3><p>可以对<strong>任意数据类型</strong>的数据使用 MIN 和 MAX 函数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(hire_date), <span class="built_in">MAX</span>(hire_date)</span><br><span class="line"><span class="keyword">FROM</span>	  employees;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554981253194.png"
                        alt="1554981253194"
                 ></p>
<h3 id="1-3-COUNT函数"><a href="#1-3-COUNT函数" class="headerlink" title="1.3 COUNT函数"></a>1.3 COUNT函数</h3><ul>
<li>COUNT(<em>)返回表中记录总数，适用于*<em>任意数据类型</em></em>。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span>	  employees</span><br><span class="line"><span class="keyword">WHERE</span>  department_id <span class="operator">=</span> <span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554981241299.png"
                        alt="1554981241299"
                 ></p>
<ul>
<li>COUNT(expr) 返回<strong>expr不为空</strong>的记录总数。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(commission_pct)</span><br><span class="line"><span class="keyword">FROM</span>   employees</span><br><span class="line"><span class="keyword">WHERE</span>  department_id <span class="operator">=</span> <span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554981328678.png"
                        alt="1554981328678"
                 ></p>
<ul>
<li><p><strong>问题：用count(*)，count(1)，count(列名)谁好呢?</strong></p>
<p>其实，对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。</p>
<p>Innodb引擎的表用count(*),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好于具体的count(列名)。</p>
</li>
<li><p><strong>问题：能不能使用count(列名)替换count(*)?</strong></p>
<p>不要使用 count(列名)来替代 <code>count(*)</code>，<code>count(*)</code>是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。</p>
<p>说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p>
</li>
</ul>
<h2 id="2-GROUP-BY"><a href="#2-GROUP-BY" class="headerlink" title="2. GROUP BY"></a>2. GROUP BY</h2><h3 id="2-1-基本使用"><a href="#2-1-基本使用" class="headerlink" title="2.1 基本使用"></a>2.1 基本使用</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554981374920.png"
                        alt="1554981374920"
                 ></p>
<p><strong>可以使用GROUP BY子句将表中的数据分成若干组</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">column</span>, group_function(<span class="keyword">column</span>)</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span></span><br><span class="line">[<span class="keyword">WHERE</span>	<span class="keyword">condition</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span>	group_by_expression]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span>	<span class="keyword">column</span>];</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>明确：WHERE一定放在FROM后面</strong></p>
</blockquote>
<p><strong>在SELECT列表中所有未包含在组函数中的列都应该包含在 GROUP BY子句中</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>   department_id, <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span>     employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id ;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554981539408.png"
                        alt="1554981539408"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554981544191.png"
                        alt="1554981544191"
                 ></p>
<p>包含在 GROUP BY 子句中的列不必包含在SELECT 列表中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>   <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span>     employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id ;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554981574152.png"
                        alt="1554981574152"
                 ></p>
<h3 id="2-2-使用多个列分组"><a href="#2-2-使用多个列分组" class="headerlink" title="2.2 使用多个列分组"></a>2.2 使用多个列分组</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554981607442.png"
                        alt="1554981607442"
                 ></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>   department_id dept_id, job_id, <span class="built_in">SUM</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span>     employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id, job_id ;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554981624864.png"
                        alt="1554981624864"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554981629733.png"
                        alt="1554981629733"
                 ></p>
<h3 id="2-3-GROUP-BY中使用WITH-ROLLUP"><a href="#2-3-GROUP-BY中使用WITH-ROLLUP" class="headerlink" title="2.3 GROUP BY中使用WITH ROLLUP"></a>2.3 GROUP BY中使用WITH ROLLUP</h3><p>使用<code>WITH ROLLUP</code>关键字之后，在所有查询出的分组记录之后增加一条记录，该记录计算查询出的所有记录的总和，即统计记录数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT department_id,AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id &gt; 80</span><br><span class="line">GROUP BY department_id WITH ROLLUP;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>当使用ROLLUP时，不能同时使用ORDER BY子句进行结果排序，即ROLLUP和ORDER BY是互相排斥的。</p>
</blockquote>
<h2 id="3-HAVING"><a href="#3-HAVING" class="headerlink" title="3. HAVING"></a>3. HAVING</h2><h3 id="3-1-基本使用"><a href="#3-1-基本使用" class="headerlink" title="3.1 基本使用"></a>3.1 基本使用</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554981656798.png"
                        alt="1554981656798"
                 ></p>
<p><strong>过滤分组：HAVING子句</strong></p>
<ol>
<li>行已经被分组。</li>
<li>使用了聚合函数。</li>
<li>满足HAVING 子句中条件的分组将被显示。</li>
<li>HAVING 不能单独使用，必须要跟 GROUP BY 一起使用。</li>
</ol>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554981808091.png"
                        alt="1554981808091"
                 ></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>   department_id, <span class="built_in">MAX</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span>     employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span>   <span class="built_in">MAX</span>(salary)<span class="operator">&gt;</span><span class="number">10000</span> ;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554981824564.png"
                        alt="1554981824564"
                 ></p>
<ul>
<li>**非法使用聚合函数 ： 不能在 WHERE 子句中使用聚合函数。**如下：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>   department_id, <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span>     employees</span><br><span class="line"><span class="keyword">WHERE</span>    <span class="built_in">AVG</span>(salary) <span class="operator">&gt;</span> <span class="number">8000</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554981724375.png"
                        alt="1554981724375"
                 ></p>
<h3 id="3-2-WHERE和HAVING的对比"><a href="#3-2-WHERE和HAVING的对比" class="headerlink" title="3.2 WHERE和HAVING的对比"></a>3.2 WHERE和HAVING的对比</h3><p><strong>区别1：WHERE 可以直接使用表中的字段作为筛选条件，但不能使用分组中的计算函数作为筛选条件；HAVING 必须要与 GROUP BY 配合使用，可以把分组计算的函数和分组字段作为筛选条件。</strong></p>
<p>这决定了，在需要对数据进行分组统计的时候，HAVING 可以完成 WHERE 不能完成的任务。这是因为，在查询语法结构中，WHERE 在 GROUP BY 之前，所以无法对分组结果进行筛选。HAVING 在 GROUP BY 之后，可以使用分组字段和分组中的计算函数，对分组的结果集进行筛选，这个功能是 WHERE 无法完成的。另外，WHERE排除的记录不再包括在分组中。</p>
<p><strong>区别2：如果需要通过连接从关联表中获取需要的数据，WHERE 是先筛选后连接，而 HAVING 是先连接后筛选。</strong> 这一点，就决定了在关联查询中，WHERE 比 HAVING 更高效。因为 WHERE 可以先筛选，用一个筛选后的较小数据集和关联表进行连接，这样占用的资源比较少，执行效率也比较高。HAVING 则需要先把结果集准备好，也就是用未被筛选的数据集进行关联，然后对这个大的数据集进行筛选，这样占用的资源就比较多，执行效率也较低。</p>
<p>小结如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>WHERE</td>
<td>先筛选数据再关联，执行效率高</td>
<td>不能使用分组中的计算函数进行筛选</td>
</tr>
<tr>
<td>HAVING</td>
<td>可以使用分组中的计算函数</td>
<td>在最后的结果集中进行筛选，执行效率较低</td>
</tr>
</tbody></table>
<p><strong>开发中的选择：</strong></p>
<p>WHERE 和 HAVING 也不是互相排斥的，我们可以在一个查询里面同时使用 WHERE 和 HAVING。包含分组统计函数的条件用 HAVING，普通条件用 WHERE。这样，我们就既利用了 WHERE 条件的高效快速，又发挥了 HAVING 可以使用包含分组统计函数的查询条件的优点。当数据量特别大的时候，运行效率会有很大的差别。</p>
<h2 id="4-SELECT的执行过程"><a href="#4-SELECT的执行过程" class="headerlink" title="4. SELECT的执行过程"></a>4. SELECT的执行过程</h2><h3 id="4-1-查询的结构"><a href="#4-1-查询的结构" class="headerlink" title="4.1 查询的结构"></a>4.1 查询的结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式1：</span><br><span class="line">SELECT ...,....,...</span><br><span class="line">FROM ...,...,....</span><br><span class="line">WHERE 多表的连接条件</span><br><span class="line">AND 不包含组函数的过滤条件</span><br><span class="line">GROUP BY ...,...</span><br><span class="line">HAVING 包含组函数的过滤条件</span><br><span class="line">ORDER BY ... ASC/DESC</span><br><span class="line">LIMIT ...,...</span><br><span class="line"></span><br><span class="line">#方式2：</span><br><span class="line">SELECT ...,....,...</span><br><span class="line">FROM ... JOIN ... </span><br><span class="line">ON 多表的连接条件</span><br><span class="line">JOIN ...</span><br><span class="line">ON ...</span><br><span class="line">WHERE 不包含组函数的过滤条件</span><br><span class="line">AND/OR 不包含组函数的过滤条件</span><br><span class="line">GROUP BY ...,...</span><br><span class="line">HAVING 包含组函数的过滤条件</span><br><span class="line">ORDER BY ... ASC/DESC</span><br><span class="line">LIMIT ...,...</span><br><span class="line"></span><br><span class="line">#其中：</span><br><span class="line">#（1）from：从哪些表中筛选</span><br><span class="line">#（2）on：关联多表查询时，去除笛卡尔积</span><br><span class="line">#（3）where：从表中筛选的条件</span><br><span class="line">#（4）group by：分组依据</span><br><span class="line">#（5）having：在统计结果中再次筛选</span><br><span class="line">#（6）order by：排序</span><br><span class="line">#（7）limit：分页</span><br></pre></td></tr></table></figure>

<h3 id="4-2-SELECT执行顺序"><a href="#4-2-SELECT执行顺序" class="headerlink" title="4.2 SELECT执行顺序"></a>4.2 SELECT执行顺序</h3><p>你需要记住 SELECT 查询时的两个顺序：</p>
<p><strong>1. 关键字的顺序是不能颠倒的：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT...</span><br></pre></td></tr></table></figure>

<p><strong>2.SELECT 语句的执行顺序</strong>（在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM -&gt; WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT 的字段 -&gt; DISTINCT -&gt; ORDER BY -&gt; LIMIT</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1566872301088.png"
                        alt="1566872301088"
                 ></p>
<p>比如你写了一个 SQL 语句，那么它的关键字顺序和执行顺序是下面这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT player_id, player_name, count(*) as num # 顺序 5</span><br><span class="line">FROM player JOIN team ON player.team_id = team.team_id # 顺序 1</span><br><span class="line">WHERE height &gt; 1.80 # 顺序 2</span><br><span class="line">GROUP BY player.team_id # 顺序 3</span><br><span class="line">HAVING num &gt; 2 # 顺序 4</span><br><span class="line">ORDER BY num DESC # 顺序 6</span><br><span class="line">LIMIT 2 # 顺序 7</span><br></pre></td></tr></table></figure>

<p>在 SELECT 语句执行这些步骤的时候，每个步骤都会产生一个<code>虚拟表</code>，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在 SQL 的执行过程中，对于我们来说是不可见的。</p>
<h3 id="4-3-SQL-的执行原理"><a href="#4-3-SQL-的执行原理" class="headerlink" title="4.3 SQL 的执行原理"></a>4.3 SQL 的执行原理</h3><p>SELECT 是先执行 FROM 这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：</p>
<ol>
<li>首先先通过 CROSS JOIN 求笛卡尔积，相当于得到虚拟表 vt（virtual table）1-1；</li>
<li>通过 ON 进行筛选，在虚拟表 vt1-1 的基础上进行筛选，得到虚拟表 vt1-2；</li>
<li>添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟表 vt1-2 的基础上增加外部行，得到虚拟表 vt1-3。</li>
</ol>
<p>当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得到是我们的原始数据。</p>
<p>当我们拿到了查询数据表的原始数据，也就是最终的虚拟表 <code>vt1</code>，就可以在此基础上再进行 <code>WHERE 阶段</code>。在这个阶段中，会根据 vt1 表的结果进行筛选过滤，得到虚拟表 <code>vt2</code>。</p>
<p>然后进入第三步和第四步，也就是 <code>GROUP 和 HAVING 阶段</code>。在这个阶段中，实际上是在虚拟表 vt2 的基础上进行分组和分组过滤，得到中间的虚拟表 <code>vt3</code> 和 <code>vt4</code>。</p>
<p>当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到 <code>SELECT 和 DISTINCT 阶段</code>。</p>
<p>首先在 SELECT 阶段会提取想要的字段，然后在 DISTINCT 阶段过滤掉重复的行，分别得到中间的虚拟表 <code>vt5-1</code> 和 <code>vt5-2</code>。</p>
<p>当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是 <code>ORDER BY 阶段</code>，得到虚拟表 <code>vt6</code>。</p>
<p>最后在 vt6 的基础上，取出指定行的记录，也就是 <code>LIMIT 阶段</code>，得到最终的结果，对应的是虚拟表 <code>vt7</code>。</p>
<p>当然我们在写 SELECT 语句的时候，不一定存在所有的关键字，相应的阶段就会省略。</p>
<p>同时因为 SQL 是一门类似英语的结构化查询语言，所以我们在写 SELECT 语句的时候，还要注意相应的关键字顺序，<strong>所谓底层运行的原理，就是我们刚才讲到的执行顺序。</strong></p>
<hr>
<h1 id="第09章-子查询"><a href="#第09章-子查询" class="headerlink" title="第09章_子查询"></a>第09章_子查询</h1><hr>
<p>子查询指一个查询语句嵌套在另一个查询语句内部的查询，这个特性从MySQL 4.1开始引入。</p>
<p>SQL 中子查询的使用大大增强了 SELECT 查询的能力，因为很多时候查询需要从结果集中获取数据，或者需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较。</p>
<h2 id="1-需求分析与问题解决"><a href="#1-需求分析与问题解决" class="headerlink" title="1. 需求分析与问题解决"></a>1. 需求分析与问题解决</h2><h3 id="1-1-实际问题"><a href="#1-1-实际问题" class="headerlink" title="1.1 实际问题"></a>1.1 实际问题</h3><img    
                       lazyload
                       alt="image"
                       data-src="MySQL/1554991034688.png"
                         alt="1554991034688" style="zoom:80%;" 
                 >

<p>现有解决方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式一：</span><br><span class="line">SELECT salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name = &#x27;Abel&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; 11000;</span><br><span class="line"></span><br><span class="line">#方式二：自连接</span><br><span class="line">SELECT e2.last_name,e2.salary</span><br><span class="line">FROM employees e1,employees e2</span><br><span class="line">WHERE e1.last_name = &#x27;Abel&#x27;</span><br><span class="line">AND e1.`salary` &lt; e2.`salary`</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式三：子查询</span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; (</span><br><span class="line">		SELECT salary</span><br><span class="line">		FROM employees</span><br><span class="line">		WHERE last_name = &#x27;Abel&#x27;</span><br><span class="line">		);</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554991316599.png"
                        alt="1554991316599"
                 ></p>
<h3 id="1-2-子查询的基本使用"><a href="#1-2-子查询的基本使用" class="headerlink" title="1.2 子查询的基本使用"></a>1.2 子查询的基本使用</h3><ul>
<li>子查询的基本语法结构：</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554991054388.png"
                        alt="1554991054388"
                 ></p>
<ul>
<li>子查询（内查询）在主查询之前一次执行完成。</li>
<li>子查询的结果被主查询（外查询）使用 。</li>
<li><strong>注意事项</strong><ul>
<li>子查询要包含在括号内</li>
<li>将子查询放在比较条件的右侧</li>
<li>单行操作符对应单行子查询，多行操作符对应多行子查询</li>
</ul>
</li>
</ul>
<h3 id="1-3-子查询的分类"><a href="#1-3-子查询的分类" class="headerlink" title="1.3 子查询的分类"></a>1.3 子查询的分类</h3><p><strong>分类方式1：</strong></p>
<p>我们按内查询的结果返回一条还是多条记录，将子查询分为<code>单行子查询</code>、<code>多行子查询</code>。</p>
<ul>
<li><p>单行子查询</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554991538719.png"
                        alt="1554991538719"
                 ></p>
</li>
<li><p>多行子查询</p>
</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554991555669.png"
                        alt="1554991555669"
                 ></p>
<p><strong>分类方式2：</strong></p>
<p>我们按内查询是否被执行多次，将子查询划分为<code>相关(或关联)子查询</code>和<code>不相关(或非关联)子查询</code>。</p>
<p>子查询从数据表中查询了数据结果，如果这个数据结果只执行一次，然后这个数据结果作为主查询的条件进行执行，那么这样的子查询叫做不相关子查询。</p>
<p>同样，如果子查询需要执行多次，即采用循环的方式，先从外部查询开始，每次都传入子查询进行查询，然后再将结果反馈给外部，这种嵌套的执行方式就称为相关子查询。</p>
<h2 id="2-单行子查询"><a href="#2-单行子查询" class="headerlink" title="2. 单行子查询"></a>2. 单行子查询</h2><h3 id="2-1-单行比较操作符"><a href="#2-1-单行比较操作符" class="headerlink" title="2.1 单行比较操作符"></a>2.1 单行比较操作符</h3><table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>equal to</td>
</tr>
<tr>
<td>&gt;</td>
<td>greater than</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>greater than or equal to</td>
</tr>
<tr>
<td>&lt;</td>
<td>less than</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>less than or equal to</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>not equal to</td>
</tr>
</tbody></table>
<h3 id="2-2-代码示例"><a href="#2-2-代码示例" class="headerlink" title="2.2 代码示例"></a>2.2 代码示例</h3><p><strong>题目：查询工资大于149号员工工资的员工的信息</strong></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20210914232952626.png"
                        alt="image-20210914232952626"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20210914232935062.png"
                        alt="image-20210914232935062"
                 ></p>
<p><strong>题目：返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, job_id, salary</span><br><span class="line"><span class="keyword">FROM</span>   employees</span><br><span class="line"><span class="keyword">WHERE</span>  job_id <span class="operator">=</span>  </span><br><span class="line">                (<span class="keyword">SELECT</span> job_id</span><br><span class="line">                 <span class="keyword">FROM</span>   employees</span><br><span class="line">                 <span class="keyword">WHERE</span>  employee_id <span class="operator">=</span> <span class="number">141</span>)</span><br><span class="line"><span class="keyword">AND</span>    salary <span class="operator">&gt;</span></span><br><span class="line">                (<span class="keyword">SELECT</span> salary</span><br><span class="line">                 <span class="keyword">FROM</span>   employees</span><br><span class="line">                 <span class="keyword">WHERE</span>  employee_id <span class="operator">=</span> <span class="number">143</span>);</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554991892770.png"
                        alt="1554991892770"
                 ></p>
<p><strong>题目：返回公司工资最少的员工的last_name,job_id和salary</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, job_id, salary</span><br><span class="line"><span class="keyword">FROM</span>   employees</span><br><span class="line"><span class="keyword">WHERE</span>  salary <span class="operator">=</span> </span><br><span class="line">                (<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary)</span><br><span class="line">                 <span class="keyword">FROM</span>   employees);</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554991935186.png"
                        alt="1554991935186"
                 ></p>
<p><strong>题目：查询与141号或174号员工的manager_id和department_id相同的其他员工的employee_id，manager_id，department_id</strong></p>
<p>实现方式1：不成对比较</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT  employee_id, manager_id, department_id</span><br><span class="line">FROM    employees</span><br><span class="line">WHERE   manager_id IN</span><br><span class="line">		  (SELECT  manager_id</span><br><span class="line">                   FROM    employees</span><br><span class="line">                   WHERE   employee_id IN (174,141))</span><br><span class="line">AND     department_id IN </span><br><span class="line">		  (SELECT  department_id</span><br><span class="line">                   FROM    employees</span><br><span class="line">                   WHERE   employee_id IN (174,141))</span><br><span class="line">AND	employee_id NOT IN(174,141);</span><br></pre></td></tr></table></figure>

<p>实现方式2：成对比较</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT	employee_id, manager_id, department_id</span><br><span class="line">FROM	employees</span><br><span class="line">WHERE  (manager_id, department_id) IN</span><br><span class="line">                      (SELECT manager_id, department_id</span><br><span class="line">                       FROM   employees</span><br><span class="line">                       WHERE  employee_id IN (141,174))</span><br><span class="line">AND	employee_id NOT IN (141,174);</span><br></pre></td></tr></table></figure>

<h3 id="2-3-HAVING-中的子查询"><a href="#2-3-HAVING-中的子查询" class="headerlink" title="2.3 HAVING 中的子查询"></a>2.3 HAVING 中的子查询</h3><ul>
<li>首先执行子查询。</li>
<li>向主查询中的HAVING 子句返回结果。</li>
</ul>
<p><strong>题目：查询最低工资大于50号部门最低工资的部门id和其最低工资</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>   department_id, <span class="built_in">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span>     employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">HAVING</span>   <span class="built_in">MIN</span>(salary) <span class="operator">&gt;</span></span><br><span class="line">                       (<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(salary)</span><br><span class="line">                        <span class="keyword">FROM</span>   employees</span><br><span class="line">                        <span class="keyword">WHERE</span>  department_id <span class="operator">=</span> <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-4-CASE中的子查询"><a href="#2-4-CASE中的子查询" class="headerlink" title="2.4 CASE中的子查询"></a>2.4 CASE中的子查询</h3><p>在CASE表达式中使用单列子查询：</p>
<p><strong>题目：显式员工的employee_id,last_name和location。其中，若员工department_id与location_id为1800的department_id相同，则location为’Canada’，其余则为’USA’。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id, last_name,</span><br><span class="line">       (CASE department_id</span><br><span class="line">        WHEN</span><br><span class="line">             (SELECT department_id FROM departments</span><br><span class="line">	      WHERE location_id = 1800)           </span><br><span class="line">        THEN &#x27;Canada&#x27; ELSE &#x27;USA&#x27; END) location</span><br><span class="line">FROM   employees;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-子查询中的空值问题"><a href="#2-5-子查询中的空值问题" class="headerlink" title="2.5 子查询中的空值问题"></a>2.5 子查询中的空值问题</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name, job_id</span><br><span class="line"><span class="keyword">FROM</span>   employees</span><br><span class="line"><span class="keyword">WHERE</span>  job_id <span class="operator">=</span></span><br><span class="line">                (<span class="keyword">SELECT</span> job_id</span><br><span class="line">                 <span class="keyword">FROM</span>   employees</span><br><span class="line">                 <span class="keyword">WHERE</span>  last_name <span class="operator">=</span> <span class="string">&#x27;Haas&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554992067381.png"
                        alt="1554992067381"
                 ></p>
<blockquote>
<p><strong>子查询不返回任何行</strong></p>
</blockquote>
<h3 id="2-5-非法使用子查询"><a href="#2-5-非法使用子查询" class="headerlink" title="2.5 非法使用子查询"></a>2.5 非法使用子查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, last_name</span><br><span class="line"><span class="keyword">FROM</span>   employees</span><br><span class="line"><span class="keyword">WHERE</span>  salary <span class="operator">=</span></span><br><span class="line">                (<span class="keyword">SELECT</span>   <span class="built_in">MIN</span>(salary)</span><br><span class="line">                 <span class="keyword">FROM</span>     employees</span><br><span class="line">                 <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id);</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554992135819.png"
                        alt="1554992135819"
                 ></p>
<blockquote>
<p><strong>多行子查询使用单行比较符</strong></p>
</blockquote>
<h2 id="3-多行子查询"><a href="#3-多行子查询" class="headerlink" title="3. 多行子查询"></a>3. 多行子查询</h2><ul>
<li>也称为集合比较子查询</li>
<li>内查询返回多行</li>
<li>使用多行比较操作符</li>
</ul>
<h3 id="3-1-多行比较操作符"><a href="#3-1-多行比较操作符" class="headerlink" title="3.1 多行比较操作符"></a>3.1 多行比较操作符</h3><table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>IN</td>
<td>等于列表中的<strong>任意一个</strong></td>
</tr>
<tr>
<td>ANY</td>
<td>需要和单行比较操作符一起使用，和子查询返回的<strong>某一个</strong>值比较</td>
</tr>
<tr>
<td>ALL</td>
<td>需要和单行比较操作符一起使用，和子查询返回的<strong>所有</strong>值比较</td>
</tr>
<tr>
<td>SOME</td>
<td>实际上是ANY的别名，作用相同，一般常使用ANY</td>
</tr>
</tbody></table>
<blockquote>
<p>体会 ANY 和 ALL 的区别</p>
</blockquote>
<h3 id="3-2-代码示例"><a href="#3-2-代码示例" class="headerlink" title="3.2 代码示例"></a>3.2 代码示例</h3><p><strong>题目：返回其它job_id中比job_id为‘IT_PROG’部门任一工资低的员工的员工号、姓名、job_id 以及salary</strong></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554992658876.png"
                        alt="1554992658876"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554992664594.png"
                        alt="1554992664594"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554992668429.png"
                        alt="1554992668429"
                 ></p>
<p><strong>题目：返回其它job_id中比job_id为‘IT_PROG’部门所有工资都低的员工的员工号、姓名、job_id以及salary</strong></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554992753654.png"
                        alt="1554992753654"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554992759467.png"
                        alt="1554992759467"
                 ></p>
<p><strong>题目：查询平均工资最低的部门id</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式1：</span><br><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING AVG(salary) = (</span><br><span class="line">			SELECT MIN(avg_sal)</span><br><span class="line">			FROM (</span><br><span class="line">				SELECT AVG(salary) avg_sal</span><br><span class="line">				FROM employees</span><br><span class="line">				GROUP BY department_id</span><br><span class="line">				) dept_avg_sal</span><br><span class="line">			)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式2：</span><br><span class="line">SELECT department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id</span><br><span class="line">HAVING AVG(salary) &lt;= ALL (</span><br><span class="line">				SELECT AVG(salary) avg_sal</span><br><span class="line">				FROM employees</span><br><span class="line">				GROUP BY department_id</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="3-3-空值问题"><a href="#3-3-空值问题" class="headerlink" title="3.3 空值问题"></a>3.3 空值问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT last_name</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id NOT IN (</span><br><span class="line">			SELECT manager_id</span><br><span class="line">			FROM employees</span><br><span class="line">			);</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211027195906773.png"
                        alt="image-20211027195906773"
                 ></p>
<h2 id="4-相关子查询"><a href="#4-相关子查询" class="headerlink" title="4. 相关子查询"></a>4. 相关子查询</h2><h3 id="4-1-相关子查询执行流程"><a href="#4-1-相关子查询执行流程" class="headerlink" title="4.1 相关子查询执行流程"></a>4.1 相关子查询执行流程</h3><p>如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为<code>关联子查询</code>。</p>
<p>相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="C:\Users\zwh\mysql_gitcode\黑马mysql学习\images\xianguanzichaxun_1.png"
                         alt="1554992898234" style="zoom:80%;" 
                 >

<img    
                       lazyload
                       alt="image"
                       data-src="C:\Users\zwh\mysql_gitcode\黑马mysql学习\images\xianguanzichaxun_2.png"
                         alt="1554992925281" style="zoom:80%;" 
                 >

<p>说明：<strong>子查询中使用主查询中的列</strong></p>
<h3 id="4-2-代码示例"><a href="#4-2-代码示例" class="headerlink" title="4.2 代码示例"></a>4.2 代码示例</h3><p><strong>题目：查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id</strong></p>
<p><strong>方式一：相关子查询</strong></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554992986225.png"
                        alt="1554992986225"
                 ></p>
<p><strong>方式二：在 FROM 中使用子查询</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name,salary,e1.department_id</span><br><span class="line"><span class="keyword">FROM</span> employees e1,(<span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary) dept_avg_sal <span class="keyword">FROM</span> employees <span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id) e2</span><br><span class="line"><span class="keyword">WHERE</span> e1.`department_id` <span class="operator">=</span> e2.department_id</span><br><span class="line"><span class="keyword">AND</span> e2.dept_avg_sal <span class="operator">&lt;</span> e1.`salary`;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>from型的子查询：子查询是作为from的一部分，子查询要用()引起来，并且要给这个子查询取别名，<br>把它当成一张“临时的虚拟的表”来使用。</p>
</blockquote>
<p>在ORDER BY 中使用子查询：</p>
<p><strong>题目：查询员工的id,salary,按照department_name 排序</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,salary</span><br><span class="line"><span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (</span><br><span class="line">	  <span class="keyword">SELECT</span> department_name</span><br><span class="line">	  <span class="keyword">FROM</span> departments d</span><br><span class="line">	  <span class="keyword">WHERE</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line">	);</span><br></pre></td></tr></table></figure>

<p><strong>题目：若employees表中employee_id与job_history表中employee_id相同的数目不小于2，输出这些相同id的员工的employee_id,last_name和其job_id</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT e.employee_id, last_name,e.job_id</span><br><span class="line">FROM   employees e </span><br><span class="line">WHERE  2 &lt;= (SELECT COUNT(*)</span><br><span class="line">             FROM   job_history </span><br><span class="line">             WHERE  employee_id = e.employee_id);</span><br></pre></td></tr></table></figure>

<h3 id="4-3-EXISTS-与-NOT-EXISTS关键字"><a href="#4-3-EXISTS-与-NOT-EXISTS关键字" class="headerlink" title="4.3 EXISTS 与 NOT EXISTS关键字"></a>4.3 EXISTS 与 NOT EXISTS关键字</h3><ul>
<li>关联子查询通常也会和 EXISTS操作符一起来使用，用来检查在子查询中是否存在满足条件的行。</li>
<li><strong>如果在子查询中不存在满足条件的行：</strong><ul>
<li>条件返回 FALSE</li>
<li>继续在子查询中查找</li>
</ul>
</li>
<li><strong>如果在子查询中存在满足条件的行：</strong><ul>
<li>不在子查询中继续查找</li>
<li>条件返回 TRUE</li>
</ul>
</li>
<li>NOT EXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE。</li>
</ul>
<p><strong>题目：查询公司管理者的employee_id，last_name，job_id，department_id信息</strong></p>
<p>方式一：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, job_id, department_id</span><br><span class="line"><span class="keyword">FROM</span>   employees e1</span><br><span class="line"><span class="keyword">WHERE</span>  <span class="keyword">EXISTS</span> ( <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">                 <span class="keyword">FROM</span>   employees e2</span><br><span class="line">                 <span class="keyword">WHERE</span>  e2.manager_id <span class="operator">=</span> </span><br><span class="line">                        e1.employee_id);</span><br></pre></td></tr></table></figure>

<p>方式二：自连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> e1.employee_id, e1.last_name, e1.job_id, e1.department_id</span><br><span class="line"><span class="keyword">FROM</span>   employees e1 <span class="keyword">JOIN</span> employees e2</span><br><span class="line"><span class="keyword">WHERE</span> e1.employee_id <span class="operator">=</span> e2.manager_id;</span><br></pre></td></tr></table></figure>

<p>方式三：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,job_id,department_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="keyword">IN</span> (</span><br><span class="line">		     <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> manager_id</span><br><span class="line">		     <span class="keyword">FROM</span> employees</span><br><span class="line">		     </span><br><span class="line">		     );</span><br></pre></td></tr></table></figure>

<p><strong>题目：查询departments表中，不存在于employees表中的部门的department_id和department_name</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department_id, department_name</span><br><span class="line"><span class="keyword">FROM</span> departments d</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="string">&#x27;X&#x27;</span></span><br><span class="line">                  <span class="keyword">FROM</span>   employees</span><br><span class="line">                  <span class="keyword">WHERE</span>  department_id <span class="operator">=</span> d.department_id);</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554993169269.png"
                        alt="1554993169269"
                 ></p>
<h3 id="4-4-相关更新"><a href="#4-4-相关更新" class="headerlink" title="4.4 相关更新"></a>4.4 相关更新</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table1 alias1</span><br><span class="line"><span class="keyword">SET</span>    <span class="keyword">column</span> <span class="operator">=</span> (<span class="keyword">SELECT</span> expression</span><br><span class="line">                 <span class="keyword">FROM</span>   table2 alias2</span><br><span class="line">                 <span class="keyword">WHERE</span>  alias1.column <span class="operator">=</span> alias2.column);</span><br></pre></td></tr></table></figure>

<p>使用相关子查询依据一个表中的数据更新另一个表的数据。</p>
<p><strong>题目：在employees中增加一个department_name字段，数据为员工对应的部门名称</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1）</span><br><span class="line">ALTER TABLE employees</span><br><span class="line">ADD(department_name VARCHAR2(14));</span><br><span class="line"></span><br><span class="line"># 2）</span><br><span class="line">UPDATE employees e</span><br><span class="line">SET department_name =  (SELECT department_name </span><br><span class="line">	                       FROM   departments d</span><br><span class="line">	                       WHERE  e.department_id = d.department_id);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-4-相关删除"><a href="#4-4-相关删除" class="headerlink" title="4.4 相关删除"></a>4.4 相关删除</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table1 alias1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">column</span> operator (<span class="keyword">SELECT</span> expression</span><br><span class="line">                       <span class="keyword">FROM</span>   table2 alias2</span><br><span class="line">                       <span class="keyword">WHERE</span>  alias1.column <span class="operator">=</span> alias2.column);</span><br></pre></td></tr></table></figure>

<p>使用相关子查询依据一个表中的数据删除另一个表的数据。</p>
<p><strong>题目：删除表employees中，其与emp_history表皆有的数据</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> employees e</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="keyword">in</span>  </span><br><span class="line">           (<span class="keyword">SELECT</span> employee_id</span><br><span class="line">            <span class="keyword">FROM</span>   emp_history </span><br><span class="line">            <span class="keyword">WHERE</span>  employee_id <span class="operator">=</span> e.employee_id);</span><br></pre></td></tr></table></figure>

<h2 id="5-抛一个思考题"><a href="#5-抛一个思考题" class="headerlink" title="5. 抛一个思考题"></a>5. 抛一个思考题</h2><p>**问题：**谁的工资比Abel的高？</p>
<p><strong>解答：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式1：自连接</span><br><span class="line">SELECT e2.last_name,e2.salary</span><br><span class="line">FROM employees e1,employees e2</span><br><span class="line">WHERE e1.last_name = &#x27;Abel&#x27;</span><br><span class="line">AND e1.`salary` &lt; e2.`salary`</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式2：子查询</span><br><span class="line">SELECT last_name,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt; (</span><br><span class="line">		SELECT salary</span><br><span class="line">		FROM employees</span><br><span class="line">		WHERE last_name = &#x27;Abel&#x27;</span><br><span class="line">		);</span><br></pre></td></tr></table></figure>

<p>**问题：**以上两种方式有好坏之分吗？</p>
<p>**解答：**自连接方式好！</p>
<p>题目中可以使用子查询，也可以使用自连接。一般情况建议你使用自连接，因为在许多 DBMS 的处理过程中，对于自连接的处理速度要比子查询快得多。</p>
<p>可以这样理解：子查询实际上是通过未知表进行查询后的条件判断，而自连接是通过已知的自身数据表进行条件判断，因此在大部分 DBMS 中都对自连接处理进行了优化。</p>
<hr>
<h1 id="第10章-创建和管理表"><a href="#第10章-创建和管理表" class="headerlink" title="第10章_创建和管理表"></a>第10章_创建和管理表</h1><hr>
<h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h2><h3 id="1-1-一条数据存储的过程"><a href="#1-1-一条数据存储的过程" class="headerlink" title="1.1 一条数据存储的过程"></a>1.1 一条数据存储的过程</h3><p><code>存储数据是处理数据的第一步</code>。只有正确地把数据存储起来，我们才能进行有效的处理和分析。否则，只能是一团乱麻，无从下手。</p>
<p>那么，怎样才能把用户各种经营相关的、纷繁复杂的数据，有序、高效地存储起来呢？ 在 MySQL 中，一个完整的数据存储过程总共有 4 步，分别是创建数据库、确认字段、创建数据表、插入数据。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211007155810920.png"
                        alt="image-20211007155810920"
                 ></p>
<p>我们要先创建一个数据库，而不是直接创建数据表呢？</p>
<p>因为从系统架构的层次上看，MySQL 数据库系统从大到小依次是<code>数据库服务器</code>、<code>数据库</code>、<code>数据表</code>、数据表的<code>行与列</code>。</p>
<p>MySQL 数据库服务器之前已经安装。所以，我们就从创建数据库开始。</p>
<h3 id="1-2-标识符命名规则"><a href="#1-2-标识符命名规则" class="headerlink" title="1.2 标识符命名规则"></a>1.2 标识符命名规则</h3><ul>
<li>数据库名、表名不得超过30个字符，变量名限制为29个</li>
<li>必须只能包含 A–Z, a–z, 0–9, _共63个字符</li>
<li>数据库名、表名、字段名等对象名中间不要包含空格</li>
<li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li>
<li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用&#96;（着重号）引起来</li>
<li>保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了</li>
</ul>
<h3 id="1-3-MySQL中的数据类型"><a href="#1-3-MySQL中的数据类型" class="headerlink" title="1.3 MySQL中的数据类型"></a>1.3 MySQL中的数据类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>类型举例</th>
</tr>
</thead>
<tbody><tr>
<td>整数类型</td>
<td>TINYINT、SMALLINT、MEDIUMINT、<strong>INT(或INTEGER)</strong>、BIGINT</td>
</tr>
<tr>
<td>浮点类型</td>
<td>FLOAT、DOUBLE</td>
</tr>
<tr>
<td>定点数类型</td>
<td><strong>DECIMAL</strong></td>
</tr>
<tr>
<td>位类型</td>
<td>BIT</td>
</tr>
<tr>
<td>日期时间类型</td>
<td>YEAR、TIME、<strong>DATE</strong>、DATETIME、TIMESTAMP</td>
</tr>
<tr>
<td>文本字符串类型</td>
<td>CHAR、<strong>VARCHAR</strong>、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td>
</tr>
<tr>
<td>枚举类型</td>
<td>ENUM</td>
</tr>
<tr>
<td>集合类型</td>
<td>SET</td>
</tr>
<tr>
<td>二进制字符串类型</td>
<td>BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td>
</tr>
<tr>
<td>JSON类型</td>
<td>JSON对象、JSON数组</td>
</tr>
<tr>
<td>空间数据类型</td>
<td>单值：GEOMETRY、POINT、LINESTRING、POLYGON；<br/>集合：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION</td>
</tr>
</tbody></table>
<p>其中，常用的几类类型介绍如下：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>INT</td>
<td>从-2^31到2^31-1的整型数据。存储大小为 4个字节</td>
</tr>
<tr>
<td>CHAR(size)</td>
<td>定长字符数据。若未指定，默认为1个字符，最大长度255</td>
</tr>
<tr>
<td>VARCHAR(size)</td>
<td>可变长字符数据，根据字符串实际长度保存，<strong>必须指定长度</strong></td>
</tr>
<tr>
<td>FLOAT(M,D)</td>
<td>单精度，占用4个字节，M&#x3D;整数位+小数位，D&#x3D;小数位。 D&lt;&#x3D;M&lt;&#x3D;255,0&lt;&#x3D;D&lt;&#x3D;30，默认M+D&lt;&#x3D;6</td>
</tr>
<tr>
<td>DOUBLE(M,D)</td>
<td>双精度，占用8个字节，D&lt;&#x3D;M&lt;&#x3D;255,0&lt;&#x3D;D&lt;&#x3D;30，默认M+D&lt;&#x3D;15</td>
</tr>
<tr>
<td>DECIMAL(M,D)</td>
<td>高精度小数，占用M+2个字节，D&lt;&#x3D;M&lt;&#x3D;65，0&lt;&#x3D;D&lt;&#x3D;30，最大取值范围与DOUBLE相同。</td>
</tr>
<tr>
<td>DATE</td>
<td>日期型数据，格式’YYYY-MM-DD’</td>
</tr>
<tr>
<td>BLOB</td>
<td>二进制形式的长文本数据，最大可达4G</td>
</tr>
<tr>
<td>TEXT</td>
<td>长文本数据，最大可达4G</td>
</tr>
</tbody></table>
<h2 id="2-创建和管理数据库"><a href="#2-创建和管理数据库" class="headerlink" title="2. 创建和管理数据库"></a>2. 创建和管理数据库</h2><h3 id="2-1-创建数据库"><a href="#2-1-创建数据库" class="headerlink" title="2.1 创建数据库"></a>2.1 创建数据库</h3><ul>
<li>方式1：创建数据库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE 数据库名; </span><br></pre></td></tr></table></figure>

<ul>
<li>方式2：创建数据库并指定字符集</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE 数据库名 CHARACTER SET 字符集;</span><br></pre></td></tr></table></figure>

<ul>
<li>方式3：判断数据库是否已经存在，不存在则创建数据库（<code>推荐</code>）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE IF NOT EXISTS 数据库名; </span><br></pre></td></tr></table></figure>

<p>如果MySQL中已经存在相关的数据库，则忽略创建语句，不再创建数据库。</p>
<blockquote>
<p>注意：DATABASE 不能改名。一些可视化工具可以改名，它是建新库，把所有表复制到新库，再删旧库完成的。</p>
</blockquote>
<h3 id="2-2-使用数据库"><a href="#2-2-使用数据库" class="headerlink" title="2.2 使用数据库"></a>2.2 使用数据库</h3><ul>
<li>查看当前所有的数据库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW DATABASES; #有一个S，代表多个数据库</span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前正在使用的数据库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DATABASE();  #使用的一个 mysql 中的全局函数</span><br></pre></td></tr></table></figure>

<ul>
<li>查看指定库下所有的表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLES FROM 数据库名;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看数据库的创建信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE DATABASE 数据库名;</span><br><span class="line">或者：</span><br><span class="line">SHOW CREATE DATABASE 数据库名\G</span><br></pre></td></tr></table></figure>

<ul>
<li>使用&#x2F;切换数据库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：要操作表格和数据之前必须先说明是对哪个数据库进行操作，否则就要对所有对象加上“数据库名.”。</p>
</blockquote>
<h3 id="2-3-修改数据库"><a href="#2-3-修改数据库" class="headerlink" title="2.3 修改数据库"></a>2.3 修改数据库</h3><ul>
<li>更改数据库字符集</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER DATABASE 数据库名 CHARACTER SET 字符集;  #比如：gbk、utf8等</span><br></pre></td></tr></table></figure>

<h3 id="2-4-删除数据库"><a href="#2-4-删除数据库" class="headerlink" title="2.4 删除数据库"></a>2.4 删除数据库</h3><ul>
<li>方式1：删除指定的数据库</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE 数据库名;</span><br></pre></td></tr></table></figure>

<ul>
<li>方式2：删除指定的数据库（<code>推荐</code>）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS 数据库名;</span><br></pre></td></tr></table></figure>

<h2 id="3-创建表"><a href="#3-创建表" class="headerlink" title="3. 创建表"></a>3. 创建表</h2><h3 id="3-1-创建方式1"><a href="#3-1-创建方式1" class="headerlink" title="3.1 创建方式1"></a>3.1 创建方式1</h3><ul>
<li><strong>必须具备：</strong><ul>
<li>CREATE TABLE权限</li>
<li>存储空间</li>
</ul>
</li>
<li><strong>语法格式：</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE [IF NOT EXISTS] 表名(</span><br><span class="line">	字段1, 数据类型 [约束条件] [默认值],</span><br><span class="line">	字段2, 数据类型 [约束条件] [默认值],</span><br><span class="line">	字段3, 数据类型 [约束条件] [默认值],</span><br><span class="line">	……</span><br><span class="line">	[表约束条件]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>加上了IF NOT EXISTS关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表；如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。</p>
</blockquote>
<ul>
<li><strong>必须指定：</strong><ul>
<li>表名</li>
<li>列名(或字段名)，数据类型，<strong>长度</strong></li>
</ul>
</li>
<li><strong>可选指定：</strong><ul>
<li>约束条件</li>
<li>默认值</li>
</ul>
</li>
<li>创建表举例1：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建表</span><br><span class="line">CREATE TABLE emp (</span><br><span class="line">  -- int类型</span><br><span class="line">  emp_id INT,</span><br><span class="line">  -- 最多保存20个中英文字符</span><br><span class="line">  emp_name VARCHAR(20),</span><br><span class="line">  -- 总位数不超过15位</span><br><span class="line">  salary DOUBLE,</span><br><span class="line">  -- 日期类型</span><br><span class="line">  birthday DATE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC emp;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211016160557995.png"
                        alt="image-20211016160557995"
                 ></p>
<p>MySQL在执行建表语句时，将id字段的类型设置为int(11)，这里的11实际上是int类型指定的显示宽度，默认的显示宽度为11。也可以在创建数据表的时候指定数据的显示宽度。</p>
<ul>
<li>创建表举例2：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE dept(</span><br><span class="line">    -- int类型，自增</span><br><span class="line">	deptno INT(2) AUTO_INCREMENT,</span><br><span class="line">	dname VARCHAR(14),</span><br><span class="line">	loc VARCHAR(13),</span><br><span class="line">    -- 主键</span><br><span class="line">    PRIMARY KEY (deptno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESCRIBE dept;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211016160643445.png"
                        alt="image-20211016160643445"
                 ></p>
<blockquote>
<p>在MySQL 8.x版本中，不再推荐为INT类型指定显示长度，并在未来的版本中可能去掉这样的语法。</p>
</blockquote>
<h3 id="3-2-创建方式2"><a href="#3-2-创建方式2" class="headerlink" title="3.2 创建方式2"></a>3.2 创建方式2</h3><ul>
<li><p>使用 AS subquery 选项，<strong>将创建表和插入数据结合起来</strong></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554997882872.png"
                        alt="1554997882872"
                 ></p>
</li>
<li><p>指定的列和子查询中的列要一一对应</p>
</li>
<li><p>通过列名和默认值定义列</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE emp1 AS SELECT * FROM employees;</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp2 AS SELECT * FROM employees WHERE 1=2; -- 创建的emp2是空表</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE dept80</span><br><span class="line">AS </span><br><span class="line">SELECT  employee_id, last_name, salary*12 ANNSAL, hire_date</span><br><span class="line">FROM    employees</span><br><span class="line">WHERE   department_id = 80;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESCRIBE dept80;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554997998148.png"
                        alt="1554997998148"
                 ></p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554998004494.png"
                        alt="1554998004494"
                 ></p>
<h3 id="3-3-查看数据表结构"><a href="#3-3-查看数据表结构" class="headerlink" title="3.3 查看数据表结构"></a>3.3 查看数据表结构</h3><p>在MySQL中创建好数据表之后，可以查看数据表的结构。MySQL支持使用<code>DESCRIBE/DESC</code>语句查看数据表结构，也支持使用<code>SHOW CREATE TABLE</code>语句查看数据表结构。</p>
<p>语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名\G</span><br></pre></td></tr></table></figure>

<p>使用SHOW CREATE TABLE语句不仅可以查看表创建时的详细语句，还可以查看存储引擎和字符编码。</p>
<h2 id="4-修改表"><a href="#4-修改表" class="headerlink" title="4. 修改表"></a>4. 修改表</h2><p>修改表指的是修改数据库中已经存在的数据表的结构。</p>
<p><strong>使用 ALTER TABLE 语句可以实现：</strong></p>
<ul>
<li><p>向已有的表中添加列</p>
</li>
<li><p>修改现有表中的列</p>
</li>
<li><p>删除现有表中的列</p>
</li>
<li><p>重命名现有表中的列</p>
</li>
</ul>
<h3 id="4-1-追加一个列"><a href="#4-1-追加一个列" class="headerlink" title="4.1 追加一个列"></a>4.1 追加一个列</h3><p>语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD 【COLUMN】 字段名 字段类型 【FIRST|AFTER 字段名】;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE dept80 </span><br><span class="line">ADD job_id varchar(15);</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1554998139815.png"
                        alt="1554998139815"
                 ></p>
<h3 id="4-2-修改一个列"><a href="#4-2-修改一个列" class="headerlink" title="4.2 修改一个列"></a>4.2 修改一个列</h3><ul>
<li><p>可以修改列的数据类型，长度、默认值和位置</p>
</li>
<li><p>修改字段数据类型、长度、默认值、位置的语法格式如下：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 【COLUMN】 字段名1 字段类型 【DEFAULT 默认值】【FIRST|AFTER 字段名2】;</span><br></pre></td></tr></table></figure>

<ul>
<li>举例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE	dept80</span><br><span class="line">MODIFY last_name VARCHAR(30);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE	dept80</span><br><span class="line">MODIFY salary double(9,2) default 1000;</span><br></pre></td></tr></table></figure>

<ul>
<li>对默认值的修改只影响今后对表的修改</li>
<li>此外，还可以通过此种方式修改列的约束。这里暂先不讲。</li>
</ul>
<h3 id="4-3-重命名一个列"><a href="#4-3-重命名一个列" class="headerlink" title="4.3 重命名一个列"></a>4.3 重命名一个列</h3><p>使用 CHANGE old_column  new_column  dataType子句重命名列。语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 CHANGE 【column】 列名 新列名 新数据类型;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE  dept80</span><br><span class="line">CHANGE department_name dept_name varchar(15); </span><br></pre></td></tr></table></figure>

<h3 id="4-4-删除一个列"><a href="#4-4-删除一个列" class="headerlink" title="4.4 删除一个列"></a>4.4 删除一个列</h3><p>删除表中某个字段的语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP 【COLUMN】字段名</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE  dept80</span><br><span class="line">DROP COLUMN  job_id; </span><br></pre></td></tr></table></figure>

<h2 id="5-重命名表"><a href="#5-重命名表" class="headerlink" title="5. 重命名表"></a>5. 重命名表</h2><ul>
<li>方式一：使用RENAME</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RENAME TABLE emp</span><br><span class="line">TO myemp;</span><br></pre></td></tr></table></figure>

<ul>
<li>方式二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER table dept</span><br><span class="line">RENAME [TO] detail_dept;  -- [TO]可以省略</span><br></pre></td></tr></table></figure>

<ul>
<li>必须是对象的拥有者</li>
</ul>
<h2 id="6-删除表"><a href="#6-删除表" class="headerlink" title="6. 删除表"></a>6. 删除表</h2><ul>
<li><p>在MySQL中，当一张数据表<code>没有与其他任何数据表形成关联关系</code>时，可以将当前数据表直接删除。</p>
</li>
<li><p>数据和结构都被删除</p>
</li>
<li><p>所有正在运行的相关事务被提交</p>
</li>
<li><p>所有相关索引被删除</p>
</li>
<li><p>语法格式：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] 数据表1 [, 数据表2, …, 数据表n];</span><br></pre></td></tr></table></figure>

<p><code>IF EXISTS</code>的含义为：如果当前数据库中存在相应的数据表，则删除数据表；如果当前数据库中不存在相应的数据表，则忽略删除语句，不再执行删除数据表的操作。</p>
<ul>
<li>举例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE dept80;</span><br></pre></td></tr></table></figure>

<ul>
<li>DROP TABLE 语句不能回滚</li>
</ul>
<h2 id="7-清空表"><a href="#7-清空表" class="headerlink" title="7. 清空表"></a>7. 清空表</h2><ul>
<li><p>TRUNCATE TABLE语句：</p>
<ul>
<li>删除表中所有的数据</li>
<li>释放表的存储空间</li>
</ul>
</li>
<li><p>举例：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TRUNCATE TABLE detail_dept;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>TRUNCATE语句<strong>不能回滚</strong>，而使用 DELETE 语句删除数据，可以回滚</p>
</li>
<li><p>对比：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET autocommit = FALSE;</span><br><span class="line">  </span><br><span class="line">DELETE FROM emp2; </span><br><span class="line">#TRUNCATE TABLE emp2;</span><br><span class="line">  </span><br><span class="line">SELECT * FROM emp2;</span><br><span class="line">  </span><br><span class="line">ROLLBACK;</span><br><span class="line">  </span><br><span class="line">SELECT * FROM emp2;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>阿里开发规范：</p>
<p>【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 TRIGGER，有可能造成事故，故不建议在开发代码中使用此语句。</p>
<p>说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p>
</blockquote>
<h2 id="8-内容拓展"><a href="#8-内容拓展" class="headerlink" title="8. 内容拓展"></a>8. 内容拓展</h2><h3 id="拓展1：阿里巴巴《Java开发手册》之MySQL字段命名"><a href="#拓展1：阿里巴巴《Java开发手册》之MySQL字段命名" class="headerlink" title="拓展1：阿里巴巴《Java开发手册》之MySQL字段命名"></a>拓展1：阿里巴巴《Java开发手册》之MySQL字段命名</h3><ul>
<li><p>【<code>强制</code>】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p>
<ul>
<li>正例：aliyun_admin，rdc_config，level3_name</li>
<li>反例：AliyunAdmin，rdcConfig，level_3_name</li>
</ul>
</li>
<li><p>【<code>强制</code>】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</p>
</li>
<li><p>【<code>强制</code>】表必备三字段：id, gmt_create, gmt_modified。</p>
<ul>
<li>说明：其中 id 必为主键，类型为BIGINT UNSIGNED、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 DATETIME 类型，前者现在时表示主动式创建，后者过去分词表示被动式更新</li>
</ul>
</li>
<li><p>【<code>推荐</code>】表的命名最好是遵循 “业务名称_表的作用”。</p>
<ul>
<li>正例：alipay_task 、 force_project、 trade_config</li>
</ul>
</li>
<li><p>【<code>推荐</code>】库名与应用名称尽量一致。</p>
</li>
<li><p>【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。</p>
<ul>
<li>正例：无符号值可以避免误存负数，且扩大了表示范围。</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211024012735469.png"
                        alt="image-20211024012735469"
                 ></p>
</li>
</ul>
<h3 id="拓展2：如何理解清空表、删除表等操作需谨慎？！"><a href="#拓展2：如何理解清空表、删除表等操作需谨慎？！" class="headerlink" title="拓展2：如何理解清空表、删除表等操作需谨慎？！"></a>拓展2：如何理解清空表、删除表等操作需谨慎？！</h3><p><code>表删除</code>操作将把表的定义和表中的数据一起删除，并且MySQL在执行删除操作时，不会有任何的确认信息提示，因此执行删除操时应当慎重。在删除表前，最好对表中的数据进行<code>备份</code>，这样当操作失误时可以对数据进行恢复，以免造成无法挽回的后果。</p>
<p>同样的，在使用 <code>ALTER TABLE</code> 进行表的基本修改操作时，在执行操作过程之前，也应该确保对数据进行完整的<code>备份</code>，因为数据库的改变是<code>无法撤销</code>的，如果添加了一个不需要的字段，可以将其删除；相同的，如果删除了一个需要的列，该列下面的所有数据都将会丢失。</p>
<h3 id="拓展3：MySQL8新特性—DDL的原子化"><a href="#拓展3：MySQL8新特性—DDL的原子化" class="headerlink" title="拓展3：MySQL8新特性—DDL的原子化"></a>拓展3：MySQL8新特性—DDL的原子化</h3><p>在MySQL 8.0版本中，InnoDB表的DDL支持事务完整性，即<code>DDL操作要么成功要么回滚</code>。DDL操作回滚日志写入到data dictionary数据字典表mysql.innodb_ddl_log（该表是隐藏的表，通过show tables无法看到）中，用于回滚操作。通过设置参数，可将DDL操作日志打印输出到MySQL错误日志中。</p>
<p>分别在MySQL 5.7版本和MySQL 8.0版本中创建数据库和数据表，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE mytest;</span><br><span class="line"></span><br><span class="line">USE mytest;</span><br><span class="line"></span><br><span class="line">CREATE TABLE book1(</span><br><span class="line">book_id INT ,</span><br><span class="line">book_name VARCHAR(255)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure>

<p>（1）在MySQL 5.7版本中，测试步骤如下：<br>删除数据表book1和数据表book2，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; DROP TABLE book1,book2;</span><br><span class="line">ERROR 1051 (42S02): Unknown table &#x27;mytest.book2&#x27;</span><br></pre></td></tr></table></figure>

<p>再次查询数据库中的数据表名称，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>从结果可以看出，虽然删除操作时报错了，但是仍然删除了数据表book1。</p>
<p>（2）在MySQL 8.0版本中，测试步骤如下：<br>删除数据表book1和数据表book2，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; DROP TABLE book1,book2;</span><br><span class="line">ERROR 1051 (42S02): Unknown table &#x27;mytest.book2&#x27;</span><br></pre></td></tr></table></figure>

<p>再次查询数据库中的数据表名称，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br><span class="line">+------------------+</span><br><span class="line">| Tables_in_mytest |</span><br><span class="line">+------------------+</span><br><span class="line">| book1            |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>从结果可以看出，数据表book1并没有被删除。</p>
<hr>
<h1 id="第11章-数据处理之增删改"><a href="#第11章-数据处理之增删改" class="headerlink" title="第11章_数据处理之增删改"></a>第11章_数据处理之增删改</h1><hr>
<h2 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1. 插入数据"></a>1. 插入数据</h2><h3 id="1-1-实际问题-1"><a href="#1-1-实际问题-1" class="headerlink" title="1.1 实际问题"></a>1.1 实际问题</h3><img    
                       lazyload
                       alt="image"
                       data-src="MySQL/1555425366064.png"
                         alt="1555425366064" style="zoom:80%;" 
                 >

<p>解决方式：使用 INSERT 语句向表中插入数据。</p>
<h3 id="1-2-方式1：VALUES的方式添加"><a href="#1-2-方式1：VALUES的方式添加" class="headerlink" title="1.2 方式1：VALUES的方式添加"></a>1.2 方式1：VALUES的方式添加</h3><p>使用这种语法一次只能向表中插入<strong>一条</strong>数据。</p>
<p><strong>情况1：为表的所有字段按默认顺序插入数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名</span><br><span class="line">VALUES (value1,value2,....);</span><br></pre></td></tr></table></figure>

<p>值列表中需要为表的每一个字段指定值，并且值的顺序必须和数据表中字段定义时的顺序相同。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO departments</span><br><span class="line">VALUES (70, &#x27;Pub&#x27;, 100, 1700);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO	departments</span><br><span class="line">VALUES		(100, &#x27;Finance&#x27;, NULL, NULL);</span><br></pre></td></tr></table></figure>

<p><strong>情况2：为表的指定字段插入数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 表名(column1 [, column2, …, columnn]) </span><br><span class="line">VALUES (value1 [,value2, …, valuen]);</span><br></pre></td></tr></table></figure>

<p>为表的指定字段插入数据，就是在INSERT语句中只向部分字段中插入值，而其他字段的值为表定义时的默认值。</p>
<p>在 INSERT 子句中随意列出列名，但是一旦列出，VALUES中要插入的value1,….valuen需要与column1,…columnn列一一对应。如果类型不同，将无法插入，并且MySQL会产生错误。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO departments(department_id, department_name)</span><br><span class="line">VALUES (80, &#x27;IT&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>情况3：同时插入多条记录</strong></p>
<p>INSERT语句可以同时向数据表中插入多条记录，插入时指定多个值列表，每个值列表之间用逗号分隔开，基本语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO table_name </span><br><span class="line">VALUES </span><br><span class="line">(value1 [,value2, …, valuen]),</span><br><span class="line">(value1 [,value2, …, valuen]),</span><br><span class="line">……</span><br><span class="line">(value1 [,value2, …, valuen]);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO table_name(column1 [, column2, …, columnn]) </span><br><span class="line">VALUES </span><br><span class="line">(value1 [,value2, …, valuen]),</span><br><span class="line">(value1 [,value2, …, valuen]),</span><br><span class="line">……</span><br><span class="line">(value1 [,value2, …, valuen]);</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; INSERT INTO emp(emp_id,emp_name)</span><br><span class="line">    -&gt; VALUES (1001,&#x27;shkstart&#x27;),</span><br><span class="line">    -&gt; (1002,&#x27;atguigu&#x27;),</span><br><span class="line">    -&gt; (1003,&#x27;Tom&#x27;);</span><br><span class="line">Query OK, 3 rows affected (0.00 sec)</span><br><span class="line">Records: 3  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>

<p>使用INSERT同时插入多条记录时，MySQL会返回一些在执行单行插入时没有的额外信息，这些信息的含义如下：<br>●　Records：表明插入的记录条数。<br>●　Duplicates：表明插入时被忽略的记录，原因可能是这些记录包含了重复的主键值。<br>●　Warnings：表明有问题的数据值，例如发生数据类型转换。</p>
<blockquote>
<p>一个同时插入多行记录的INSERT语句等同于多个单行插入的INSERT语句，但是多行的INSERT语句在处理过程中<code>效率更高</code>。因为MySQL执行单条INSERT语句插入多行数据比使用多条INSERT语句快，所以在插入多条记录时最好选择使用单条INSERT语句的方式插入。</p>
</blockquote>
<p><strong>小结：</strong></p>
<ul>
<li><p><code>VALUES</code>也可以写成<code>VALUE</code>，但是VALUES是标准写法。</p>
</li>
<li><p>字符和日期型数据应包含在单引号中。</p>
</li>
</ul>
<h3 id="1-3-方式2：将查询结果插入到表中"><a href="#1-3-方式2：将查询结果插入到表中" class="headerlink" title="1.3 方式2：将查询结果插入到表中"></a>1.3 方式2：将查询结果插入到表中</h3><p>INSERT还可以将SELECT语句查询的结果插入到表中，此时不需要把每一条记录的值一个一个输入，只需要使用一条INSERT语句和一条SELECT语句组成的组合语句即可快速地从一个或多个表中向一个表中插入多行。</p>
<p>基本语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO 目标表名</span><br><span class="line">(tar_column1 [, tar_column2, …, tar_columnn])</span><br><span class="line">SELECT</span><br><span class="line">(src_column1 [, src_column2, …, src_columnn])</span><br><span class="line">FROM 源表名</span><br><span class="line">[WHERE condition]</span><br></pre></td></tr></table></figure>

<ul>
<li>在 INSERT 语句中加入子查询。</li>
<li><strong>不必书写</strong> <strong>VALUES</strong> <strong>子句。</strong></li>
<li>子查询中的值列表应与 INSERT 子句中的列名对应。</li>
</ul>
<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> emp2 </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">90</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> sales_reps(id, name, salary, commission_pct)</span><br><span class="line"><span class="keyword">SELECT</span> employee_id, last_name, salary, commission_pct</span><br><span class="line"><span class="keyword">FROM</span>   employees</span><br><span class="line"><span class="keyword">WHERE</span>  job_id <span class="keyword">LIKE</span> <span class="string">&#x27;%REP%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-更新数据"><a href="#2-更新数据" class="headerlink" title="2. 更新数据"></a>2. 更新数据</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1555425824246.png"
                        alt="1555425824246"
                 ></p>
<ul>
<li>使用 UPDATE 语句更新数据。语法如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE table_name</span><br><span class="line">SET column1=value1, column2=value2, … , column=valuen</span><br><span class="line">[WHERE condition]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>可以一次更新<strong>多条</strong>数据。</p>
</li>
<li><p>如果需要回滚数据，需要保证在DML前，进行设置：<strong>SET AUTOCOMMIT &#x3D; FALSE;</strong></p>
</li>
</ul>
<hr>
<ul>
<li>使用 <strong>WHERE</strong> 子句指定需要更新的数据。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span>    department_id <span class="operator">=</span> <span class="number">70</span></span><br><span class="line"><span class="keyword">WHERE</span>  employee_id <span class="operator">=</span> <span class="number">113</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果省略 WHERE 子句，则表中的所有数据都将被更新。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 	copy_emp</span><br><span class="line"><span class="keyword">SET</span>    	department_id <span class="operator">=</span> <span class="number">110</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>更新中的数据完整性错误</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> employees</span><br><span class="line"><span class="keyword">SET</span>    department_id <span class="operator">=</span> <span class="number">55</span></span><br><span class="line"><span class="keyword">WHERE</span>  department_id <span class="operator">=</span> <span class="number">110</span>;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1555426069578.png"
                        alt="1555426069578"
                 ></p>
<blockquote>
<p>说明：不存在 55 号部门</p>
</blockquote>
<h2 id="3-删除数据"><a href="#3-删除数据" class="headerlink" title="3. 删除数据"></a>3. 删除数据</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1555426124751.png"
                        alt="1555426124751"
                 ></p>
<ul>
<li>使用 DELETE 语句从表中删除数据</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1555426162264.png"
                        alt="1555426162264"
                 ></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM table_name [WHERE &lt;condition&gt;];</span><br></pre></td></tr></table></figure>

<p>table_name指定要执行删除操作的表；“[WHERE <condition>]”为可选参数，指定删除条件，如果没有WHERE子句，DELETE语句将删除表中的所有记录。</p>
<ul>
<li>使用 WHERE 子句删除指定的记录。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> departments</span><br><span class="line"><span class="keyword">WHERE</span>  department_name <span class="operator">=</span> <span class="string">&#x27;Finance&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果省略 WHERE 子句，则表中的全部数据将被删除</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span>  copy_emp;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>删除中的数据完整性错误</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> departments</span><br><span class="line"><span class="keyword">WHERE</span>       department_id <span class="operator">=</span> <span class="number">60</span>;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1555426258516.png"
                        alt="1555426258516"
                 ></p>
<blockquote>
<p>说明：You cannot delete a row that contains a primary key that is used as a foreign key in another table.</p>
</blockquote>
<h2 id="4-MySQL8新特性：计算列"><a href="#4-MySQL8新特性：计算列" class="headerlink" title="4. MySQL8新特性：计算列"></a>4. MySQL8新特性：计算列</h2><p>什么叫计算列呢？简单来说就是某一列的值是通过别的列计算得来的。例如，a列值为1、b列值为2，c列不需要手动插入，定义a+b的结果为c的值，那么c就是计算列，是通过别的列计算得来的。</p>
<p>在MySQL 8.0中，CREATE TABLE 和 ALTER TABLE 中都支持增加计算列。下面以CREATE TABLE为例进行讲解。</p>
<p>举例：定义数据表tb1，然后定义字段id、字段a、字段b和字段c，其中字段c为计算列，用于计算a+b的值。<br>首先创建测试表tb1，语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE tb1(</span><br><span class="line">id INT,</span><br><span class="line">a INT,</span><br><span class="line">b INT,</span><br><span class="line">c INT GENERATED ALWAYS AS (a + b) VIRTUAL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>插入演示数据，语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO tb1(a,b) VALUES (100,200);</span><br></pre></td></tr></table></figure>

<p>查询数据表tb1中的数据，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM tb1;</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| id   | a    | b    | c    |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">| NULL |  100 |  200 |  300 |</span><br><span class="line">+------+------+------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>更新数据中的数据，语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; UPDATE tb1 SET a = 500;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 0  Warnings: 0</span><br></pre></td></tr></table></figure>

<h2 id="5-综合案例"><a href="#5-综合案例" class="headerlink" title="5. 综合案例"></a>5. 综合案例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1、创建数据库test01_library</span><br><span class="line"></span><br><span class="line"># 2、创建表 books，表结构如下：</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>字段名</th>
<th>字段说明</th>
<th>数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>书编号</td>
<td>INT</td>
</tr>
<tr>
<td>name</td>
<td>书名</td>
<td>VARCHAR(50)</td>
</tr>
<tr>
<td>authors</td>
<td>作者</td>
<td>VARCHAR(100)</td>
</tr>
<tr>
<td>price</td>
<td>价格</td>
<td>FLOAT</td>
</tr>
<tr>
<td>pubdate</td>
<td>出版日期</td>
<td>YEAR</td>
</tr>
<tr>
<td>note</td>
<td>说明</td>
<td>VARCHAR(100)</td>
</tr>
<tr>
<td>num</td>
<td>库存</td>
<td>INT</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 3、向books表中插入记录</span><br><span class="line"></span><br><span class="line"># 1）不指定字段名称，插入第一条记录</span><br><span class="line"># 2）指定所有字段名称，插入第二记录</span><br><span class="line"># 3）同时插入多条记录（剩下的所有记录）</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>authors</th>
<th>price</th>
<th>pubdate</th>
<th>note</th>
<th>num</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Tal of AAA</td>
<td>Dickes</td>
<td>23</td>
<td>1995</td>
<td>novel</td>
<td>11</td>
</tr>
<tr>
<td>2</td>
<td>EmmaT</td>
<td>Jane lura</td>
<td>35</td>
<td>1993</td>
<td>joke</td>
<td>22</td>
</tr>
<tr>
<td>3</td>
<td>Story of Jane</td>
<td>Jane Tim</td>
<td>40</td>
<td>2001</td>
<td>novel</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>Lovey Day</td>
<td>George Byron</td>
<td>20</td>
<td>2005</td>
<td>novel</td>
<td>30</td>
</tr>
<tr>
<td>5</td>
<td>Old land</td>
<td>Honore Blade</td>
<td>30</td>
<td>2010</td>
<td>law</td>
<td>0</td>
</tr>
<tr>
<td>6</td>
<td>The Battle</td>
<td>Upton Sara</td>
<td>30</td>
<td>1999</td>
<td>medicine</td>
<td>40</td>
</tr>
<tr>
<td>7</td>
<td>Rose Hood</td>
<td>Richard haggard</td>
<td>28</td>
<td>2008</td>
<td>cartoon</td>
<td>28</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 4、将小说类型(novel)的书的价格都增加5。</span><br><span class="line"></span><br><span class="line"># 5、将名称为EmmaT的书的价格改为40，并将说明改为drama。</span><br><span class="line"></span><br><span class="line"># 6、删除库存为0的记录。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 7、统计书名中包含a字母的书</span><br><span class="line"></span><br><span class="line"># 8、统计书名中包含a字母的书的数量和库存总量</span><br><span class="line"></span><br><span class="line"># 9、找出“novel”类型的书，按照价格降序排列</span><br><span class="line"></span><br><span class="line"># 10、查询图书信息，按照库存量降序排列，如果库存量相同的按照note升序排列</span><br><span class="line"></span><br><span class="line"># 11、按照note分类统计书的数量</span><br><span class="line"></span><br><span class="line"># 12、按照note分类统计书的库存量，显示库存量超过30本的</span><br><span class="line"></span><br><span class="line"># 13、查询所有图书，每页显示5本，显示第二页</span><br><span class="line"></span><br><span class="line"># 14、按照note分类统计书的库存量，显示库存量最多的</span><br><span class="line"></span><br><span class="line"># 15、查询书名达到10个字符的书，不包括里面的空格</span><br><span class="line"></span><br><span class="line"># 16、查询书名和类型，其中note值为novel显示小说，law显示法律，medicine显示医药，cartoon显示卡通，joke显示笑话</span><br><span class="line"></span><br><span class="line"># 17、查询书名、库存，其中num值超过30本的，显示滞销，大于0并低于10的，显示畅销，为0的显示需要无货</span><br><span class="line"></span><br><span class="line"># 18、统计每一种note的库存量，并合计总量</span><br><span class="line"></span><br><span class="line"># 19、统计每一种note的数量，并合计总量</span><br><span class="line"></span><br><span class="line"># 20、统计库存量前三名的图书</span><br><span class="line"></span><br><span class="line"># 21、找出最早出版的一本书</span><br><span class="line"></span><br><span class="line"># 22、找出novel中价格最高的一本书</span><br><span class="line"></span><br><span class="line"># 23、找出书名中字数最多的一本书，不含空格</span><br></pre></td></tr></table></figure>

<p>答案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#1、创建数据库test01_library</span><br><span class="line">CREATE DATABASE IF NOT EXISTS test01_library CHARACTER SET &#x27;utf8&#x27;;</span><br><span class="line"></span><br><span class="line">#指定使用哪个数据库</span><br><span class="line">USE test01_library;</span><br><span class="line"></span><br><span class="line">#2、创建表 books</span><br><span class="line">CREATE TABLE books(</span><br><span class="line">	id INT,</span><br><span class="line">	name VARCHAR(50),</span><br><span class="line">	`authors` VARCHAR(100) ,</span><br><span class="line">	price FLOAT,</span><br><span class="line">	pubdate YEAR ,</span><br><span class="line">	note VARCHAR(100),</span><br><span class="line">	num INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#3、向books表中插入记录</span><br><span class="line"># 1）不指定字段名称，插入第一条记录</span><br><span class="line">INSERT INTO books </span><br><span class="line">VALUES(1,&#x27;Tal of AAA&#x27;,&#x27;Dickes&#x27;,23,1995,&#x27;novel&#x27;,11);</span><br><span class="line"># 2）指定所有字段名称，插入第二记录</span><br><span class="line">INSERT INTO books (id,name,`authors`,price,pubdate,note,num)</span><br><span class="line">VALUES(2,&#x27;EmmaT&#x27;,&#x27;Jane lura&#x27;,35,1993,&#x27;Joke&#x27;,22);</span><br><span class="line"># 3）同时插入多条记录（剩下的所有记录）</span><br><span class="line">INSERT INTO books (id,name,`authors`,price,pubdate,note,num) VALUES</span><br><span class="line">(3,&#x27;Story of Jane&#x27;,&#x27;Jane Tim&#x27;,40,2001,&#x27;novel&#x27;,0),</span><br><span class="line">(4,&#x27;Lovey Day&#x27;,&#x27;George Byron&#x27;,20,2005,&#x27;novel&#x27;,30),</span><br><span class="line">(5,&#x27;Old land&#x27;,&#x27;Honore Blade&#x27;,30,2010,&#x27;Law&#x27;,0),</span><br><span class="line">(6,&#x27;The Battle&#x27;,&#x27;Upton Sara&#x27;,30,1999,&#x27;medicine&#x27;,40),</span><br><span class="line">(7,&#x27;Rose Hood&#x27;,&#x27;Richard haggard&#x27;,28,2008,&#x27;cartoon&#x27;,28);</span><br><span class="line"></span><br><span class="line"># 4、将小说类型(novel)的书的价格都增加5。</span><br><span class="line">UPDATE books SET price=price+5 WHERE note = &#x27;novel&#x27;;</span><br><span class="line"></span><br><span class="line"># 5、将名称为EmmaT的书的价格改为40，并将说明改为drama。</span><br><span class="line">UPDATE books SET price=40,note=&#x27;drama&#x27; WHERE name=&#x27;EmmaT&#x27;;</span><br><span class="line"></span><br><span class="line"># 6、删除库存为0的记录。</span><br><span class="line">DELETE FROM books WHERE num=0;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 7、统计书名中包含a字母的书</span><br><span class="line">SELECT * FROM books WHERE name LIKE &#x27;%a%&#x27;;</span><br><span class="line"></span><br><span class="line"># 8、统计书名中包含a字母的书的数量和库存总量</span><br><span class="line">SELECT COUNT(*),SUM(num) FROM books WHERE name LIKE &#x27;%a%&#x27;;</span><br><span class="line"></span><br><span class="line"># 9、找出“novel”类型的书，按照价格降序排列</span><br><span class="line">SELECT * FROM books WHERE note = &#x27;novel&#x27; ORDER BY price DESC;</span><br><span class="line"></span><br><span class="line"># 10、查询图书信息，按照库存量降序排列，如果库存量相同的按照note升序排列</span><br><span class="line">SELECT * FROM books ORDER BY num DESC,note ASC;</span><br><span class="line"></span><br><span class="line"># 11、按照note分类统计书的数量</span><br><span class="line">SELECT note,COUNT(*) FROM books GROUP BY note;</span><br><span class="line"></span><br><span class="line"># 12、按照note分类统计书的库存量，显示库存量超过30本的</span><br><span class="line">SELECT note,SUM(num) FROM books GROUP BY note HAVING SUM(num)&gt;30;</span><br><span class="line"></span><br><span class="line"># 13、查询所有图书，每页显示5本，显示第二页</span><br><span class="line">SELECT * FROM books LIMIT 5,5;</span><br><span class="line"></span><br><span class="line"># 14、按照note分类统计书的库存量，显示库存量最多的</span><br><span class="line">SELECT note,SUM(num) sum_num FROM books GROUP BY note ORDER BY sum_num DESC LIMIT 0,1;</span><br><span class="line"></span><br><span class="line"># 15、查询书名达到10个字符的书，不包括里面的空格</span><br><span class="line">SELECT * FROM books WHERE CHAR_LENGTH(REPLACE(name,&#x27; &#x27;,&#x27;&#x27;))&gt;=10;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">16、查询书名和类型，</span><br><span class="line"> 其中note值为 novel显示小说，law显示法律，medicine显示医药，cartoon显示卡通，joke显示笑话</span><br><span class="line">*/</span><br><span class="line">SELECT name AS &quot;书名&quot; ,note, CASE note </span><br><span class="line"> WHEN &#x27;novel&#x27; THEN &#x27;小说&#x27;</span><br><span class="line"> WHEN &#x27;law&#x27; THEN &#x27;法律&#x27;</span><br><span class="line"> WHEN &#x27;medicine&#x27; THEN &#x27;医药&#x27;</span><br><span class="line"> WHEN &#x27;cartoon&#x27; THEN &#x27;卡通&#x27;</span><br><span class="line"> WHEN &#x27;joke&#x27; THEN &#x27;笑话&#x27;</span><br><span class="line"> END AS &quot;类型&quot;</span><br><span class="line">FROM books;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 17、查询书名、库存，其中num值超过30本的，显示滞销，大于0并低于10的，显示畅销，为0的显示需要无货</span><br><span class="line">SELECT name,num,CASE </span><br><span class="line">  WHEN num&gt;30 THEN &#x27;滞销&#x27;</span><br><span class="line">  WHEN num&gt;0 AND num&lt;10 THEN &#x27;畅销&#x27;</span><br><span class="line">  WHEN num=0 THEN &#x27;无货&#x27;</span><br><span class="line">  ELSE &#x27;正常&#x27;</span><br><span class="line">  END AS &quot;库存状态&quot;</span><br><span class="line">FROM books;</span><br><span class="line"></span><br><span class="line"># 18、统计每一种note的库存量，并合计总量</span><br><span class="line">SELECT IFNULL(note,&#x27;合计总库存量&#x27;) AS note,SUM(num) FROM books GROUP BY note WITH ROLLUP;</span><br><span class="line"></span><br><span class="line"># 19、统计每一种note的数量，并合计总量</span><br><span class="line">SELECT IFNULL(note,&#x27;合计总数&#x27;) AS note,COUNT(*) FROM books GROUP BY note WITH ROLLUP;</span><br><span class="line"></span><br><span class="line"># 20、统计库存量前三名的图书</span><br><span class="line">SELECT * FROM books ORDER BY num DESC LIMIT 0,3;</span><br><span class="line"></span><br><span class="line"># 21、找出最早出版的一本书</span><br><span class="line">SELECT * FROM books ORDER BY pubdate ASC LIMIT 0,1;</span><br><span class="line"></span><br><span class="line"># 22、找出novel中价格最高的一本书</span><br><span class="line">SELECT * FROM books WHERE note = &#x27;novel&#x27; ORDER BY price DESC LIMIT 0,1;</span><br><span class="line"></span><br><span class="line"># 23、找出书名中字数最多的一本书，不含空格</span><br><span class="line">SELECT * FROM books ORDER BY CHAR_LENGTH(REPLACE(name,&#x27; &#x27;,&#x27;&#x27;)) DESC LIMIT 0,1;</span><br></pre></td></tr></table></figure>




<hr>
<h1 id="第12章-MySQL数据类型精讲"><a href="#第12章-MySQL数据类型精讲" class="headerlink" title="第12章_MySQL数据类型精讲"></a>第12章_MySQL数据类型精讲</h1><hr>
<h2 id="1-MySQL中的数据类型"><a href="#1-MySQL中的数据类型" class="headerlink" title="1. MySQL中的数据类型"></a>1. MySQL中的数据类型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>类型举例</th>
</tr>
</thead>
<tbody><tr>
<td>整数类型</td>
<td>TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT</td>
</tr>
<tr>
<td>浮点类型</td>
<td>FLOAT、DOUBLE</td>
</tr>
<tr>
<td>定点数类型</td>
<td>DECIMAL</td>
</tr>
<tr>
<td>位类型</td>
<td>BIT</td>
</tr>
<tr>
<td>日期时间类型</td>
<td>YEAR、TIME、DATE、DATETIME、TIMESTAMP</td>
</tr>
<tr>
<td>文本字符串类型</td>
<td>CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT</td>
</tr>
<tr>
<td>枚举类型</td>
<td>ENUM</td>
</tr>
<tr>
<td>集合类型</td>
<td>SET</td>
</tr>
<tr>
<td>二进制字符串类型</td>
<td>BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB</td>
</tr>
<tr>
<td>JSON类型</td>
<td>JSON对象、JSON数组</td>
</tr>
<tr>
<td>空间数据类型</td>
<td>单值类型：GEOMETRY、POINT、LINESTRING、POLYGON；<br/>集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION</td>
</tr>
</tbody></table>
<p>常见数据类型的属性，如下：</p>
<table>
<thead>
<tr>
<th>MySQL关键字</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>NULL</td>
<td>数据列可包含NULL值</td>
</tr>
<tr>
<td>NOT NULL</td>
<td>数据列不允许包含NULL值</td>
</tr>
<tr>
<td>DEFAULT</td>
<td>默认值</td>
</tr>
<tr>
<td>PRIMARY KEY</td>
<td>主键</td>
</tr>
<tr>
<td>AUTO_INCREMENT</td>
<td>自动递增，适用于整数类型</td>
</tr>
<tr>
<td>UNSIGNED</td>
<td>无符号</td>
</tr>
<tr>
<td>CHARACTER SET name</td>
<td>指定一个字符集</td>
</tr>
</tbody></table>
<h2 id="2-整数类型"><a href="#2-整数类型" class="headerlink" title="2. 整数类型"></a>2. 整数类型</h2><h3 id="2-1-类型介绍"><a href="#2-1-类型介绍" class="headerlink" title="2.1 类型介绍"></a>2.1 类型介绍</h3><p>整数类型一共有 5 种，包括 TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和 BIGINT。</p>
<p>它们的区别如下表所示：</p>
<table>
<thead>
<tr>
<th><strong>整数类型</strong></th>
<th><strong>字节</strong></th>
<th>有符号数取值范围</th>
<th>无符号数取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>1</td>
<td>-128~127</td>
<td>0~255</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2</td>
<td>-32768~32767</td>
<td>0~65535</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3</td>
<td>-8388608~8388607</td>
<td>0~16777215</td>
</tr>
<tr>
<td>INT、INTEGER</td>
<td>4</td>
<td>-2147483648~2147483647</td>
<td>0~4294967295</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8</td>
<td>-9223372036854775808~9223372036854775807</td>
<td>0~18446744073709551615</td>
</tr>
</tbody></table>
<h3 id="2-2-可选属性"><a href="#2-2-可选属性" class="headerlink" title="2.2 可选属性"></a>2.2 可选属性</h3><p><strong>整数类型的可选属性有三个：</strong></p>
<h4 id="2-2-1-M"><a href="#2-2-1-M" class="headerlink" title="2.2.1 M"></a>2.2.1 M</h4><p><code>M</code>: 表示显示宽度，M的取值范围是(0, 255)。例如，int(5)：当数据宽度小于5位的时候在数字前面需要用字符填满宽度。该项功能需要配合“<code>ZEROFILL</code>”使用，表示用“0”填满宽度，否则指定显示宽度无效。</p>
<p>如果设置了显示宽度，那么插入的数据宽度超过显示宽度限制，会不会截断或插入失败？</p>
<p>答案：不会对插入的数据有任何影响，还是按照类型的实际宽度进行保存，即<code>显示宽度与类型可以存储的值范围无关</code>。<strong>从MySQL 8.0.17开始，整数数据类型不推荐使用显示宽度属性。</strong></p>
<p>整型数据类型可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_int1 ( x TINYINT,　y SMALLINT,　z MEDIUMINT,　m INT,　n BIGINT );</span><br></pre></td></tr></table></figure>

<p>查看表结构 （MySQL5.7中显式如下，MySQL8中不再显式范围）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc test_int1;</span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type         | Null | Key | Default | Extra |</span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">|   x   | tinyint(4)   | YES  |     | NULL    |       |</span><br><span class="line">| 　y   | smallint(6)  | YES  |     | NULL    |       |</span><br><span class="line">| 　z   | mediumint(9) | YES  |     | NULL    |       |</span><br><span class="line">| 　m   | int(11)      | YES  |     | NULL    |       |</span><br><span class="line">| 　n   | bigint(20)   | YES  |     | NULL    |       |</span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>TINYINT有符号数和无符号数的取值范围分别为-128<del>127和0</del>255，由于负号占了一个数字位，因此TINYINT默认的显示宽度为4。同理，其他整数类型的默认显示宽度与其有符号数的最小值的宽度相同。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_int2(</span><br><span class="line">f1 INT,</span><br><span class="line">f2 INT(5),</span><br><span class="line">f3 INT(5) ZEROFILL</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">DESC test_int2;</span><br><span class="line"></span><br><span class="line">INSERT INTO test_int2(f1,f2,f3)</span><br><span class="line">VALUES(1,123,123);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_int2(f1,f2)</span><br><span class="line">VALUES(123456,123456);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_int2(f1,f2,f3)</span><br><span class="line">VALUES(123456,123456,123456);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test_int2;</span><br><span class="line">+--------+--------+--------+</span><br><span class="line">| f1     | f2     | f3     |</span><br><span class="line">+--------+--------+--------+</span><br><span class="line">|      1 |    123 |  00123 |</span><br><span class="line">| 123456 | 123456 |   NULL |</span><br><span class="line">| 123456 | 123456 | 123456 |</span><br><span class="line">+--------+--------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-UNSIGNED"><a href="#2-2-2-UNSIGNED" class="headerlink" title="2.2.2 UNSIGNED"></a>2.2.2 UNSIGNED</h4><p><code>UNSIGNED</code>: 无符号类型（非负），所有的整数类型都有一个可选的属性UNSIGNED（无符号属性），无符号整数类型的最小取值为0。所以，如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设置为无符号类型。</p>
<p>int类型默认显示宽度为int(11)，无符号int类型默认显示宽度为int(10)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_int3(</span><br><span class="line">f1 INT UNSIGNED</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">mysql&gt; desc test_int3;</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type             | Null | Key | Default | Extra |</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">| f1    | int(10) unsigned | YES  |     | NULL    |       |</span><br><span class="line">+-------+------------------+------+-----+---------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-ZEROFILL"><a href="#2-2-3-ZEROFILL" class="headerlink" title="2.2.3 ZEROFILL"></a>2.2.3 ZEROFILL</h4><p><code>ZEROFILL</code>: 0填充,（如果某列是ZEROFILL，那么MySQL会自动为当前列添加UNSIGNED属性），如果指定了ZEROFILL只是表示不够M位时，用0在左边填充，如果超过M位，只要不超过数据存储范围即可。</p>
<p>原来，在 int(M) 中，M 的值跟 int(M) 所占多少存储空间并无任何关系。 int(3)、int(4)、int(8) 在磁盘上都是占用 4 bytes 的存储空间。也就是说，**int(M)，必须和UNSIGNED ZEROFILL一起使用才有意义。**如果整数值超过M位，就按照实际位数存储。只是无须再用字符 0 进行填充。</p>
<h3 id="2-3-适用场景"><a href="#2-3-适用场景" class="headerlink" title="2.3 适用场景"></a>2.3 适用场景</h3><p><code>TINYINT</code>：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。</p>
<p><code>SMALLINT</code>：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。</p>
<p><code>MEDIUMINT</code>：用于较大整数的计算，比如车站每日的客流量等。</p>
<p><code>INT、INTEGER</code>：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。</p>
<p><code>BIGINT</code>：只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓等。</p>
<h3 id="2-4-如何选择？"><a href="#2-4-如何选择？" class="headerlink" title="2.4 如何选择？"></a>2.4 如何选择？</h3><p>在评估用哪种整数类型的时候，你需要考虑<code>存储空间</code>和<code>可靠性</code>的平衡问题：一方 面，用占用字节数少的整数类型可以节省存储空间；另一方面，要是为了节省存储空间， 使用的整数类型取值范围太小，一旦遇到超出取值范围的情况，就可能引起<code>系统错误</code>，影响可靠性。</p>
<p>举个例子，商品编号采用的数据类型是 INT。原因就在于，客户门店中流通的商品种类较多，而且，每天都有旧商品下架，新商品上架，这样不断迭代，日积月累。</p>
<p>如果使用 SMALLINT 类型，虽然占用字节数比 INT 类型的整数少，但是却不能保证数据不会超出范围 65535。相反，使用 INT，就能确保有足够大的取值范围，不用担心数据超出范围影响可靠性的问题。</p>
<p>你要注意的是，在实际工作中，<strong>系统故障产生的成本远远超过增加几个字段存储空间所产生的成本</strong>。因此，我建议你首先确保数据不会超过取值范围，在这个前提之下，再去考虑如何节省存储空间。</p>
<h2 id="3-浮点类型"><a href="#3-浮点类型" class="headerlink" title="3. 浮点类型"></a>3. 浮点类型</h2><h3 id="3-1-类型介绍"><a href="#3-1-类型介绍" class="headerlink" title="3.1 类型介绍"></a>3.1 类型介绍</h3><p>浮点数和定点数类型的特点是可以<code>处理小数</code>，你可以把整数看成小数的一个特例。因此，浮点数和定点数的使用场景，比整数大多了。 MySQL支持的浮点数类型，分别是 FLOAT、DOUBLE、REAL。</p>
<ul>
<li>FLOAT 表示单精度浮点数；</li>
<li>DOUBLE 表示双精度浮点数；</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211007173312237.png"
                        alt="image-20211007173312237"
                 ></p>
<ul>
<li><p>REAL默认就是 DOUBLE。如果你把 SQL 模式设定为启用“<code>REAL_AS_FLOAT</code>”，那 么，MySQL 就认为 REAL 是 FLOAT。如果要启用“REAL_AS_FLOAT”，可以通过以下 SQL 语句实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET sql_mode = “REAL_AS_FLOAT”;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>**问题1：**FLOAT 和 DOUBLE 这两种数据类型的区别是啥呢？</p>
<p>FLOAT 占用字节数少，取值范围小；DOUBLE 占用字节数多，取值范围也大。</p>
<p>**问题2：**为什么浮点数类型的无符号数取值范围，只相当于有符号数取值范围的一半，也就是只相当于有符号数取值范围大于等于零的部分呢？</p>
<p>MySQL 存储浮点数的格式为：<code>符号(S)</code>、<code>尾数(M)</code>和 <code>阶码(E)</code>。因此，无论有没有符号，MySQL 的浮点数都会存储表示符号的部分。因此， 所谓的无符号数取值范围，其实就是有符号数取值范围大于等于零的部分。</p>
<h3 id="3-2-数据精度说明"><a href="#3-2-数据精度说明" class="headerlink" title="3.2 数据精度说明"></a>3.2 数据精度说明</h3><p>对于浮点类型，在MySQL中单精度值使用<code>4</code>个字节，双精度值使用<code>8</code>个字节。</p>
<ul>
<li><p>MySQL允许使用<code>非标准语法</code>（其他数据库未必支持，因此如果涉及到数据迁移，则最好不要这么用）：<code>FLOAT(M,D)</code>或<code>DOUBLE(M,D)</code>。这里，M称为<code>精度</code>，D称为<code>标度</code>。(M,D)中 M&#x3D;整数位+小数位，D&#x3D;小数位。 D&lt;&#x3D;M&lt;&#x3D;255，0&lt;&#x3D;D&lt;&#x3D;30。</p>
<p>例如，定义为FLOAT(5,2)的一个列可以显示为-999.99-999.99。如果超过这个范围会报错。</p>
</li>
<li><p>FLOAT和DOUBLE类型在不指定(M,D)时，默认会按照实际的精度（由实际的硬件和操作系统决定）来显示。</p>
</li>
<li><p>说明：浮点类型，也可以加<code>UNSIGNED</code>，但是不会改变数据范围，例如：FLOAT(3,2) UNSIGNED仍然只能表示0-9.99的范围。</p>
</li>
<li><p>不管是否显式设置了精度(M,D)，这里MySQL的处理方案如下：</p>
<ul>
<li><p>如果存储时，整数部分超出了范围，MySQL就会报错，不允许存这样的值</p>
</li>
<li><p>如果存储时，小数点部分若超出范围，就分以下情况：</p>
<ul>
<li>若四舍五入后，整数部分没有超出范围，则只警告，但能成功操作并四舍五入删除多余的小数位后保存。例如在FLOAT(5,2)列内插入999.009，近似结果是999.01。</li>
<li>若四舍五入后，整数部分超出范围，则MySQL报错，并拒绝处理。如FLOAT(5,2)列内插入999.995和-999.995都会报错。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>从MySQL 8.0.17开始，FLOAT(M,D) 和DOUBLE(M,D)用法在官方文档中已经明确不推荐使用</strong>，将来可能被移除。另外，关于浮点型FLOAT和DOUBLE的UNSIGNED也不推荐使用了，将来也可能被移除。</p>
</li>
<li><p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_double1(</span><br><span class="line">f1 FLOAT,</span><br><span class="line">f2 FLOAT(5,2),</span><br><span class="line">f3 DOUBLE,</span><br><span class="line">f4 DOUBLE(5,2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">DESC test_double1;</span><br><span class="line"></span><br><span class="line">INSERT INTO test_double1</span><br><span class="line">VALUES(123.456,123.456,123.4567,123.45);</span><br><span class="line"></span><br><span class="line">#Out of range value for column &#x27;f2&#x27; at row 1</span><br><span class="line">INSERT INTO test_double1</span><br><span class="line">VALUES(123.456,1234.456,123.4567,123.45); </span><br><span class="line"></span><br><span class="line">SELECT * FROM test_double1;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-3-精度误差说明"><a href="#3-3-精度误差说明" class="headerlink" title="3.3 精度误差说明"></a>3.3 精度误差说明</h3><p>浮点数类型有个缺陷，就是不精准。下面我来重点解释一下为什么 MySQL 的浮点数不够精准。比如，我们设计一个表，有f1这个字段，插入值分别为0.47,0.44,0.19，我们期待的运行结果是：0.47 + 0.44 + 0.19 &#x3D; 1.1。而使用sum之后查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_double2(</span><br><span class="line">f1 DOUBLE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_double2</span><br><span class="line">VALUES(0.47),(0.44),(0.19);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT SUM(f1)</span><br><span class="line">    -&gt; FROM test_double2;</span><br><span class="line">+--------------------+</span><br><span class="line">| SUM(f1)            |</span><br><span class="line">+--------------------+</span><br><span class="line">| 1.0999999999999999 |</span><br><span class="line">+--------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT SUM(f1) = 1.1,1.1 = 1.1</span><br><span class="line">    -&gt; FROM test_double2;</span><br><span class="line">+---------------+-----------+</span><br><span class="line">| SUM(f1) = 1.1 | 1.1 = 1.1 |</span><br><span class="line">+---------------+-----------+</span><br><span class="line">|             0 |         1 |</span><br><span class="line">+---------------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>查询结果是 1.0999999999999999。看到了吗？虽然误差很小，但确实有误差。 你也可以尝试把数据类型改成 FLOAT，然后运行求和查询，得到的是， 1.0999999940395355。显然，误差更大了。</p>
<p>那么，为什么会存在这样的误差呢？问题还是出在 MySQL 对浮点类型数据的存储方式上。</p>
<p>MySQL 用 4 个字节存储 FLOAT 类型数据，用 8 个字节来存储 DOUBLE 类型数据。无论哪个，都是采用二进制的方式来进行存储的。比如 9.625，用二进制来表达，就是 1001.101，或者表达成 1.001101×2^3。如果尾数不是 0 或 5（比如 9.624），你就无法用一个二进制数来精确表达。进而，就只好在取值允许的范围内进行四舍五入。</p>
<p>在编程中，如果用到浮点数，要特别注意误差问题，**因为浮点数是不准确的，所以我们要避免使用“&#x3D;”来判断两个数是否相等。**同时，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结果错误，甚至是造成不可挽回的损失。那么，MySQL 有没有精准的数据类型呢？当然有，这就是定点数类型：<code>DECIMAL</code>。</p>
<h2 id="4-定点数类型"><a href="#4-定点数类型" class="headerlink" title="4. 定点数类型"></a>4. 定点数类型</h2><h3 id="4-1-类型介绍"><a href="#4-1-类型介绍" class="headerlink" title="4.1 类型介绍"></a>4.1 类型介绍</h3><ul>
<li><p>MySQL中的定点数类型只有 DECIMAL 一种类型。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>字节数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>DECIMAL(M,D),DEC,NUMERIC</td>
<td>M+2字节</td>
<td>有效范围由M和D决定</td>
</tr>
</tbody></table>
<p>使用 DECIMAL(M,D) 的方式表示高精度小数。其中，M被称为精度，D被称为标度。0&lt;&#x3D;M&lt;&#x3D;65，0&lt;&#x3D;D&lt;&#x3D;30，D&lt;M。例如，定义DECIMAL（5,2）的类型，表示该列取值范围是-999.99~999.99。</p>
</li>
<li><p><strong>DECIMAL(M,D)的最大取值范围与DOUBLE类型一样</strong>，但是有效的数据范围是由M和D决定的。DECIMAL 的存储空间并不是固定的，由精度值M决定，总共占用的存储空间为M+2个字节。也就是说，在一些对精度要求不高的场景下，比起占用同样字节长度的定点数，浮点数表达的数值范围可以更大一些。</p>
</li>
<li><p>定点数在MySQL内部是以<code>字符串</code>的形式进行存储，这就决定了它一定是精准的。</p>
</li>
<li><p>当DECIMAL类型不指定精度和标度时，其默认为DECIMAL(10,0)。当数据的精度超出了定点数类型的精度范围时，则MySQL同样会进行四舍五入处理。</p>
</li>
<li><p><strong>浮点数 vs 定点数</strong></p>
<ul>
<li>浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动力学等）</li>
<li>定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景 （比如涉及金额计算的场景）</li>
</ul>
</li>
<li><p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_decimal1(</span><br><span class="line">f1 DECIMAL,</span><br><span class="line">f2 DECIMAL(5,2)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">DESC test_decimal1;</span><br><span class="line"></span><br><span class="line">INSERT INTO test_decimal1(f1,f2)</span><br><span class="line">VALUES(123.123,123.456);</span><br><span class="line"></span><br><span class="line">#Out of range value for column &#x27;f2&#x27; at row 1</span><br><span class="line">INSERT INTO test_decimal1(f2)</span><br><span class="line">VALUES(1234.34);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test_decimal1;</span><br><span class="line">+------+--------+</span><br><span class="line">| f1   | f2     |</span><br><span class="line">+------+--------+</span><br><span class="line">|  123 | 123.46 |</span><br><span class="line">+------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>举例</p>
<p>我们运行下面的语句，把test_double2表中字段“f1”的数据类型修改为 DECIMAL(5,2)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE test_double2</span><br><span class="line">MODIFY f1 DECIMAL(5,2);</span><br></pre></td></tr></table></figure>

<p>然后，我们再一次运行求和语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT SUM(f1)</span><br><span class="line">    -&gt; FROM test_double2;</span><br><span class="line">+---------+</span><br><span class="line">| SUM(f1) |</span><br><span class="line">+---------+</span><br><span class="line">|    1.10 |</span><br><span class="line">+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT SUM(f1) = 1.1</span><br><span class="line">    -&gt; FROM test_double2;</span><br><span class="line">+---------------+</span><br><span class="line">| SUM(f1) = 1.1 |</span><br><span class="line">+---------------+</span><br><span class="line">|             1 |</span><br><span class="line">+---------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-2-开发中经验"><a href="#4-2-开发中经验" class="headerlink" title="4.2 开发中经验"></a>4.2 开发中经验</h3><blockquote>
<p>“由于 DECIMAL 数据类型的精准性，在我们的项目中，除了极少数（比如商品编号）用到整数类型外，其他的数值都用的是 DECIMAL，原因就是这个项目所处的零售行业，要求精准，一分钱也不能差。 ” ——来自某项目经理</p>
</blockquote>
<h2 id="5-位类型：BIT"><a href="#5-位类型：BIT" class="headerlink" title="5. 位类型：BIT"></a>5. 位类型：BIT</h2><p>BIT类型中存储的是二进制值，类似010110。</p>
<table>
<thead>
<tr>
<th>二进制字符串类型</th>
<th>长度</th>
<th>长度范围</th>
<th>占用空间</th>
</tr>
</thead>
<tbody><tr>
<td>BIT(M)</td>
<td>M</td>
<td>1 &lt;&#x3D; M &lt;&#x3D; 64</td>
<td>约为(M + 7)&#x2F;8个字节</td>
</tr>
</tbody></table>
<p>BIT类型，如果没有指定(M)，默认是1位。这个1位，表示只能存1位的二进制值。这里(M)是表示二进制的位数，位数最小值为1，最大值为64。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_bit1(</span><br><span class="line">f1 BIT,</span><br><span class="line">f2 BIT(5),</span><br><span class="line">f3 BIT(64)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_bit1(f1)</span><br><span class="line">VALUES(1);</span><br><span class="line"></span><br><span class="line">#Data too long for column &#x27;f1&#x27; at row 1</span><br><span class="line">INSERT INTO test_bit1(f1)</span><br><span class="line">VALUES(2);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_bit1(f2)</span><br><span class="line">VALUES(23);</span><br></pre></td></tr></table></figure>

<p>注意：在向BIT类型的字段中插入数据时，一定要确保插入的数据在BIT类型支持的范围内。</p>
<p>使用SELECT命令查询位字段时，可以用<code>BIN()</code>或<code>HEX()</code>函数进行读取。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test_bit1;</span><br><span class="line">+------------+------------+------------+</span><br><span class="line">| f1         | f2         | f3         |</span><br><span class="line">+------------+------------+------------+</span><br><span class="line">| 0x01       | NULL       | NULL       |</span><br><span class="line">| NULL       | 0x17       | NULL       |</span><br><span class="line">+------------+------------+------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT BIN(f2),HEX(f2)</span><br><span class="line">    -&gt; FROM test_bit1;</span><br><span class="line">+---------+---------+</span><br><span class="line">| BIN(f2) | HEX(f2) |</span><br><span class="line">+---------+---------+</span><br><span class="line">| NULL    | NULL    |</span><br><span class="line">| 10111   | 17      |</span><br><span class="line">+---------+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT f2 + 0</span><br><span class="line">    -&gt; FROM test_bit1;</span><br><span class="line">+--------+</span><br><span class="line">| f2 + 0 |</span><br><span class="line">+--------+</span><br><span class="line">|   NULL |</span><br><span class="line">|     23 |</span><br><span class="line">+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>可以看到，使用b+0查询数据时，可以直接查询出存储的十进制数据的值。</p>
<h2 id="6-日期与时间类型"><a href="#6-日期与时间类型" class="headerlink" title="6. 日期与时间类型"></a>6. 日期与时间类型</h2><p>日期与时间是重要的信息，在我们的系统中，几乎所有的数据表都用得到。原因是客户需要知道数据的时间标签，从而进行数据查询、统计和处理。</p>
<p>MySQL有多种表示日期和时间的数据类型，不同的版本可能有所差异，MySQL8.0版本支持的日期和时间类型主要有：YEAR类型、TIME类型、DATE类型、DATETIME类型和TIMESTAMP类型。</p>
<ul>
<li><code>YEAR</code>类型通常用来表示年</li>
<li><code>DATE</code>类型通常用来表示年、月、日</li>
<li><code>TIME</code>类型通常用来表示时、分、秒</li>
<li><code>DATETIME</code>类型通常用来表示年、月、日、时、分、秒</li>
<li><code>TIMESTAMP</code>类型通常用来表示带时区的年、月、日、时、分、秒</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>字节</th>
<th>日期格式</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>年</td>
<td>1</td>
<td>YYYY或YY</td>
<td>1901</td>
<td>2155</td>
</tr>
<tr>
<td>TIME</td>
<td>时间</td>
<td>3</td>
<td>HH:MM:SS</td>
<td>-838:59:59</td>
<td>838:59:59</td>
</tr>
<tr>
<td>DATE</td>
<td>日期</td>
<td>3</td>
<td>YYYY-MM-DD</td>
<td>1000-01-01</td>
<td>9999-12-03</td>
</tr>
<tr>
<td>DATETIME</td>
<td>日期时间</td>
<td>8</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1000-01-01 00:00:00</td>
<td>9999-12-31 23:59:59</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>日期时间</td>
<td>4</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>1970-01-01 00:00:00 UTC</td>
<td>2038-01-19 03:14:07UTC</td>
</tr>
</tbody></table>
<p>可以看到，不同数据类型表示的时间内容不同、取值范围不同，而且占用的字节数也不一样，你要根据实际需要灵活选取。</p>
<p>为什么时间类型 TIME 的取值范围不是 -23:59:59～23:59:59 呢？原因是 MySQL 设计的 TIME 类型，不光表示一天之内的时间，而且可以用来表示一个时间间隔，这个时间间隔可以超过 24 小时。</p>
<h3 id="6-1-YEAR类型"><a href="#6-1-YEAR类型" class="headerlink" title="6.1 YEAR类型"></a>6.1 YEAR类型</h3><p>YEAR类型用来表示年份，在所有的日期时间类型中所占用的存储空间最小，只需要<code>1个字节</code>的存储空间。</p>
<p>在MySQL中，YEAR有以下几种存储格式：</p>
<ul>
<li>以4位字符串或数字格式表示YEAR类型，其格式为YYYY，最小值为1901，最大值为2155。</li>
<li>以2位字符串格式表示YEAR类型，最小值为00，最大值为99。<ul>
<li>当取值为01到69时，表示2001到2069；</li>
<li>当取值为70到99时，表示1970到1999；</li>
<li>当取值整数的0或00添加的话，那么是0000年；</li>
<li>当取值是日期&#x2F;字符串的’0’添加的话，是2000年。</li>
</ul>
</li>
</ul>
<p><strong>从MySQL5.5.27开始，2位格式的YEAR已经不推荐使用</strong>。YEAR默认格式就是“YYYY”，没必要写成YEAR(4)，从MySQL 8.0.19开始，不推荐使用指定显示宽度的YEAR(4)数据类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_year(</span><br><span class="line">f1 YEAR,</span><br><span class="line">f2 YEAR(4)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; DESC test_year;</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">| Field | Type    | Null | Key | Default | Extra |</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">| f1    | year(4) | YES  |     | NULL    |       |</span><br><span class="line">| f2    | year(4) | YES  |     | NULL    |       |</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_year</span><br><span class="line">VALUES(&#x27;2020&#x27;,&#x27;2021&#x27;);</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM test_year;</span><br><span class="line">+------+------+</span><br><span class="line">| f1   | f2   |</span><br><span class="line">+------+------+</span><br><span class="line">| 2020 | 2021 |</span><br><span class="line">+------+------+</span><br><span class="line">1 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_year</span><br><span class="line">VALUES(&#x27;45&#x27;,&#x27;71&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_year</span><br><span class="line">VALUES(0,&#x27;0&#x27;);</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM test_year;</span><br><span class="line">+------+------+</span><br><span class="line">| f1   | f2   |</span><br><span class="line">+------+------+</span><br><span class="line">| 2020 | 2021 |</span><br><span class="line">| 2045 | 1971 |</span><br><span class="line">| 0000 | 2000 |</span><br><span class="line">+------+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="6-2-DATE类型"><a href="#6-2-DATE类型" class="headerlink" title="6.2 DATE类型"></a>6.2 DATE类型</h3><p>DATE类型表示日期，没有时间部分，格式为<code>YYYY-MM-DD</code>，其中，YYYY表示年份，MM表示月份，DD表示日期。需要<code>3个字节</code>的存储空间。在向DATE类型的字段插入数据时，同样需要满足一定的格式条件。</p>
<ul>
<li>以<code>YYYY-MM-DD</code>格式或者<code>YYYYMMDD</code>格式表示的字符串日期，其最小取值为1000-01-01，最大取值为9999-12-03。YYYYMMDD格式会被转化为YYYY-MM-DD格式。</li>
<li>以<code>YY-MM-DD</code>格式或者<code>YYMMDD</code>格式表示的字符串日期，此格式中，年份为两位数值或字符串满足YEAR类型的格式条件为：当年份取值为00到69时，会被转化为2000到2069；当年份取值为70到99时，会被转化为1970到1999。</li>
<li>使用<code>CURRENT_DATE()</code>或者<code>NOW()</code>函数，会插入当前系统的日期。</li>
</ul>
<p><strong>举例：</strong></p>
<p>创建数据表，表中只包含一个DATE类型的字段f1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_date1(</span><br><span class="line">f1 DATE</span><br><span class="line">);</span><br><span class="line">Query OK, 0 rows affected (0.13 sec)</span><br></pre></td></tr></table></figure>

<p>插入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_date1</span><br><span class="line">VALUES (&#x27;2020-10-01&#x27;), (&#x27;20201001&#x27;),(20201001);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_date1</span><br><span class="line">VALUES (&#x27;00-01-01&#x27;), (&#x27;000101&#x27;), (&#x27;69-10-01&#x27;), (&#x27;691001&#x27;), (&#x27;70-01-01&#x27;), (&#x27;700101&#x27;), (&#x27;99-01-01&#x27;), (&#x27;990101&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_date1</span><br><span class="line">VALUES (000301), (690301), (700301), (990301); </span><br><span class="line"></span><br><span class="line">INSERT INTO test_date1</span><br><span class="line">VALUES (CURRENT_DATE()), (NOW());</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM test_date1;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-TIME类型"><a href="#6-3-TIME类型" class="headerlink" title="6.3 TIME类型"></a>6.3 TIME类型</h3><p>TIME类型用来表示时间，不包含日期部分。在MySQL中，需要<code>3个字节</code>的存储空间来存储TIME类型的数据，可以使用“HH:MM:SS”格式来表示TIME类型，其中，HH表示小时，MM表示分钟，SS表示秒。</p>
<p>在MySQL中，向TIME类型的字段插入数据时，也可以使用几种不同的格式。<br>（1）可以使用带有冒号的字符串，比如’<code>D HH:MM:SS&#39;</code>、’<code>HH:MM:SS</code>‘、’<code>HH:MM</code>‘、’<code>D HH:MM</code>‘、’<code>D HH</code>‘或’<code>SS</code>‘格式，都能被正确地插入TIME类型的字段中。其中D表示天，其最小值为0，最大值为34。如果使用带有D格式的字符串插入TIME类型的字段时，D会被转化为小时，计算格式为D*24+HH。当使用带有冒号并且不带D的字符串表示时间时，表示当天的时间，比如12:10表示12:10:00，而不是00:12:10。<br>（2）可以使用不带有冒号的字符串或者数字，格式为’<code>HHMMSS</code>‘或者<code>HHMMSS</code>。如果插入一个不合法的字符串或者数字，MySQL在存储数据时，会将其自动转化为00:00:00进行存储。比如1210，MySQL会将最右边的两位解析成秒，表示00:12:10，而不是12:10:00。<br>（3）使用<code>CURRENT_TIME()</code>或者<code>NOW()</code>，会插入当前系统的时间。</p>
<p><strong>举例：</strong></p>
<p>创建数据表，表中包含一个TIME类型的字段f1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_time1(</span><br><span class="line">f1 TIME</span><br><span class="line">);</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_time1</span><br><span class="line">VALUES(&#x27;2 12:30:29&#x27;), (&#x27;12:35:29&#x27;), (&#x27;12:40&#x27;), (&#x27;2 12:40&#x27;),(&#x27;1 05&#x27;), (&#x27;45&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_time1</span><br><span class="line">VALUES (&#x27;123520&#x27;), (124011),(1210);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_time1</span><br><span class="line">VALUES (NOW()), (CURRENT_TIME());</span><br><span class="line"></span><br><span class="line">SELECT * FROM test_time1;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-DATETIME类型"><a href="#6-4-DATETIME类型" class="headerlink" title="6.4 DATETIME类型"></a>6.4 DATETIME类型</h3><p>DATETIME类型在所有的日期时间类型中占用的存储空间最大，总共需要<code>8</code>个字节的存储空间。在格式上为DATE类型和TIME类型的组合，可以表示为<code>YYYY-MM-DD HH:MM:SS</code>，其中YYYY表示年份，MM表示月份，DD表示日期，HH表示小时，MM表示分钟，SS表示秒。</p>
<p>在向DATETIME类型的字段插入数据时，同样需要满足一定的格式条件。</p>
<ul>
<li>以<code>YYYY-MM-DD HH:MM:SS</code>格式或者<code>YYYYMMDDHHMMSS</code>格式的字符串插入DATETIME类型的字段时，最小值为1000-01-01 00:00:00，最大值为9999-12-03 23:59:59。<ul>
<li>以YYYYMMDDHHMMSS格式的数字插入DATETIME类型的字段时，会被转化为YYYY-MM-DD HH:MM:SS格式。</li>
</ul>
</li>
<li>以<code>YY-MM-DD HH:MM:SS</code>格式或者<code>YYMMDDHHMMSS</code>格式的字符串插入DATETIME类型的字段时，两位数的年份规则符合YEAR类型的规则，00到69表示2000到2069；70到99表示1970到1999。</li>
<li>使用函数<code>CURRENT_TIMESTAMP()</code>和<code>NOW()</code>，可以向DATETIME类型的字段插入系统的当前日期和时间。</li>
</ul>
<p><strong>举例：</strong></p>
<p>创建数据表，表中包含一个DATETIME类型的字段dt。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_datetime1(</span><br><span class="line">dt DATETIME</span><br><span class="line">);</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure>

<p>插入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_datetime1</span><br><span class="line">VALUES (&#x27;2021-01-01 06:50:30&#x27;), (&#x27;20210101065030&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_datetime1</span><br><span class="line">VALUES (&#x27;99-01-01 00:00:00&#x27;), (&#x27;990101000000&#x27;), (&#x27;20-01-01 00:00:00&#x27;), (&#x27;200101000000&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_datetime1</span><br><span class="line">VALUES (20200101000000), (200101000000), (19990101000000), (990101000000);</span><br><span class="line"> </span><br><span class="line">INSERT INTO test_datetime1</span><br><span class="line">VALUES (CURRENT_TIMESTAMP()), (NOW());</span><br></pre></td></tr></table></figure>

<h3 id="6-5-TIMESTAMP类型"><a href="#6-5-TIMESTAMP类型" class="headerlink" title="6.5 TIMESTAMP类型"></a>6.5 TIMESTAMP类型</h3><p>TIMESTAMP类型也可以表示日期时间，其显示格式与DATETIME类型相同，都是<code>YYYY-MM-DD HH:MM:SS</code>，需要4个字节的存储空间。但是TIMESTAMP存储的时间范围比DATETIME要小很多，只能存储“1970-01-01 00:00:01 UTC”到“2038-01-19 03:14:07 UTC”之间的时间。其中，UTC表示世界统一时间，也叫作世界标准时间。</p>
<ul>
<li><strong>存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间。</strong></li>
</ul>
<p>向TIMESTAMP类型的字段插入数据时，当插入的数据格式满足YY-MM-DD HH:MM:SS和YYMMDDHHMMSS时，两位数值的年份同样符合YEAR类型的规则条件，只不过表示的时间范围要小很多。</p>
<p>如果向TIMESTAMP类型的字段插入的时间超出了TIMESTAMP类型的范围，则MySQL会抛出错误信息。</p>
<p><strong>举例：</strong></p>
<p>创建数据表，表中包含一个TIMESTAMP类型的字段ts。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_timestamp1(</span><br><span class="line">ts TIMESTAMP</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>插入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_timestamp1</span><br><span class="line">VALUES (&#x27;1999-01-01 03:04:50&#x27;), (&#x27;19990101030405&#x27;), (&#x27;99-01-01 03:04:05&#x27;), (&#x27;990101030405&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_timestamp1</span><br><span class="line">VALUES (&#x27;2020@01@01@00@00@00&#x27;), (&#x27;20@01@01@00@00@00&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_timestamp1</span><br><span class="line">VALUES (CURRENT_TIMESTAMP()), (NOW());</span><br><span class="line"></span><br><span class="line">#Incorrect datetime value</span><br><span class="line">INSERT INTO test_timestamp1</span><br><span class="line">VALUES (&#x27;2038-01-20 03:14:07&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>TIMESTAMP和DATETIME的区别：</strong></p>
<ul>
<li><p>TIMESTAMP存储空间比较小，表示的日期时间范围也比较小</p>
</li>
<li><p>底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离1970-1-1 0:0:0 0毫秒的毫秒值。</p>
</li>
<li><p>两个日期比较大小或日期计算时，TIMESTAMP更方便、更快。</p>
</li>
<li><p>TIMESTAMP和时区有关。TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE temp_time(</span><br><span class="line">d1 DATETIME,</span><br><span class="line">d2 TIMESTAMP</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO temp_time VALUES(&#x27;2021-9-2 14:45:52&#x27;,&#x27;2021-9-2 14:45:52&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO temp_time VALUES(NOW(),NOW());</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM temp_time;</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">| d1                  | d2                  |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">| 2021-09-02 14:45:52 | 2021-09-02 14:45:52 |</span><br><span class="line">| 2021-11-03 17:38:17 | 2021-11-03 17:38:17 |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#修改当前的时区</span><br><span class="line">SET time_zone = &#x27;+9:00&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM temp_time;</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">| d1                  | d2                  |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">| 2021-09-02 14:45:52 | 2021-09-02 15:45:52 |</span><br><span class="line">| 2021-11-03 17:38:17 | 2021-11-03 18:38:17 |</span><br><span class="line">+---------------------+---------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-6-开发中经验"><a href="#6-6-开发中经验" class="headerlink" title="6.6 开发中经验"></a>6.6 开发中经验</h3><p>用得最多的日期时间类型，就是 <code>DATETIME</code>。虽然 MySQL 也支持 YEAR（年）、 TIME（时间）、DATE（日期），以及 TIMESTAMP 类型，但是在实际项目中，尽量用 DATETIME 类型。因为这个数据类型包括了完整的日期和时间信息，取值范围也最大，使用起来比较方便。毕竟，如果日期时间信息分散在好几个字段，很不容易记，而且查询的时候，SQL 语句也会更加复杂。</p>
<p>此外，一般存注册时间、商品发布时间等，不建议使用DATETIME存储，而是使用<code>时间戳</code>，因为DATETIME虽然直观，但不便于计算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT UNIX_TIMESTAMP();</span><br><span class="line">+------------------+</span><br><span class="line">| UNIX_TIMESTAMP() |</span><br><span class="line">+------------------+</span><br><span class="line">|       1635932762 |</span><br><span class="line">+------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="7-文本字符串类型"><a href="#7-文本字符串类型" class="headerlink" title="7. 文本字符串类型"></a>7. 文本字符串类型</h2><p>在实际的项目中，我们还经常遇到一种数据，就是字符串数据。</p>
<p>MySQL中，文本字符串总体上分为<code>CHAR</code>、<code>VARCHAR</code>、<code>TINYTEXT</code>、<code>TEXT</code>、<code>MEDIUMTEXT</code>、<code>LONGTEXT</code>、<code>ENUM</code>、<code>SET</code>等类型。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211012003508730.png"
                        alt="image-20211012003508730"
                 ></p>
<h3 id="7-1-CHAR与VARCHAR类型"><a href="#7-1-CHAR与VARCHAR类型" class="headerlink" title="7.1 CHAR与VARCHAR类型"></a>7.1 CHAR与VARCHAR类型</h3><p>CHAR和VARCHAR类型都可以存储比较短的字符串。</p>
<table>
<thead>
<tr>
<th>字符串(文本)类型</th>
<th>特点</th>
<th>长度</th>
<th>长度范围</th>
<th>占用的存储空间</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR(M)</td>
<td>固定长度</td>
<td>M</td>
<td>0 &lt;&#x3D; M &lt;&#x3D; 255</td>
<td>M个字节</td>
</tr>
<tr>
<td>VARCHAR(M)</td>
<td>可变长度</td>
<td>M</td>
<td>0 &lt;&#x3D; M &lt;&#x3D; 65535</td>
<td>(实际长度 + 1) 个字节</td>
</tr>
</tbody></table>
<p><strong>CHAR类型：</strong></p>
<ul>
<li>CHAR(M) 类型一般需要预先定义字符串长度。如果不指定(M)，则表示长度默认是1个字符。</li>
<li>如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在<code>右侧填充</code>空格以达到指定的长度。当MySQL检索CHAR类型的数据时，CHAR类型的字段会去除尾部的空格。</li>
<li>定义CHAR类型字段时，声明的字段长度即为CHAR类型字段所占的存储空间的字节数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_char1(</span><br><span class="line">c1 CHAR,</span><br><span class="line">c2 CHAR(5)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">DESC test_char1;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_char1</span><br><span class="line">VALUES(&#x27;a&#x27;,&#x27;Tom&#x27;);</span><br><span class="line"></span><br><span class="line">SELECT c1,CONCAT(c2,&#x27;***&#x27;) FROM test_char1;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_char1(c2)</span><br><span class="line">VALUES(&#x27;a  &#x27;);</span><br><span class="line"></span><br><span class="line">SELECT CHAR_LENGTH(c2)</span><br><span class="line">FROM test_char1;</span><br></pre></td></tr></table></figure>

<p><strong>VARCHAR类型：</strong></p>
<ul>
<li>VARCHAR(M) 定义时，<code>必须指定</code>长度M，否则报错。</li>
<li>MySQL4.0版本以下，varchar(20)：指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字节） ；MySQL5.0版本以上，varchar(20)：指的是20字符。</li>
<li>检索VARCHAR类型的字段数据时，会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间为字符串实际长度加1个字节。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_varchar1(</span><br><span class="line">NAME VARCHAR  #错误</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Column length too big for column &#x27;NAME&#x27; (max = 21845);</span><br><span class="line">CREATE TABLE test_varchar2(</span><br><span class="line">NAME VARCHAR(65535)  #错误</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_varchar3(</span><br><span class="line">NAME VARCHAR(5)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_varchar3</span><br><span class="line">VALUES(&#x27;尚硅谷&#x27;),(&#x27;尚硅谷教育&#x27;);</span><br><span class="line"></span><br><span class="line">#Data too long for column &#x27;NAME&#x27; at row 1</span><br><span class="line">INSERT INTO test_varchar3</span><br><span class="line">VALUES(&#x27;尚硅谷IT教育&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>哪些情况使用 CHAR 或 VARCHAR 更好</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>空间上</th>
<th>时间上</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR(M)</td>
<td>固定长度</td>
<td>浪费存储空间</td>
<td>效率高</td>
<td>存储不大，速度要求高</td>
</tr>
<tr>
<td>VARCHAR(M)</td>
<td>可变长度</td>
<td>节省存储空间</td>
<td>效率低</td>
<td>非CHAR的情况</td>
</tr>
</tbody></table>
<p>情况1：存储很短的信息。比如门牌号码101，201……这样很短的信息应该用char，因为varchar还要占个byte用于存储信息长度，本来打算节约存储的，结果得不偿失。</p>
<p>情况2：固定长度的。比如使用uuid作为主键，那用char应该更合适。因为他固定长度，varchar动态根据长度的特性就消失了，而且还要占个长度信息。</p>
<p>情况3：十分频繁改变的column。因为varchar每次存储都要有额外的计算，得到长度等工作，如果一个非常频繁改变的，那就要有很多的精力用于计算，而这些对于char来说是不需要的。</p>
<p>情况4：具体存储引擎中的情况：</p>
<ul>
<li><p><code>MyISAM</code> 数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。这样使得整个表静态化，从而使<code>数据检索更快</code>，用空间换时间。</p>
</li>
<li><p><code>MEMORY</code> 存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系，两者都是作为CHAR类型处理的。</p>
</li>
<li><p><code>InnoDB</code>存储引擎，建议使用VARCHAR类型。因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且<strong>主要影响性能的因素是数据行使用的存储总量</strong>，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的，其他考虑varchar。这样节省空间，对磁盘I&#x2F;O和数据存储总量比较好。</p>
</li>
</ul>
<h3 id="7-2-TEXT类型"><a href="#7-2-TEXT类型" class="headerlink" title="7.2 TEXT类型"></a>7.2 TEXT类型</h3><p>在MySQL中，TEXT用来保存文本类型的字符串，总共包含4种类型，分别为TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT 类型。</p>
<p>在向TEXT类型的字段保存和查询数据时，系统自动按照实际长度存储，不需要预先定义长度。这一点和 VARCHAR类型相同。</p>
<p>每种TEXT类型保存的数据长度和所占用的存储空间不同，如下：</p>
<table>
<thead>
<tr>
<th>文本字符串类型</th>
<th>特点</th>
<th>长度</th>
<th>长度范围</th>
<th>占用的存储空间</th>
</tr>
</thead>
<tbody><tr>
<td>TINYTEXT</td>
<td>小文本、可变长度</td>
<td>L</td>
<td>0 &lt;&#x3D; L &lt;&#x3D; 255</td>
<td>L + 2 个字节</td>
</tr>
<tr>
<td>TEXT</td>
<td>文本、可变长度</td>
<td>L</td>
<td>0 &lt;&#x3D; L &lt;&#x3D; 65535</td>
<td>L + 2 个字节</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>中等文本、可变长度</td>
<td>L</td>
<td>0 &lt;&#x3D; L &lt;&#x3D; 16777215</td>
<td>L + 3 个字节</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>大文本、可变长度</td>
<td>L</td>
<td>0 &lt;&#x3D; L&lt;&#x3D; 4294967295（相当于4GB）</td>
<td>L + 4 个字节</td>
</tr>
</tbody></table>
<p><strong>由于实际存储的长度不确定，MySQL 不允许 TEXT 类型的字段做主键</strong>。遇到这种情况，你只能采用 CHAR(M)，或者 VARCHAR(M)。</p>
<p><strong>举例：</strong></p>
<p>创建数据表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_text(</span><br><span class="line">tx TEXT</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_text</span><br><span class="line">VALUES(&#x27;atguigu   &#x27;);</span><br><span class="line"></span><br><span class="line">SELECT CHAR_LENGTH(tx)</span><br><span class="line">FROM test_text; #10</span><br></pre></td></tr></table></figure>

<p>说明在保存和查询数据时，并没有删除TEXT类型的数据尾部的空格。</p>
<p><strong>开发中经验：</strong></p>
<p>TEXT文本类型，可以存比较大的文本段，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR，VARCHAR来代替。还有TEXT类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致“空洞”，使得文件碎片比较多，所以频繁使用的表不建议包含TEXT类型字段，建议单独分出去，单独用一个表。</p>
<h2 id="8-ENUM类型"><a href="#8-ENUM类型" class="headerlink" title="8. ENUM类型"></a>8. ENUM类型</h2><p>ENUM类型也叫作枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM类型只允许从成员中选取单个值，不能一次选取多个值。</p>
<p>其所需要的存储空间由定义ENUM类型时指定的成员个数决定。</p>
<table>
<thead>
<tr>
<th>文本字符串类型</th>
<th>长度</th>
<th>长度范围</th>
<th>占用的存储空间</th>
</tr>
</thead>
<tbody><tr>
<td>ENUM</td>
<td>L</td>
<td>1 &lt;&#x3D; L &lt;&#x3D; 65535</td>
<td>1或2个字节</td>
</tr>
</tbody></table>
<ul>
<li><p>当ENUM类型包含1～255个成员时，需要1个字节的存储空间；</p>
</li>
<li><p>当ENUM类型包含256～65535个成员时，需要2个字节的存储空间。</p>
</li>
<li><p>ENUM类型的成员个数的上限为65535个。</p>
</li>
</ul>
<p>举例：</p>
<p>创建表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_enum(</span><br><span class="line">season ENUM(&#x27;春&#x27;,&#x27;夏&#x27;,&#x27;秋&#x27;,&#x27;冬&#x27;,&#x27;unknow&#x27;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>添加数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_enum</span><br><span class="line">VALUES(&#x27;春&#x27;),(&#x27;秋&#x27;);</span><br><span class="line"></span><br><span class="line"># 忽略大小写</span><br><span class="line">INSERT INTO test_enum</span><br><span class="line">VALUES(&#x27;UNKNOW&#x27;);</span><br><span class="line"></span><br><span class="line"># 允许按照角标的方式获取指定索引位置的枚举值</span><br><span class="line">INSERT INTO test_enum</span><br><span class="line">VALUES(&#x27;1&#x27;),(3);</span><br><span class="line"></span><br><span class="line"># Data truncated for column &#x27;season&#x27; at row 1</span><br><span class="line">INSERT INTO test_enum</span><br><span class="line">VALUES(&#x27;ab&#x27;);</span><br><span class="line"></span><br><span class="line"># 当ENUM类型的字段没有声明为NOT NULL时，插入NULL也是有效的</span><br><span class="line">INSERT INTO test_enum</span><br><span class="line">VALUES(NULL);</span><br></pre></td></tr></table></figure>

<h2 id="9-SET类型"><a href="#9-SET类型" class="headerlink" title="9. SET类型"></a>9. SET类型</h2><p>SET表示一个字符串对象，可以包含0个或多个成员，但成员个数的上限为<code>64</code>。设置字段值时，可以取取值范围内的 0 个或多个值。</p>
<p>当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下：</p>
<table>
<thead>
<tr>
<th>成员个数范围（L表示实际成员个数）</th>
<th>占用的存储空间</th>
</tr>
</thead>
<tbody><tr>
<td>1 &lt;&#x3D; L &lt;&#x3D; 8</td>
<td>1个字节</td>
</tr>
<tr>
<td>9 &lt;&#x3D; L &lt;&#x3D; 16</td>
<td>2个字节</td>
</tr>
<tr>
<td>17 &lt;&#x3D; L &lt;&#x3D; 24</td>
<td>3个字节</td>
</tr>
<tr>
<td>25 &lt;&#x3D; L &lt;&#x3D; 32</td>
<td>4个字节</td>
</tr>
<tr>
<td>33 &lt;&#x3D; L &lt;&#x3D; 64</td>
<td>8个字节</td>
</tr>
</tbody></table>
<p>SET类型在存储数据时成员个数越多，其占用的存储空间越大。注意：SET类型在选取成员时，可以一次选择多个成员，这一点与ENUM类型不同。</p>
<p>举例：</p>
<p>创建表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_set(</span><br><span class="line">s SET (&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>向表中插入数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_set (s) VALUES (&#x27;A&#x27;), (&#x27;A,B&#x27;);</span><br><span class="line"></span><br><span class="line">#插入重复的SET类型成员时，MySQL会自动删除重复的成员</span><br><span class="line">INSERT INTO test_set (s) VALUES (&#x27;A,B,C,A&#x27;);</span><br><span class="line"></span><br><span class="line">#向SET类型的字段插入SET成员中不存在的值时，MySQL会抛出错误。</span><br><span class="line">INSERT INTO test_set (s) VALUES (&#x27;A,B,C,D&#x27;);</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM test_set;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE temp_mul(</span><br><span class="line">gender ENUM(&#x27;男&#x27;,&#x27;女&#x27;),</span><br><span class="line">hobby SET(&#x27;吃饭&#x27;,&#x27;睡觉&#x27;,&#x27;打豆豆&#x27;,&#x27;写代码&#x27;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO temp_mul VALUES(&#x27;男&#x27;,&#x27;睡觉,打豆豆&#x27;); #成功</span><br><span class="line"></span><br><span class="line"># Data truncated for column &#x27;gender&#x27; at row 1</span><br><span class="line">INSERT INTO temp_mul VALUES(&#x27;男,女&#x27;,&#x27;睡觉,写代码&#x27;); #失败</span><br><span class="line"></span><br><span class="line"># Data truncated for column &#x27;gender&#x27; at row 1</span><br><span class="line">INSERT INTO temp_mul VALUES(&#x27;妖&#x27;,&#x27;睡觉,写代码&#x27;);#失败</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO temp_mul VALUES(&#x27;男&#x27;,&#x27;睡觉,写代码,吃饭&#x27;); #成功</span><br></pre></td></tr></table></figure>

<h2 id="10-二进制字符串类型"><a href="#10-二进制字符串类型" class="headerlink" title="10. 二进制字符串类型"></a>10. 二进制字符串类型</h2><p>MySQL中的二进制字符串类型主要存储一些二进制数据，比如可以存储图片、音频和视频等二进制数据。</p>
<p>MySQL中支持的二进制字符串类型主要包括BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB类型。</p>
<h4 id="BINARY与VARBINARY类型"><a href="#BINARY与VARBINARY类型" class="headerlink" title="BINARY与VARBINARY类型"></a>BINARY与VARBINARY类型</h4><p>BINARY和VARBINARY类似于CHAR和VARCHAR，只是它们存储的是二进制字符串。</p>
<p>BINARY (M)为固定长度的二进制字符串，M表示最多能存储的字节数，取值范围是0~255个字符。如果未指定(M)，表示只能存储<code>1个字节</code>。例如BINARY (8)，表示最多能存储8个字节，如果字段值不足(M)个字节，将在右边填充’\0’以补齐指定长度。</p>
<p>VARBINARY (M)为可变长度的二进制字符串，M表示最多能存储的字节数，总字节数不能超过行的字节长度限制65535，另外还要考虑额外字节开销，VARBINARY类型的数据除了存储数据本身外，还需要1或2个字节来存储数据的字节数。VARBINARY类型<code>必须指定(M)</code>，否则报错。</p>
<table>
<thead>
<tr>
<th>二进制字符串类型</th>
<th>特点</th>
<th>值的长度</th>
<th>占用空间</th>
</tr>
</thead>
<tbody><tr>
<td>BINARY(M)</td>
<td>固定长度</td>
<td>M （0 &lt;&#x3D; M &lt;&#x3D; 255）</td>
<td>M个字节</td>
</tr>
<tr>
<td>VARBINARY(M)</td>
<td>可变长度</td>
<td>M（0 &lt;&#x3D; M &lt;&#x3D; 65535）</td>
<td>M+1个字节</td>
</tr>
</tbody></table>
<p>举例：</p>
<p>创建表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_binary1(</span><br><span class="line">f1 BINARY,</span><br><span class="line">f2 BINARY(3),</span><br><span class="line"># f3 VARBINARY,</span><br><span class="line">f4 VARBINARY(10)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>添加数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_binary1(f1,f2)</span><br><span class="line">VALUES(&#x27;a&#x27;,&#x27;a&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO test_binary1(f1,f2)</span><br><span class="line">VALUES(&#x27;尚&#x27;,&#x27;尚&#x27;);#失败</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_binary1(f2,f4)</span><br><span class="line">VALUES(&#x27;ab&#x27;,&#x27;ab&#x27;);</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT LENGTH(f2),LENGTH(f4)</span><br><span class="line">    -&gt; FROM test_binary1;</span><br><span class="line">+------------+------------+</span><br><span class="line">| LENGTH(f2) | LENGTH(f4) |</span><br><span class="line">+------------+------------+</span><br><span class="line">|          3 |       NULL |</span><br><span class="line">|          3 |          2 |</span><br><span class="line">+------------+------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="BLOB类型"><a href="#BLOB类型" class="headerlink" title="BLOB类型"></a>BLOB类型</h4><p>BLOB是一个<code>二进制大对象</code>，可以容纳可变数量的数据。</p>
<p>MySQL中的BLOB类型包括TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB 4种类型，它们可容纳值的最大长度不同。可以存储一个二进制的大对象，比如<code>图片</code>、<code>音频</code>和<code>视频</code>等。</p>
<p>需要注意的是，在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图片、音频和视频文件存储到<code>服务器的磁盘上</code>，并将图片、音频和视频的访问路径存储到MySQL中。</p>
<table>
<thead>
<tr>
<th>二进制字符串类型</th>
<th>值的长度</th>
<th>长度范围</th>
<th>占用空间</th>
</tr>
</thead>
<tbody><tr>
<td>TINYBLOB</td>
<td>L</td>
<td>0 &lt;&#x3D; L &lt;&#x3D; 255</td>
<td>L + 1 个字节</td>
</tr>
<tr>
<td>BLOB</td>
<td>L</td>
<td>0 &lt;&#x3D; L &lt;&#x3D; 65535（相当于64KB）</td>
<td>L + 2 个字节</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>L</td>
<td>0 &lt;&#x3D; L &lt;&#x3D; 16777215 （相当于16MB）</td>
<td>L + 3 个字节</td>
</tr>
<tr>
<td>LONGBLOB</td>
<td>L</td>
<td>0 &lt;&#x3D; L &lt;&#x3D; 4294967295（相当于4GB）</td>
<td>L + 4 个字节</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_blob1(</span><br><span class="line">id INT,</span><br><span class="line">img MEDIUMBLOB</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>TEXT和BLOB的使用注意事项：</strong></p>
<p>在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。</p>
<p>① BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的”<code>空洞</code>“，以后填入这些”空洞”的记录可能长度不同。为了提高性能，建议定期使用 OPTIMIZE TABLE 功能对这类表进行<code>碎片整理</code>。</p>
<p>② 如果需要对大文本字段进行模糊查询，MySQL 提供了<code>前缀索引</code>。但是仍然要在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT * 查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。</p>
<p>③ 把BLOB或TEXT列<code>分离到单独的表</code>中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会<code>减少主表中的碎片</code>，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT * 查询的时候不会通过网络传输大量的BLOB或TEXT值。</p>
<h2 id="11-JSON-类型"><a href="#11-JSON-类型" class="headerlink" title="11. JSON 类型"></a>11. JSON 类型</h2><p>JSON（JavaScript Object Notation）是一种轻量级的<code>数据交换格式</code>。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。<strong>JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式。</strong></p>
<p>在MySQL 5.7中，就已经支持JSON数据类型。在MySQL 8.x版本中，JSON类型提供了可以进行自动验证的JSON文档和优化的存储结构，使得在MySQL中存储和读取JSON类型的数据更加方便和高效。<br>创建数据表，表中包含一个JSON类型的字段 js 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_json(</span><br><span class="line">js json</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>向表中插入JSON数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_json (js) </span><br><span class="line">VALUES (&#x27;&#123;&quot;name&quot;:&quot;songhk&quot;, &quot;age&quot;:18, &quot;address&quot;:&#123;&quot;province&quot;:&quot;beijing&quot;, &quot;city&quot;:&quot;beijing&quot;&#125;&#125;&#x27;);</span><br></pre></td></tr></table></figure>

<p>查询t19表中的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT *</span><br><span class="line">    -&gt; FROM test_json;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211104192516324.png"
                        alt="image-20211104192516324"
                 ></p>
<p>当需要检索JSON类型的字段中数据的某个具体值时，可以使用“-&gt;”和“-&gt;&gt;”符号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT js -&gt; &#x27;$.name&#x27; AS NAME,js -&gt; &#x27;$.age&#x27; AS age ,js -&gt; &#x27;$.address.province&#x27; AS province, js -&gt; &#x27;$.address.city&#x27; AS city</span><br><span class="line">    -&gt; FROM test_json;</span><br><span class="line">+----------+------+-----------+-----------+</span><br><span class="line">| NAME     | age  | province  | city      |</span><br><span class="line">+----------+------+-----------+-----------+</span><br><span class="line">| &quot;songhk&quot; | 18   | &quot;beijing&quot; | &quot;beijing&quot; |</span><br><span class="line">+----------+------+-----------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>通过“-&gt;”和“-&gt;&gt;”符号，从JSON字段中正确查询出了指定的JSON数据的值。</p>
<h2 id="12-空间类型"><a href="#12-空间类型" class="headerlink" title="12. 空间类型"></a>12. 空间类型</h2><p>MySQL 空间类型扩展支持地理特征的生成、存储和分析。这里的地理特征表示世界上具有位置的任何东西，可以是一个实体，例如一座山；可以是空间，例如一座办公楼；也可以是一个可定义的位置，例如一个十字路口等等。MySQL中使用<code>Geometry（几何）</code>来表示所有地理特征。Geometry指一个点或点的集合，代表世界上任何具有位置的事物。</p>
<p>MySQL的空间数据类型（Spatial Data Type）对应于OpenGIS类，包括单值类型：GEOMETRY、POINT、LINESTRING、POLYGON以及集合类型：MULTIPOINT、MULTILINESTRING、MULTIPOLYGON、GEOMETRYCOLLECTION 。</p>
<ul>
<li>Geometry是所有空间集合类型的基类，其他类型如POINT、LINESTRING、POLYGON都是Geometry的子类。<ul>
<li>Point，顾名思义就是点，有一个坐标值。例如POINT(121.213342 31.234532)，POINT(30 10)，坐标值支持DECIMAL类型，经度（longitude）在前，维度（latitude）在后，用空格分隔。</li>
<li>LineString，线，由一系列点连接而成。如果线从头至尾没有交叉，那就是简单的（simple）；如果起点和终点重叠，那就是封闭的（closed）。例如LINESTRING(30 10,10 30,40 40)，点与点之间用逗号分隔，一个点中的经纬度用空格分隔，与POINT格式一致。</li>
<li>Polygon，多边形。可以是一个实心平面形，即没有内部边界，也可以有空洞，类似纽扣。最简单的就是只有一个外边界的情况，例如POLYGON((0 0,10 0,10 10, 0 10))。</li>
</ul>
</li>
</ul>
<p>下面展示几种常见的几何图形元素：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211104192912988.png"
                        alt="image-20211104192912988"
                 ></p>
<ul>
<li>MultiPoint、MultiLineString、MultiPolygon、GeometryCollection 这4种类型都是集合类，是多个Point、LineString或Polygon组合而成。</li>
</ul>
<p>下面展示的是多个同类或异类几何图形元素的组合：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211104193330204.png"
                        alt="image-20211104193330204"
                 ></p>
<h2 id="13-小结及选择建议"><a href="#13-小结及选择建议" class="headerlink" title="13. 小结及选择建议"></a>13. 小结及选择建议</h2><p>在定义数据类型时，如果确定是<code>整数</code>，就用<code> INT</code>； 如果是<code>小数</code>，一定用定点数类型 <code>DECIMAL(M,D)</code>； 如果是日期与时间，就用 <code>DATETIME</code>。</p>
<p>这样做的好处是，首先确保你的系统不会因为数据类型定义出错。不过，凡事都是有两面的，可靠性好，并不意味着高效。比如，TEXT 虽然使用方便，但是效率不如 CHAR(M) 和 VARCHAR(M)。</p>
<p>关于字符串的选择，建议参考如下阿里巴巴的《Java开发手册》规范：</p>
<p><strong>阿里巴巴《Java开发手册》之MySQL数据库：</strong></p>
<ul>
<li>任何字段如果为非负数，必须是 UNSIGNED</li>
<li>【<code>强制</code>】小数类型为 DECIMAL，禁止使用 FLOAT 和 DOUBLE。<ul>
<li>说明：在存储的时候，FLOAT 和 DOUBLE 都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过 DECIMAL 的范围，建议将数据拆成整数和小数并分开存储。</li>
</ul>
</li>
<li>【<code>强制</code>】如果存储的字符串长度几乎相等，使用 CHAR 定长字符串类型。</li>
<li>【<code>强制</code>】VARCHAR 是可变长字符串，不预先分配存储空间，长度不要超过 5000。如果存储长度大于此值，定义字段类型为 TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</li>
</ul>
<hr>
<h1 id="第13章-约束"><a href="#第13章-约束" class="headerlink" title="第13章_约束"></a>第13章_约束</h1><hr>
<h2 id="1-约束-constraint-概述"><a href="#1-约束-constraint-概述" class="headerlink" title="1. 约束(constraint)概述"></a>1. 约束(constraint)概述</h2><h3 id="1-1-为什么需要约束"><a href="#1-1-为什么需要约束" class="headerlink" title="1.1 为什么需要约束"></a>1.1 为什么需要约束</h3><p>数据完整性（Data Integrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。</p>
<p>为了保证数据的完整性，SQL规范以约束的方式对<strong>表数据进行额外的条件限制</strong>。从以下四个方面考虑：</p>
<ul>
<li><code>实体完整性（Entity Integrity）</code>：例如，同一个表中，不能存在两条完全相同无法区分的记录</li>
<li><code>域完整性（Domain Integrity）</code>：例如：年龄范围0-120，性别范围“男&#x2F;女”</li>
<li><code>引用完整性（Referential Integrity）</code>：例如：员工所在部门，在部门表中要能找到这个部门</li>
<li><code>用户自定义完整性（User-defined Integrity）</code>：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍。</li>
</ul>
<h3 id="1-2-什么是约束"><a href="#1-2-什么是约束" class="headerlink" title="1.2 什么是约束"></a>1.2 什么是约束</h3><p>约束是表级的强制规定。</p>
<p>可以在<strong>创建表时规定约束（通过 CREATE TABLE 语句）</strong>，或者在<strong>表创建之后通过 ALTER TABLE 语句规定约束</strong>。</p>
<h3 id="1-3-约束的分类"><a href="#1-3-约束的分类" class="headerlink" title="1.3 约束的分类"></a>1.3 约束的分类</h3><ul>
<li>**根据约束数据列的限制，**约束可分为：<ul>
<li><strong>单列约束</strong>：每个约束只约束一列</li>
<li><strong>多列约束</strong>：每个约束可约束多列数据</li>
</ul>
</li>
<li><strong>根据约束的作用范围</strong>，约束可分为：<ul>
<li><strong>列级约束</strong>：只能作用在一个列上，跟在列的定义后面</li>
<li><strong>表级约束</strong>：可以作用在多个列上，不与列一起，而是单独定义</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">			位置			支持的约束类型					是否可以起约束名</span><br><span class="line">列级约束：	列的后面		语法都支持，但外键没有效果		不可以</span><br><span class="line">表级约束：	所有列的下面	   默认和非空不支持，其他支持	   可以（主键没有效果）</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>根据约束起的作用</strong>，约束可分为：<ul>
<li><strong>NOT NULL</strong> <strong>非空约束，规定某个字段不能为空</strong></li>
<li><strong>UNIQUE</strong>  <strong>唯一约束</strong>，<strong>规定某个字段在整个表中是唯一的</strong></li>
<li><strong>PRIMARY KEY  主键(非空且唯一)约束</strong></li>
<li><strong>FOREIGN KEY</strong>  <strong>外键约束</strong></li>
<li><strong>CHECK</strong>  <strong>检查约束</strong></li>
<li><strong>DEFAULT</strong>  <strong>默认值约束</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>注意： MySQL不支持check约束，但可以使用check约束，而没有任何效果</p>
</blockquote>
<ul>
<li>查看某个表已有的约束</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#information_schema数据库名（系统库）</span><br><span class="line">#table_constraints表名称（专门存储各个表的约束）</span><br><span class="line">SELECT * FROM information_schema.table_constraints </span><br><span class="line">WHERE table_name = &#x27;表名称&#x27;;</span><br></pre></td></tr></table></figure>



<h2 id="2-非空约束"><a href="#2-非空约束" class="headerlink" title="2. 非空约束"></a>2. 非空约束</h2><h3 id="2-1-作用"><a href="#2-1-作用" class="headerlink" title="2.1 作用"></a>2.1 作用</h3><p>限定某个字段&#x2F;某列的值不允许为空</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1555426972098.png"
                        alt="1555426972098"
                 ></p>
<h3 id="2-2-关键字"><a href="#2-2-关键字" class="headerlink" title="2.2 关键字"></a>2.2 关键字</h3><p>NOT NULL</p>
<h3 id="2-3-特点"><a href="#2-3-特点" class="headerlink" title="2.3 特点"></a>2.3 特点</h3><ul>
<li><p>默认，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型</p>
</li>
<li><p>非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空</p>
</li>
<li><p>一个表可以有很多列都分别限定了非空</p>
</li>
<li><p>空字符串’’不等于NULL，0也不等于NULL</p>
</li>
</ul>
<h3 id="2-4-添加非空约束"><a href="#2-4-添加非空约束" class="headerlink" title="2.4 添加非空约束"></a>2.4 添加非空约束</h3><p>（1）建表时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名称(</span><br><span class="line">	字段名  数据类型,</span><br><span class="line">    字段名  数据类型 NOT NULL,  </span><br><span class="line">    字段名  数据类型 NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE emp(</span><br><span class="line">id INT(10) NOT NULL,</span><br><span class="line">NAME VARCHAR(20) NOT NULL,</span><br><span class="line">sex CHAR NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE student(</span><br><span class="line">	sid int,</span><br><span class="line">    sname varchar(20) not null,</span><br><span class="line">    tel char(11) ,</span><br><span class="line">    cardid char(18) not null</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student values(1,&#x27;张三&#x27;,&#x27;13710011002&#x27;,&#x27;110222198912032545&#x27;); #成功</span><br><span class="line"></span><br><span class="line">insert into student values(2,&#x27;李四&#x27;,&#x27;13710011002&#x27;,null);#身份证号为空</span><br><span class="line">ERROR 1048 (23000): Column &#x27;cardid&#x27; cannot be null</span><br><span class="line"></span><br><span class="line">insert into student values(2,&#x27;李四&#x27;,null,&#x27;110222198912032546&#x27;);#成功，tel允许为空</span><br><span class="line"></span><br><span class="line">insert into student values(3,null,null,&#x27;110222198912032547&#x27;);#失败</span><br><span class="line">ERROR 1048 (23000): Column &#x27;sname&#x27; cannot be null</span><br></pre></td></tr></table></figure>

<p>（2）建表后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名称 modify 字段名 数据类型 not null;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE emp</span><br><span class="line">MODIFY sex VARCHAR(30) NOT NULL;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table student modify sname varchar(20) not null;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-删除非空约束"><a href="#2-5-删除非空约束" class="headerlink" title="2.5 删除非空约束"></a>2.5 删除非空约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名称 modify 字段名 数据类型 NULL;#去掉not null，相当于修改某个非注解字段，该字段允许为空</span><br><span class="line"></span><br><span class="line">或 </span><br><span class="line"></span><br><span class="line">alter table 表名称 modify 字段名 数据类型;#去掉not null，相当于修改某个非注解字段，该字段允许为空</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE emp</span><br><span class="line">MODIFY sex VARCHAR(30) NULL;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE emp</span><br><span class="line">MODIFY NAME VARCHAR(15) DEFAULT &#x27;abc&#x27; NULL;</span><br></pre></td></tr></table></figure>

<h2 id="3-唯一性约束"><a href="#3-唯一性约束" class="headerlink" title="3. 唯一性约束"></a>3. 唯一性约束</h2><h3 id="3-1-作用"><a href="#3-1-作用" class="headerlink" title="3.1 作用"></a>3.1 作用</h3><p>用来限制某个字段&#x2F;某列的值不能重复。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1555427198811.png"
                        alt="1555427198811"
                 ></p>
<h3 id="3-2-关键字"><a href="#3-2-关键字" class="headerlink" title="3.2 关键字"></a>3.2 关键字</h3><p>UNIQUE</p>
<h3 id="3-3-特点"><a href="#3-3-特点" class="headerlink" title="3.3 特点"></a>3.3 特点</h3><ul>
<li>同一个表可以有多个唯一约束。</li>
<li>唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。</li>
<li>唯一性约束允许列值为空。</li>
<li>在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同。</li>
<li><strong>MySQL会给唯一约束的列上默认创建一个唯一索引。</strong></li>
</ul>
<h3 id="3-4-添加唯一约束"><a href="#3-4-添加唯一约束" class="headerlink" title="3.4 添加唯一约束"></a>3.4 添加唯一约束</h3><p>（1）建表时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">	字段名  数据类型,</span><br><span class="line">    字段名  数据类型  unique,  </span><br><span class="line">    字段名  数据类型  unique key,</span><br><span class="line">    字段名  数据类型</span><br><span class="line">);</span><br><span class="line">create table 表名称(</span><br><span class="line">	字段名  数据类型,</span><br><span class="line">    字段名  数据类型,  </span><br><span class="line">    字段名  数据类型,</span><br><span class="line">    [constraint 约束名] unique key(字段名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table student(</span><br><span class="line">	sid int,</span><br><span class="line">    sname varchar(20),</span><br><span class="line">    tel char(11) unique,</span><br><span class="line">    cardid char(18) unique key</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t_course(</span><br><span class="line">	cid INT UNIQUE,</span><br><span class="line">	cname VARCHAR(100) UNIQUE,</span><br><span class="line">	description VARCHAR(200)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE USER(</span><br><span class="line"> id INT NOT NULL,</span><br><span class="line"> NAME VARCHAR(25),</span><br><span class="line"> PASSWORD VARCHAR(16),</span><br><span class="line"> -- 使用表级约束语法</span><br><span class="line"> CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>表示用户名和密码组合不能重复</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student values(1,&#x27;张三&#x27;,&#x27;13710011002&#x27;,&#x27;101223199012015623&#x27;);</span><br><span class="line">insert into student values(2,&#x27;李四&#x27;,&#x27;13710011003&#x27;,&#x27;101223199012015624&#x27;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+-----+-------+-------------+--------------------+</span><br><span class="line">| sid | sname | tel         | cardid             |</span><br><span class="line">+-----+-------+-------------+--------------------+</span><br><span class="line">|   1 | 张三  | 13710011002 | 101223199012015623 |</span><br><span class="line">|   2 | 李四  | 13710011003 | 101223199012015624 |</span><br><span class="line">+-----+-------+-------------+--------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student values(3,&#x27;王五&#x27;,&#x27;13710011004&#x27;,&#x27;101223199012015624&#x27;); #身份证号重复</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;101223199012015624&#x27; for key &#x27;cardid&#x27;</span><br><span class="line"></span><br><span class="line">insert into student values(3,&#x27;王五&#x27;,&#x27;13710011003&#x27;,&#x27;101223199012015625&#x27;); </span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;13710011003&#x27; for key &#x27;tel&#x27;</span><br></pre></td></tr></table></figure>

<p>（2）建表后指定唯一键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#字段列表中如果是一个字段，表示该列的值唯一。如果是两个或更多个字段，那么复合唯一，即多个字段的组合是唯一的</span><br><span class="line">#方式1：</span><br><span class="line">alter table 表名称 add unique key(字段列表); </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式2：</span><br><span class="line">alter table 表名称 modify 字段名 字段类型 unique;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE USER </span><br><span class="line">ADD UNIQUE(NAME,PASSWORD);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE USER </span><br><span class="line">ADD CONSTRAINT uk_name_pwd UNIQUE(NAME,PASSWORD);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE USER </span><br><span class="line">MODIFY NAME VARCHAR(20) UNIQUE;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table student(</span><br><span class="line">	sid int primary key,</span><br><span class="line">    sname varchar(20),</span><br><span class="line">    tel char(11) ,</span><br><span class="line">    cardid char(18) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table student add unique key(tel);</span><br><span class="line">alter table student add unique key(cardid);</span><br></pre></td></tr></table></figure>

<h3 id="3-5-关于复合唯一约束"><a href="#3-5-关于复合唯一约束" class="headerlink" title="3.5 关于复合唯一约束"></a>3.5 关于复合唯一约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">	字段名  数据类型,</span><br><span class="line">    字段名  数据类型,  </span><br><span class="line">    字段名  数据类型,</span><br><span class="line">    unique key(字段列表) #字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多个字段的组合是唯一的</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#学生表</span><br><span class="line">create table student(</span><br><span class="line">	sid int,	#学号</span><br><span class="line">    sname varchar(20),			#姓名</span><br><span class="line">    tel char(11) unique key,  #电话</span><br><span class="line">    cardid char(18) unique key #身份证号</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#课程表</span><br><span class="line">create table course(</span><br><span class="line">	cid int,  #课程编号</span><br><span class="line">    cname varchar(20)     #课程名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#选课表</span><br><span class="line">create table student_course(</span><br><span class="line">    id int,</span><br><span class="line">	sid int,</span><br><span class="line">    cid int,</span><br><span class="line">    score int,</span><br><span class="line">    unique key(sid,cid)  #复合唯一</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student values(1,&#x27;张三&#x27;,&#x27;13710011002&#x27;,&#x27;101223199012015623&#x27;);#成功</span><br><span class="line">insert into student values(2,&#x27;李四&#x27;,&#x27;13710011003&#x27;,&#x27;101223199012015624&#x27;);#成功</span><br><span class="line">insert into course values(1001,&#x27;Java&#x27;),(1002,&#x27;MySQL&#x27;);#成功</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+-----+-------+-------------+--------------------+</span><br><span class="line">| sid | sname | tel         | cardid             |</span><br><span class="line">+-----+-------+-------------+--------------------+</span><br><span class="line">|   1 | 张三  | 13710011002 | 101223199012015623 |</span><br><span class="line">|   2 | 李四  | 13710011003 | 101223199012015624 |</span><br><span class="line">+-----+-------+-------------+--------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from course;</span><br><span class="line">+------+-------+</span><br><span class="line">| cid  | cname |</span><br><span class="line">+------+-------+</span><br><span class="line">| 1001 | Java  |</span><br><span class="line">| 1002 | MySQL |</span><br><span class="line">+------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student_course values</span><br><span class="line">(1, 1, 1001, 89),</span><br><span class="line">(2, 1, 1002, 90),</span><br><span class="line">(3, 2, 1001, 88),</span><br><span class="line">(4, 2, 1002, 56);#成功</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student_course;</span><br><span class="line">+----+------+------+-------+</span><br><span class="line">| id | sid  | cid  | score |</span><br><span class="line">+----+------+------+-------+</span><br><span class="line">|  1 |    1 | 1001 |    89 |</span><br><span class="line">|  2 |    1 | 1002 |    90 |</span><br><span class="line">|  3 |    2 | 1001 |    88 |</span><br><span class="line">|  4 |    2 | 1002 |    56 |</span><br><span class="line">+----+------+------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student_course values (5, 1, 1001, 88);#失败</span><br><span class="line"></span><br><span class="line">#ERROR 1062 (23000): Duplicate entry &#x27;1-1001&#x27; for key &#x27;sid&#x27;   违反sid-cid的复合唯一</span><br></pre></td></tr></table></figure>

<h3 id="3-5-删除唯一约束"><a href="#3-5-删除唯一约束" class="headerlink" title="3.5 删除唯一约束"></a>3.5 删除唯一约束</h3><ul>
<li>添加唯一性约束的列上也会自动创建唯一索引。</li>
<li>删除唯一约束只能通过删除唯一索引的方式删除。</li>
<li>删除时需要指定唯一索引名，唯一索引名就和唯一约束名一样。</li>
<li>如果创建唯一约束时未指定名称，如果是单列，就默认和列名相同；如果是组合列，那么默认和()中排在第一个的列名相同。也可以自定义唯一性约束名。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;表名&#x27;; #查看都有哪些约束</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE USER </span><br><span class="line">DROP INDEX uk_name_pwd;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：可以通过 <code>show index from 表名称; </code>查看表的索引</p>
</blockquote>
<h2 id="4-PRIMARY-KEY-约束"><a href="#4-PRIMARY-KEY-约束" class="headerlink" title="4. PRIMARY KEY 约束"></a>4. PRIMARY KEY 约束</h2><h3 id="4-1-作用"><a href="#4-1-作用" class="headerlink" title="4.1 作用"></a>4.1 作用</h3><p>用来唯一标识表中的一行记录。</p>
<h3 id="4-2-关键字"><a href="#4-2-关键字" class="headerlink" title="4.2 关键字"></a>4.2 关键字</h3><p>primary key</p>
<h3 id="4-3-特点"><a href="#4-3-特点" class="headerlink" title="4.3 特点"></a>4.3 特点</h3><ul>
<li>主键约束相当于<strong>唯一约束+非空约束的组合</strong>，主键约束列不允许重复，也不允许出现空值。</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1555427492244.png"
                        alt="1555427492244"
                 ></p>
<ul>
<li><p>一个表最多只能有一个主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。</p>
</li>
<li><p>主键约束对应着表中的一列或者多列（复合主键）</p>
</li>
<li><p>如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。</p>
</li>
<li><p><strong>MySQL的主键名总是PRIMARY</strong>，就算自己命名了主键约束名也没用。</p>
</li>
<li><p>当创建主键约束时，系统默认会在所在的列或列组合上建立对应的<strong>主键索引</strong>（能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。</p>
</li>
<li><p>需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。</p>
</li>
</ul>
<h3 id="4-4-添加主键约束"><a href="#4-4-添加主键约束" class="headerlink" title="4.4 添加主键约束"></a>4.4 添加主键约束</h3><p>（1）建表时指定主键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">	字段名  数据类型  primary key, #列级模式</span><br><span class="line">    字段名  数据类型,  </span><br><span class="line">    字段名  数据类型  </span><br><span class="line">);</span><br><span class="line">create table 表名称(</span><br><span class="line">	字段名  数据类型,</span><br><span class="line">    字段名  数据类型,  </span><br><span class="line">    字段名  数据类型,</span><br><span class="line">    [constraint 约束名] primary key(字段名) #表级模式</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table temp(</span><br><span class="line">	id int primary key,</span><br><span class="line">    name varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc temp;</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| id    | int(11)     | NO   | PRI | NULL    |       |</span><br><span class="line">| name  | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into temp values(1,&#x27;张三&#x27;);#成功</span><br><span class="line">insert into temp values(2,&#x27;李四&#x27;);#成功</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from temp;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | 张三 |</span><br><span class="line">|  2 | 李四 |</span><br><span class="line">+----+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into temp values(1,&#x27;张三&#x27;);#失败</span><br><span class="line">ERROR 1062 (23000): Duplicate（重复） entry（键入，输入） &#x27;1&#x27; for key &#x27;PRIMARY&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into temp values(1,&#x27;王五&#x27;);#失败</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;1&#x27; for key &#x27;PRIMARY&#x27;</span><br><span class="line"></span><br><span class="line">insert into temp values(3,&#x27;张三&#x27;);#成功</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from temp;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | 张三 |</span><br><span class="line">|  2 | 李四 |</span><br><span class="line">|  3 | 张三 |</span><br><span class="line">+----+------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into temp values(4,null);#成功</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into temp values(null,&#x27;李琦&#x27;);#失败</span><br><span class="line">ERROR 1048 (23000): Column &#x27;id&#x27; cannot be null</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from temp;</span><br><span class="line">+----+------+</span><br><span class="line">| id | name |</span><br><span class="line">+----+------+</span><br><span class="line">|  1 | 张三 |</span><br><span class="line">|  2 | 李四 |</span><br><span class="line">|  3 | 张三 |</span><br><span class="line">|  4 | NULL |</span><br><span class="line">+----+------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#演示一个表建立两个主键约束</span><br><span class="line">create table temp(</span><br><span class="line">	id int primary key,</span><br><span class="line">    name varchar(20) primary key</span><br><span class="line">);</span><br><span class="line">ERROR 1068 (42000): Multiple（多重的） primary key defined（定义）</span><br></pre></td></tr></table></figure>

<p>再举例：</p>
<ul>
<li>列级约束</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE emp4(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT ,</span><br><span class="line">NAME VARCHAR(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>表级约束</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE emp5(</span><br><span class="line">id INT NOT NULL AUTO_INCREMENT,</span><br><span class="line">NAME VARCHAR(20),</span><br><span class="line">pwd VARCHAR(15),</span><br><span class="line">CONSTRAINT emp5_id_pk PRIMARY KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>（2）建表后增加主键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名称 ADD PRIMARY KEY(字段列表); #字段列表可以是一个字段，也可以是多个字段，如果是多个字段的话，是复合主键</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE student ADD PRIMARY KEY (sid);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE emp5 ADD PRIMARY KEY(NAME,pwd);</span><br></pre></td></tr></table></figure>

<h3 id="4-5-关于复合主键"><a href="#4-5-关于复合主键" class="headerlink" title="4.5 关于复合主键"></a>4.5 关于复合主键</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">	字段名  数据类型,</span><br><span class="line">    字段名  数据类型,  </span><br><span class="line">    字段名  数据类型,</span><br><span class="line">    primary key(字段名1,字段名2)  #表示字段1和字段2的组合是唯一的，也可以有更多个字段</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#学生表</span><br><span class="line">create table student(</span><br><span class="line">	sid int primary key,  #学号</span><br><span class="line">    sname varchar(20)     #学生姓名</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#课程表</span><br><span class="line">create table course(</span><br><span class="line">	cid int primary key,  #课程编号</span><br><span class="line">    cname varchar(20)     #课程名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#选课表</span><br><span class="line">create table student_course(</span><br><span class="line">	sid int,</span><br><span class="line">    cid int,</span><br><span class="line">    score int,</span><br><span class="line">    primary key(sid,cid)  #复合主键</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student values(1,&#x27;张三&#x27;),(2,&#x27;李四&#x27;);</span><br><span class="line">insert into course values(1001,&#x27;Java&#x27;),(1002,&#x27;MySQL&#x27;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student;</span><br><span class="line">+-----+-------+</span><br><span class="line">| sid | sname |</span><br><span class="line">+-----+-------+</span><br><span class="line">|   1 | 张三  |</span><br><span class="line">|   2 | 李四  |</span><br><span class="line">+-----+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from course;</span><br><span class="line">+------+-------+</span><br><span class="line">| cid  | cname |</span><br><span class="line">+------+-------+</span><br><span class="line">| 1001 | Java  |</span><br><span class="line">| 1002 | MySQL |</span><br><span class="line">+------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student_course values(1, 1001, 89),(1,1002,90),(2,1001,88),(2,1002,56);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from student_course;</span><br><span class="line">+-----+------+-------+</span><br><span class="line">| sid | cid  | score |</span><br><span class="line">+-----+------+-------+</span><br><span class="line">|   1 | 1001 |    89 |</span><br><span class="line">|   1 | 1002 |    90 |</span><br><span class="line">|   2 | 1001 |    88 |</span><br><span class="line">|   2 | 1002 |    56 |</span><br><span class="line">+-----+------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into student_course values(1, 1001, 100);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;1-1001&#x27; for key &#x27;PRIMARY&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc student_course;</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">| Field | Type    | Null | Key | Default | Extra |</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">| sid   | int(11) | NO   | PRI | NULL    |       |</span><br><span class="line">| cid   | int(11) | NO   | PRI | NULL    |       |</span><br><span class="line">| score | int(11) | YES  |     | NULL    |       |</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>再举例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE emp6(</span><br><span class="line">id INT NOT NULL,</span><br><span class="line">NAME VARCHAR(20),</span><br><span class="line">pwd VARCHAR(15),</span><br><span class="line">CONSTRAINT emp7_pk PRIMARY KEY(NAME,pwd)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="4-6-删除主键约束"><a href="#4-6-删除主键约束" class="headerlink" title="4.6 删除主键约束"></a>4.6 删除主键约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名称 drop primary key;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE student DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE emp5 DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存在。</p>
</blockquote>
<h2 id="5-自增列：AUTO-INCREMENT"><a href="#5-自增列：AUTO-INCREMENT" class="headerlink" title="5. 自增列：AUTO_INCREMENT"></a>5. 自增列：AUTO_INCREMENT</h2><h3 id="5-1-作用"><a href="#5-1-作用" class="headerlink" title="5.1 作用"></a>5.1 作用</h3><p>某个字段的值自增</p>
<h3 id="5-2-关键字"><a href="#5-2-关键字" class="headerlink" title="5.2 关键字"></a>5.2 关键字</h3><p>auto_increment</p>
<h3 id="5-3-特点和要求"><a href="#5-3-特点和要求" class="headerlink" title="5.3 特点和要求"></a>5.3 特点和要求</h3><p>（1）一个表最多只能有一个自增长列</p>
<p>（2）当需要产生唯一标识符或顺序值时，可设置自增长</p>
<p>（3）自增长列约束的列必须是键列（主键列，唯一键列）</p>
<p>（4）自增约束的列的数据类型必须是整数类型</p>
<p>（5）如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。</p>
<p>错误演示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table employee(</span><br><span class="line">	eid int auto_increment,</span><br><span class="line">    ename varchar(20)</span><br><span class="line">);</span><br><span class="line"># ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key   </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table employee(</span><br><span class="line">	eid int primary key,</span><br><span class="line">    ename varchar(20) unique key auto_increment</span><br><span class="line">);</span><br><span class="line"># ERROR 1063 (42000): Incorrect column specifier for column &#x27;ename&#x27;  因为ename不是整数类型</span><br></pre></td></tr></table></figure>

<h3 id="5-4-如何指定自增约束"><a href="#5-4-如何指定自增约束" class="headerlink" title="5.4 如何指定自增约束"></a>5.4 如何指定自增约束</h3><p><strong>（1）建表时</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">	字段名  数据类型  primary key auto_increment,</span><br><span class="line">    字段名  数据类型  unique key not null,  </span><br><span class="line">    字段名  数据类型  unique key,</span><br><span class="line">    字段名  数据类型  not null default 默认值, </span><br><span class="line">);</span><br><span class="line">create table 表名称(</span><br><span class="line">	字段名  数据类型 default 默认值 ,</span><br><span class="line">    字段名  数据类型 unique key auto_increment,  </span><br><span class="line">    字段名  数据类型 not null default 默认值,,</span><br><span class="line">    primary key(字段名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table employee(</span><br><span class="line">	eid int primary key auto_increment,</span><br><span class="line">    ename varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc employee;</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| eid   | int(11)     | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| ename | varchar(20) | YES  |     | NULL    |                |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>（2）建表后</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名称 modify 字段名 数据类型 auto_increment;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table employee(</span><br><span class="line">	eid int primary key ,</span><br><span class="line">    ename varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table employee modify eid int auto_increment;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc employee;</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">| eid   | int(11)     | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| ename | varchar(20) | YES  |     | NULL    |                |</span><br><span class="line">+-------+-------------+------+-----+---------+----------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="5-5-如何删除自增约束"><a href="#5-5-如何删除自增约束" class="headerlink" title="5.5 如何删除自增约束"></a>5.5 如何删除自增约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#alter table 表名称 modify 字段名 数据类型 auto_increment;#给这个字段增加自增约束</span><br><span class="line"></span><br><span class="line">alter table 表名称 modify 字段名 数据类型; #去掉auto_increment相当于删除</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table employee modify eid int;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc employee;</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| eid   | int(11)     | NO   | PRI | NULL    |       |</span><br><span class="line">| ename | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="5-6-MySQL-8-0新特性—自增变量的持久化"><a href="#5-6-MySQL-8-0新特性—自增变量的持久化" class="headerlink" title="5.6 MySQL 8.0新特性—自增变量的持久化"></a>5.6 MySQL 8.0新特性—自增变量的持久化</h3><p>在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENT&#x3D;max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。<br>下面通过案例来对比不同的版本中自增变量是否持久化。<br>在MySQL 5.7版本中，测试步骤如下：<br>创建的数据表中包含自增主键的id字段，语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test1(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>插入4个空值，执行如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test1</span><br><span class="line">VALUES(0),(0),(0),(0);</span><br></pre></td></tr></table></figure>

<p>查询数据表test1中的数据，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test1;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  1 |</span><br><span class="line">|  2 |</span><br><span class="line">|  3 |</span><br><span class="line">|  4 |</span><br><span class="line">+----+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>删除id为4的记录，语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM test1 WHERE id = 4;</span><br></pre></td></tr></table></figure>

<p>再次插入一个空值，语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test1 VALUES(0);</span><br></pre></td></tr></table></figure>

<p>查询此时数据表test1中的数据，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test1;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  1 |</span><br><span class="line">|  2 |</span><br><span class="line">|  3 |</span><br><span class="line">|  5 |</span><br><span class="line">+----+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>从结果可以看出，虽然删除了id为4的记录，但是再次插入空值时，并没有重用被删除的4，而是分配了5。<br>删除id为5的记录，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM test1 where id=5;</span><br></pre></td></tr></table></figure>

<p><strong>重启数据库</strong>，重新插入一个空值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test1 values(0);</span><br></pre></td></tr></table></figure>

<p>再次查询数据表test1中的数据，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test1;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  1 |</span><br><span class="line">|  2 |</span><br><span class="line">|  3 |</span><br><span class="line">|  4 |</span><br><span class="line">+----+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>从结果可以看出，新插入的0值分配的是4，按照重启前的操作逻辑，此处应该分配6。出现上述结果的主要原因是自增主键没有持久化。<br>在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个<code>计数器</code>来决定的，而该计数器只在<code>内存中维护</code>，并不会持久化到磁盘中。当数据库重启时，该计数器会被初始化。</p>
<p>在MySQL 8.0版本中，上述测试步骤最后一步的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test1;</span><br><span class="line">+----+</span><br><span class="line">| id |</span><br><span class="line">+----+</span><br><span class="line">|  1 |</span><br><span class="line">|  2 |</span><br><span class="line">|  3 |</span><br><span class="line">|  6 |</span><br><span class="line">+----+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>从结果可以看出，自增变量已经持久化了。</p>
<p>MySQL 8.0将自增主键的计数器持久化到<code>重做日志</code>中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值。</p>
<h2 id="6-FOREIGN-KEY-约束"><a href="#6-FOREIGN-KEY-约束" class="headerlink" title="6. FOREIGN KEY 约束"></a>6. FOREIGN KEY 约束</h2><h3 id="6-1-作用"><a href="#6-1-作用" class="headerlink" title="6.1 作用"></a>6.1 作用</h3><p>限定某个表的某个字段的引用完整性。</p>
<p>比如：员工表的员工所在部门的选择，必须在部门表能找到对应的部分。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1555428214706.png"
                        alt="1555428214706"
                 ></p>
<h3 id="6-2-关键字"><a href="#6-2-关键字" class="headerlink" title="6.2 关键字"></a>6.2 关键字</h3><p>FOREIGN KEY</p>
<h3 id="6-3-主表和从表-父表和子表"><a href="#6-3-主表和从表-父表和子表" class="headerlink" title="6.3 主表和从表&#x2F;父表和子表"></a>6.3 主表和从表&#x2F;父表和子表</h3><p>主表（父表）：被引用的表，被参考的表</p>
<p>从表（子表）：引用别人的表，参考别人的表</p>
<p>例如：员工表的员工所在部门这个字段的值要参考部门表：部门表是主表，员工表是从表。</p>
<p>例如：学生表、课程表、选课表：选课表的学生和课程要分别参考学生表和课程表，学生表和课程表是主表，选课表是从表。</p>
<h3 id="6-4-特点"><a href="#6-4-特点" class="headerlink" title="6.4 特点"></a>6.4 特点</h3><p>（1）从表的外键列，必须引用&#x2F;参考主表的主键或唯一约束的列</p>
<p>​          为什么？因为被依赖&#x2F;被参考的值必须是唯一的</p>
<p>（2）在创建外键约束时，如果不给外键约束命名，<strong>默认名不是列名，而是自动产生一个外键名</strong>（例如 student_ibfk_1;），也可以指定外键约束名。</p>
<p>（3）创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表</p>
<p>（4）删表时，先删从表（或先删除外键约束），再删除主表</p>
<p>（5）当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据</p>
<p>（6）在“从表”中指定外键约束，并且一个表可以建立多个外键约束</p>
<p>（7）从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can’t create table’database.tablename’(errno: 150)”。</p>
<p>​          例如：都是表示部门编号，都是int类型。</p>
<p>（8）<strong>当创建外键约束时，系统默认会在所在的列上建立对应的普通索引</strong>。但是索引名是外键的约束名。（根据外键查询效率很高）</p>
<p>（9）删除外键约束后，必须<code>手动</code>删除对应的索引</p>
<h3 id="6-5-添加外键约束"><a href="#6-5-添加外键约束" class="headerlink" title="6.5 添加外键约束"></a>6.5 添加外键约束</h3><p>（1）建表时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 主表名称(</span><br><span class="line">	字段1  数据类型  primary key,</span><br><span class="line">    字段2  数据类型</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table 从表名称(</span><br><span class="line">	字段1  数据类型  primary key,</span><br><span class="line">    字段2  数据类型,</span><br><span class="line">    [CONSTRAINT &lt;外键约束名称&gt;] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段)</span><br><span class="line">);</span><br><span class="line">#(从表的某个字段)的数据类型必须与主表名(被参考字段)的数据类型一致，逻辑意义也一样</span><br><span class="line">#(从表的某个字段)的字段名可以与主表名(被参考字段)的字段名一样，也可以不一样</span><br><span class="line"></span><br><span class="line">-- FOREIGN KEY: 在表级指定子表中的列</span><br><span class="line">-- REFERENCES: 标示在父表中的列</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table dept( #主表</span><br><span class="line">	did int primary key,		#部门编号</span><br><span class="line">    dname varchar(50)			#部门名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(#从表</span><br><span class="line">	eid int primary key,  #员工编号</span><br><span class="line">    ename varchar(5),     #员工姓名</span><br><span class="line">    deptid int,				#员工所在的部门</span><br><span class="line">    foreign key (deptid) references dept(did)   #在从表中指定外键约束</span><br><span class="line">    #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">（1）主表dept必须先创建成功，然后才能创建emp表，指定外键成功。</span><br><span class="line">（2）删除表时，先删除从表emp，再删除主表dept</span><br></pre></td></tr></table></figure>

<p>（2）建表后</p>
<p>一般情况下，表与表的关联都是提前设计好了的，因此，会在创建表的时候就把外键约束定义好。不过，如果需要修改表的设计（比如添加新的字段，增加新的关联关系），但没有预先定义外键约束，那么，就要用修改表的方式来补充定义。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 从表名 ADD [CONSTRAINT 约束名] FOREIGN KEY (从表的字段) REFERENCES 主表名(被引用字段) [on update xx][on delete xx];</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE emp1</span><br><span class="line">ADD [CONSTRAINT emp_dept_id_fk] FOREIGN KEY(dept_id) REFERENCES dept(dept_id);</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table dept(</span><br><span class="line">	did int primary key,		#部门编号</span><br><span class="line">    dname varchar(50)			#部门名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">	eid int primary key,  #员工编号</span><br><span class="line">    ename varchar(5),     #员工姓名</span><br><span class="line">    deptid int				#员工所在的部门</span><br><span class="line">);</span><br><span class="line">#这两个表创建时，没有指定外键的话，那么创建顺序是随意</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table emp add foreign key (deptid) references dept(did);</span><br></pre></td></tr></table></figure>

<h3 id="6-6-演示问题"><a href="#6-6-演示问题" class="headerlink" title="6.6 演示问题"></a>6.6 演示问题</h3><p>（1）失败：不是键列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table dept(</span><br><span class="line">	did int ,		#部门编号</span><br><span class="line">    dname varchar(50)			#部门名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">	eid int primary key,  #员工编号</span><br><span class="line">    ename varchar(5),     #员工姓名</span><br><span class="line">    deptid int,				#员工所在的部门</span><br><span class="line">    foreign key (deptid) references dept(did)</span><br><span class="line">);</span><br><span class="line">#ERROR 1215 (HY000): Cannot add foreign key constraint  原因是dept的did不是键列</span><br></pre></td></tr></table></figure>

<p>（2）失败：数据类型不一致</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table dept(</span><br><span class="line">	did int primary key,		#部门编号</span><br><span class="line">    dname varchar(50)			#部门名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">	eid int primary key,  #员工编号</span><br><span class="line">    ename varchar(5),     #员工姓名</span><br><span class="line">    deptid char,				#员工所在的部门</span><br><span class="line">    foreign key (deptid) references dept(did)</span><br><span class="line">);</span><br><span class="line">#ERROR 1215 (HY000): Cannot add foreign key constraint  原因是从表的deptid字段和主表的did字段的数据类型不一致，并且要它俩的逻辑意义一致</span><br></pre></td></tr></table></figure>

<p>（3）成功，两个表字段名一样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table dept(</span><br><span class="line">	did int primary key,		#部门编号</span><br><span class="line">    dname varchar(50)			#部门名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">	eid int primary key,  #员工编号</span><br><span class="line">    ename varchar(5),     #员工姓名</span><br><span class="line">    did int,				#员工所在的部门</span><br><span class="line">    foreign key (did) references dept(did)  </span><br><span class="line">    #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号</span><br><span class="line">    #是否重名没问题，因为两个did在不同的表中</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>（4）添加、删除、修改问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table dept(</span><br><span class="line">	did int primary key,		#部门编号</span><br><span class="line">    dname varchar(50)			#部门名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">	eid int primary key,  #员工编号</span><br><span class="line">    ename varchar(5),     #员工姓名</span><br><span class="line">    deptid int,				#员工所在的部门</span><br><span class="line">    foreign key (deptid) references dept(did)  </span><br><span class="line">    #emp表的deptid和和dept表的did的数据类型一致，意义都是表示部门的编号</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into dept values(1001,&#x27;教学部&#x27;);</span><br><span class="line">insert into dept values(1003, &#x27;财务部&#x27;);</span><br><span class="line"></span><br><span class="line">insert into emp values(1,&#x27;张三&#x27;,1001); #添加从表记录成功，在添加这条记录时，要求部门表有1001部门</span><br><span class="line"></span><br><span class="line">insert into emp values(2,&#x27;李四&#x27;,1005);#添加从表记录失败</span><br><span class="line">ERROR 1452 (23000): Cannot add（添加） or update（修改） a child row: a foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`)) 从表emp添加记录失败，因为主表dept没有1005部门</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from dept;</span><br><span class="line">+------+--------+</span><br><span class="line">| did  | dname  |</span><br><span class="line">+------+--------+</span><br><span class="line">| 1001 | 教学部  |</span><br><span class="line">| 1003 | 财务部  |</span><br><span class="line">+------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| eid | ename | deptid |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">|   1 | 张三   |   1001 |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update emp set deptid = 1002 where eid = 1;#修改从表失败 </span><br><span class="line">ERROR 1452 (23000): Cannot add（添加） or update（修改） a child row（子表的记录）: a foreign key constraint fails（外键约束失败） (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`))  #部门表did字段现在没有1002的值，所以员工表中不能修改员工所在部门deptid为1002</span><br><span class="line"></span><br><span class="line">update dept set did = 1002 where did = 1001;#修改主表失败</span><br><span class="line">ERROR 1451 (23000): Cannot delete（删除） or update（修改） a parent row（父表的记录）: a foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`)) #部门表did的1001字段已经被emp引用了，所以部门表的1001字段就不能修改了。</span><br><span class="line"></span><br><span class="line">update dept set did = 1002 where did = 1003;#修改主表成功  因为部门表的1003部门没有被emp表引用，所以可以修改</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from dept where did=1001; #删除主表失败</span><br><span class="line">ERROR 1451 (23000): Cannot delete（删除） or update（修改） a parent row（父表记录）: a foreign key constraint fails (`atguigudb`.`emp`, CONSTRAINT `emp_ibfk_1` FOREIGN KEY (`deptid`) REFERENCES `dept` (`did`))  #因为部门表did的1001字段已经被emp引用了，所以部门表的1001字段对应的记录就不能被删除</span><br></pre></td></tr></table></figure>

<p>总结：约束关系是针对双方的</p>
<ul>
<li><p>添加了外键约束后，主表的修改和删除数据受约束</p>
</li>
<li><p>添加了外键约束后，从表的添加和修改数据受约束</p>
</li>
<li><p>在从表上建立外键，要求主表必须存在</p>
</li>
<li><p>删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除</p>
</li>
</ul>
<h3 id="6-7-约束等级"><a href="#6-7-约束等级" class="headerlink" title="6.7 约束等级"></a>6.7 约束等级</h3><ul>
<li><p><code>Cascade方式</code>：在父表上update&#x2F;delete记录时，同步update&#x2F;delete掉子表的匹配记录</p>
</li>
<li><p><code>Set null方式</code>：在父表上update&#x2F;delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为not null</p>
</li>
<li><p><code>No action方式</code>：如果子表中有匹配的记录，则不允许对父表对应候选键进行update&#x2F;delete操作</p>
</li>
<li><p><code>Restrict方式</code>：同no action， 都是立即检查外键约束</p>
</li>
<li><p><code>Set default方式</code>（在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别</p>
</li>
</ul>
<p>如果没有指定等级，就相当于Restrict方式。</p>
<p>对于外键约束，最好是采用: <code>ON UPDATE CASCADE ON DELETE RESTRICT</code> 的方式。</p>
<p>（1）演示1：on update cascade on delete set null</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table dept(</span><br><span class="line">	did int primary key,		#部门编号</span><br><span class="line">    dname varchar(50)			#部门名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">	eid int primary key,  #员工编号</span><br><span class="line">    ename varchar(5),     #员工姓名</span><br><span class="line">    deptid int,				#员工所在的部门</span><br><span class="line">    foreign key (deptid) references dept(did)  on update cascade on delete set null</span><br><span class="line">    #把修改操作设置为级联修改等级，把删除操作设置为set null等级</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into dept values(1001,&#x27;教学部&#x27;);</span><br><span class="line">insert into dept values(1002, &#x27;财务部&#x27;);</span><br><span class="line">insert into dept values(1003, &#x27;咨询部&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">insert into emp values(1,&#x27;张三&#x27;,1001); #在添加这条记录时，要求部门表有1001部门</span><br><span class="line">insert into emp values(2,&#x27;李四&#x27;,1001);</span><br><span class="line">insert into emp values(3,&#x27;王五&#x27;,1002);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from dept;</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#修改主表成功，从表也跟着修改，修改了主表被引用的字段1002为1004，从表的引用字段就跟着修改为1004了</span><br><span class="line">mysql&gt; update dept set did = 1004 where did = 1002;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from dept;</span><br><span class="line">+------+--------+</span><br><span class="line">| did  | dname  |</span><br><span class="line">+------+--------+</span><br><span class="line">| 1001 | 教学部 |</span><br><span class="line">| 1003 | 咨询部 |</span><br><span class="line">| 1004 | 财务部 | #原来是1002，修改为1004</span><br><span class="line">+------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| eid | ename | deptid |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">|   1 | 张三  |   1001 |</span><br><span class="line">|   2 | 李四  |   1001 |</span><br><span class="line">|   3 | 王五  |   1004 | #原来是1002，跟着修改为1004</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#删除主表的记录成功，从表对应的字段的值被修改为null</span><br><span class="line">mysql&gt; delete from dept where did = 1001;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from dept;</span><br><span class="line">+------+--------+</span><br><span class="line">| did  | dname  | #记录1001部门被删除了</span><br><span class="line">+------+--------+</span><br><span class="line">| 1003 | 咨询部  |</span><br><span class="line">| 1004 | 财务部  |</span><br><span class="line">+------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| eid | ename | deptid |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">|   1 | 张三  |   NULL | #原来引用1001部门的员工，deptid字段变为null</span><br><span class="line">|   2 | 李四  |   NULL |</span><br><span class="line">|   3 | 王五  |   1004 |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>（2）演示2：on update set null on delete cascade</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table dept(</span><br><span class="line">	did int primary key,		#部门编号</span><br><span class="line">    dname varchar(50)			#部门名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">	eid int primary key,  #员工编号</span><br><span class="line">    ename varchar(5),     #员工姓名</span><br><span class="line">    deptid int,				#员工所在的部门</span><br><span class="line">    foreign key (deptid) references dept(did)  on update set null on delete cascade</span><br><span class="line">    #把修改操作设置为set null等级，把删除操作设置为级联删除等级</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into dept values(1001,&#x27;教学部&#x27;);</span><br><span class="line">insert into dept values(1002, &#x27;财务部&#x27;);</span><br><span class="line">insert into dept values(1003, &#x27;咨询部&#x27;);</span><br><span class="line"></span><br><span class="line">insert into emp values(1,&#x27;张三&#x27;,1001); #在添加这条记录时，要求部门表有1001部门</span><br><span class="line">insert into emp values(2,&#x27;李四&#x27;,1001);</span><br><span class="line">insert into emp values(3,&#x27;王五&#x27;,1002);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from dept;</span><br><span class="line">+------+--------+</span><br><span class="line">| did  | dname  |</span><br><span class="line">+------+--------+</span><br><span class="line">| 1001 | 教学部 |</span><br><span class="line">| 1002 | 财务部 |</span><br><span class="line">| 1003 | 咨询部 |</span><br><span class="line">+------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| eid | ename | deptid |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">|   1 | 张三  |   1001 |</span><br><span class="line">|   2 | 李四  |   1001 |</span><br><span class="line">|   3 | 王五  |   1002 |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#修改主表，从表对应的字段设置为null</span><br><span class="line">mysql&gt; update dept set did = 1004 where did = 1002;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from dept;</span><br><span class="line">+------+--------+</span><br><span class="line">| did  | dname  |</span><br><span class="line">+------+--------+</span><br><span class="line">| 1001 | 教学部 |</span><br><span class="line">| 1003 | 咨询部 |</span><br><span class="line">| 1004 | 财务部 | #原来did是1002</span><br><span class="line">+------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| eid | ename | deptid |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">|   1 | 张三  |   1001 |</span><br><span class="line">|   2 | 李四  |   1001 |</span><br><span class="line">|   3 | 王五  |   NULL | #原来deptid是1002，因为部门表1002被修改了，1002没有对应的了，就设置为null</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#删除主表的记录成功，主表的1001行被删除了，从表相应的记录也被删除了</span><br><span class="line">mysql&gt; delete from dept where did=1001;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from dept;</span><br><span class="line">+------+--------+</span><br><span class="line">| did  | dname  | #部门表中1001部门被删除</span><br><span class="line">+------+--------+</span><br><span class="line">| 1003 | 咨询部 |</span><br><span class="line">| 1004 | 财务部 |</span><br><span class="line">+------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| eid | ename | deptid |#原来1001部门的员工也被删除了</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">|   3 | 王五  |   NULL |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（3）演示：on update cascade on delete cascade</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table dept(</span><br><span class="line">	did int primary key,		#部门编号</span><br><span class="line">    dname varchar(50)			#部门名称</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table emp(</span><br><span class="line">	eid int primary key,  #员工编号</span><br><span class="line">    ename varchar(5),     #员工姓名</span><br><span class="line">    deptid int,				#员工所在的部门</span><br><span class="line">    foreign key (deptid) references dept(did)  on update cascade on delete cascade</span><br><span class="line">    #把修改操作设置为级联修改等级，把删除操作也设置为级联删除等级</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into dept values(1001,&#x27;教学部&#x27;);</span><br><span class="line">insert into dept values(1002, &#x27;财务部&#x27;);</span><br><span class="line">insert into dept values(1003, &#x27;咨询部&#x27;);</span><br><span class="line"></span><br><span class="line">insert into emp values(1,&#x27;张三&#x27;,1001); #在添加这条记录时，要求部门表有1001部门</span><br><span class="line">insert into emp values(2,&#x27;李四&#x27;,1001);</span><br><span class="line">insert into emp values(3,&#x27;王五&#x27;,1002);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from dept;</span><br><span class="line">+------+--------+</span><br><span class="line">| did  | dname  |</span><br><span class="line">+------+--------+</span><br><span class="line">| 1001 | 教学部 |</span><br><span class="line">| 1002 | 财务部 |</span><br><span class="line">| 1003 | 咨询部 |</span><br><span class="line">+------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| eid | ename | deptid |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">|   1 | 张三  |   1001 |</span><br><span class="line">|   2 | 李四  |   1001 |</span><br><span class="line">|   3 | 王五  |   1002 |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#修改主表，从表对应的字段自动修改</span><br><span class="line">mysql&gt; update dept set did = 1004 where did = 1002;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from dept;</span><br><span class="line">+------+--------+</span><br><span class="line">| did  | dname  |</span><br><span class="line">+------+--------+</span><br><span class="line">| 1001 | 教学部 |</span><br><span class="line">| 1003 | 咨询部 |</span><br><span class="line">| 1004 | 财务部 | #部门1002修改为1004</span><br><span class="line">+------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| eid | ename | deptid |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">|   1 | 张三  |   1001 |</span><br><span class="line">|   2 | 李四  |   1001 |</span><br><span class="line">|   3 | 王五  |   1004 | #级联修改</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#删除主表的记录成功，主表的1001行被删除了，从表相应的记录也被删除了</span><br><span class="line">mysql&gt; delete from dept where did=1001;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from dept;</span><br><span class="line">+------+--------+</span><br><span class="line">| did  | dname  | #1001部门被删除了</span><br><span class="line">+------+--------+</span><br><span class="line">| 1003 | 咨询部 |</span><br><span class="line">| 1004 | 财务部 | </span><br><span class="line">+------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from emp;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| eid | ename | deptid |  #1001部门的员工也被删除了</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">|   3 | 王五  |   1004 |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>



<h3 id="6-8-删除外键约束"><a href="#6-8-删除外键约束" class="headerlink" title="6.8 删除外键约束"></a>6.8 删除外键约束</h3><p>流程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)第一步先查看约束名和删除外键约束</span><br><span class="line">SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;表名称&#x27;;#查看某个表的约束名</span><br><span class="line"></span><br><span class="line">ALTER TABLE 从表名 DROP FOREIGN KEY 外键约束名;</span><br><span class="line"></span><br><span class="line">（2）第二步查看索引名和删除索引。（注意，只能手动删除）</span><br><span class="line">SHOW INDEX FROM 表名称; #查看某个表的索引名</span><br><span class="line"></span><br><span class="line">ALTER TABLE 从表名 DROP INDEX 索引名;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM information_schema.table_constraints WHERE table_name = &#x27;emp&#x27;;</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table emp drop foreign key emp_ibfk_1;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show index from emp;</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table emp drop index deptid;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt;  show index from emp;</span><br></pre></td></tr></table></figure>

<h3 id="6-9-开发场景"><a href="#6-9-开发场景" class="headerlink" title="6.9 开发场景"></a>6.9 开发场景</h3><p><strong>问题1：如果两个表之间有关系（一对一、一对多），比如：员工表和部门表（一对多），它们之间是否一定要建外键约束？</strong></p>
<p>答：不是的</p>
<p><strong>问题2：建和不建外键约束有什么区别？</strong></p>
<p>答：建外键约束，你的操作（创建表、删除表、添加、修改、删除）会受到限制，从语法层面受到限制。例如：在员工表中不可能添加一个员工信息，它的部门的值在部门表中找不到。</p>
<p>不建外键约束，你的操作（创建表、删除表、添加、修改、删除）不受限制，要保证数据的<code>引用完整性</code>，只能依<code>靠程序员的自觉</code>，或者是<code>在Java程序中进行限定</code>。例如：在员工表中，可以添加一个员工的信息，它的部门指定为一个完全不存在的部门。</p>
<p><strong>问题3：那么建和不建外键约束和查询有没有关系？</strong></p>
<p>答：没有</p>
<blockquote>
<p>在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适合。比如大型网站的中央数据库，可能会<code>因为外键约束的系统开销而变得非常慢</code>。所以， MySQL 允许你不使用系统自带的外键约束，在<code>应用层面</code>完成检查数据一致性的逻辑。也就是说，即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。</p>
</blockquote>
<h3 id="6-10-阿里开发规范"><a href="#6-10-阿里开发规范" class="headerlink" title="6.10 阿里开发规范"></a>6.10 阿里开发规范</h3><p>【<code>强制</code>】不得使用外键与级联，一切外键概念必须在应用层解决。</p>
<p>说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于<code>单机低并发</code>，不适合<code>分布式</code>、<code>高并发集群</code>；级联更新是强阻塞，存在数据库<code>更新风暴</code>的风险；外键影响数据库的<code>插入速度</code>。</p>
<h2 id="7-CHECK-约束"><a href="#7-CHECK-约束" class="headerlink" title="7. CHECK 约束"></a>7. CHECK 约束</h2><h3 id="7-1-作用"><a href="#7-1-作用" class="headerlink" title="7.1 作用"></a>7.1 作用</h3><p>检查某个字段的值是否符号xx要求，一般指的是值的范围</p>
<h3 id="2、关键字"><a href="#2、关键字" class="headerlink" title="2、关键字"></a>2、关键字</h3><p>CHECK</p>
<h3 id="3、说明：MySQL-5-7-不支持"><a href="#3、说明：MySQL-5-7-不支持" class="headerlink" title="3、说明：MySQL 5.7 不支持"></a>3、说明：MySQL 5.7 不支持</h3><p>MySQL5.7 可以使用check约束，但check约束对数据验证没有任何作用。添加数据时，没有任何错误或警告</p>
<p>但是<strong>MySQL 8.0中可以使用check约束了</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table employee(</span><br><span class="line">	eid int primary key,</span><br><span class="line">    ename varchar(5),</span><br><span class="line">    gender char check (&#x27;男&#x27; or &#x27;女&#x27;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into employee values(1,&#x27;张三&#x27;,&#x27;妖&#x27;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from employee;</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">| eid | ename | gender |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">|   1 | 张三   | 妖     |</span><br><span class="line">+-----+-------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>再举例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE temp(</span><br><span class="line">id INT AUTO_INCREMENT,</span><br><span class="line">NAME VARCHAR(20),</span><br><span class="line">age INT CHECK(age &gt; 20),</span><br><span class="line">PRIMARY KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>再举例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">age tinyint check(age &gt;20) 或 sex char(2) check(sex in(‘男’,’女’))</span><br></pre></td></tr></table></figure>

<ul>
<li>再举例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHECK(height&gt;=0 AND height&lt;3)</span><br></pre></td></tr></table></figure>

<h2 id="8-DEFAULT约束"><a href="#8-DEFAULT约束" class="headerlink" title="8. DEFAULT约束"></a>8. DEFAULT约束</h2><h3 id="8-1-作用"><a href="#8-1-作用" class="headerlink" title="8.1 作用"></a>8.1 作用</h3><p>给某个字段&#x2F;某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。</p>
<h3 id="8-2-关键字"><a href="#8-2-关键字" class="headerlink" title="8.2 关键字"></a>8.2 关键字</h3><p>DEFAULT</p>
<h3 id="8-3-如何给字段加默认值"><a href="#8-3-如何给字段加默认值" class="headerlink" title="8.3 如何给字段加默认值"></a>8.3 如何给字段加默认值</h3><p>（1）建表时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名称(</span><br><span class="line">	字段名  数据类型  primary key,</span><br><span class="line">    字段名  数据类型  unique key not null,  </span><br><span class="line">    字段名  数据类型  unique key,</span><br><span class="line">    字段名  数据类型  not null default 默认值, </span><br><span class="line">);</span><br><span class="line">create table 表名称(</span><br><span class="line">	字段名  数据类型 default 默认值 ,</span><br><span class="line">    字段名  数据类型 not null default 默认值,  </span><br><span class="line">    字段名  数据类型 not null default 默认值,</span><br><span class="line">    primary key(字段名),</span><br><span class="line">    unique key(字段名)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">说明：默认值约束一般不在唯一键和主键列上加</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table employee(</span><br><span class="line">	eid int primary key,</span><br><span class="line">    ename varchar(20) not null,</span><br><span class="line">    gender char default &#x27;男&#x27;,</span><br><span class="line">    tel char(11) not null default &#x27;&#x27; #默认是空字符串</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc employee;</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| eid    | int(11)     | NO   | PRI | NULL    |       |</span><br><span class="line">| ename  | varchar(20) | NO   |     | NULL    |       |</span><br><span class="line">| gender | char(1)     | YES  |     | 男      |       |</span><br><span class="line">| tel    | char(11)    | NO   |     |         |       |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into employee values(1,&#x27;汪飞&#x27;,&#x27;男&#x27;,&#x27;13700102535&#x27;); #成功</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from employee;</span><br><span class="line">+-----+-------+--------+-------------+</span><br><span class="line">| eid | ename | gender | tel         |</span><br><span class="line">+-----+-------+--------+-------------+</span><br><span class="line">|   1 | 汪飞  | 男     | 13700102535 |</span><br><span class="line">+-----+-------+--------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into employee(eid,ename) values(2,&#x27;天琪&#x27;); #成功</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from employee;</span><br><span class="line">+-----+-------+--------+-------------+</span><br><span class="line">| eid | ename | gender | tel         |</span><br><span class="line">+-----+-------+--------+-------------+</span><br><span class="line">|   1 | 汪飞  | 男     | 13700102535 |</span><br><span class="line">|   2 | 天琪  | 男     |             |</span><br><span class="line">+-----+-------+--------+-------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into employee(eid,ename) values(3,&#x27;二虎&#x27;);</span><br><span class="line">#ERROR 1062 (23000): Duplicate entry &#x27;&#x27; for key &#x27;tel&#x27;  </span><br><span class="line">#如果tel有唯一性约束的话会报错，如果tel没有唯一性约束，可以添加成功</span><br></pre></td></tr></table></figure>

<p>再举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE myemp(</span><br><span class="line">id INT AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">NAME VARCHAR(15),</span><br><span class="line">salary DOUBLE(10,2) DEFAULT 2000</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>（2）建表后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名称 modify 字段名 数据类型 default 默认值;</span><br><span class="line"></span><br><span class="line">#如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被删除了</span><br><span class="line">#同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默认值约束，否则就删除了</span><br><span class="line">alter table 表名称 modify 字段名 数据类型 default 默认值 not null;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table employee(</span><br><span class="line">	eid int primary key,</span><br><span class="line">    ename varchar(20),</span><br><span class="line">    gender char,</span><br><span class="line">    tel char(11) not null</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc employee;</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| eid    | int(11)     | NO   | PRI | NULL    |       |</span><br><span class="line">| ename  | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| gender | char(1)     | YES  |     | NULL    |       |</span><br><span class="line">| tel    | char(11)    | NO   |     | NULL    |       |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table employee modify gender char default &#x27;男&#x27;;  #给gender字段增加默认值约束</span><br><span class="line">alter table employee modify tel char(11) default &#x27;&#x27;; #给tel字段增加默认值约束</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc employee;</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| eid    | int(11)     | NO   | PRI | NULL    |       |</span><br><span class="line">| ename  | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| gender | char(1)     | YES  |     | 男      |       |</span><br><span class="line">| tel    | char(11)    | YES  |     |         |       |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table employee modify tel char(11) default &#x27;&#x27;  not null;#给tel字段增加默认值约束，并保留非空约束</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc employee;</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| eid    | int(11)     | NO   | PRI | NULL    |       |</span><br><span class="line">| ename  | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| gender | char(1)     | YES  |     | 男      |       |</span><br><span class="line">| tel    | char(11)    | NO   |     |         |       |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="8-4-如何删除默认值约束"><a href="#8-4-如何删除默认值约束" class="headerlink" title="8.4 如何删除默认值约束"></a>8.4 如何删除默认值约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束</span><br><span class="line"></span><br><span class="line">alter table 表名称 modify 字段名 数据类型  not null; #删除默认值约束，保留非空约束</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table employee modify gender char; #删除gender字段默认值约束，如果有非空约束，也一并删除</span><br><span class="line">alter table employee modify tel char(11)  not null;#删除tel字段默认值约束，保留非空约束</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc employee;</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| eid    | int(11)     | NO   | PRI | NULL    |       |</span><br><span class="line">| ename  | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| gender | char(1)     | YES  |     | NULL    |       |</span><br><span class="line">| tel    | char(11)    | NO   |     | NULL    |       |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="9-面试"><a href="#9-面试" class="headerlink" title="9. 面试"></a>9. 面试</h2><p><strong>面试1、为什么建表时，加 not null default ‘’ 或 default 0</strong></p>
<p>答：不想让表中出现null值。</p>
<p><strong>面试2、为什么不想要 null 的值</strong></p>
<p>答:（1）不好比较。null是一种特殊值，比较时只能用专门的is null 和 is not null来比较。碰到运算符，通常返回null。</p>
<p>​     （2）效率不高。影响提高索引效果。因此，我们往往在建表时 not null default ‘’ 或 default 0</p>
<p><strong>面试3、带AUTO_INCREMENT约束的字段值是从1开始的吗？</strong><br>在MySQL中，默认AUTO_INCREMENT的初始值是1，每新增一条记录，字段值自动加1。设置自增属性（AUTO_INCREMENT）的时候，还可以指定第一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一条记录，同时指定id值为5，则以后插入的记录的id值就会从6开始往上增加。添加主键约束时，往往需要设置字段自动增加属性。</p>
<p><strong>面试4、并不是每个表都可以任意选择存储引擎？</strong><br>外键约束（FOREIGN KEY）不能跨引擎使用。</p>
<p>MySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不能创建外键约束的。所以说，存储引擎的选择也不完全是随意的。</p>
<hr>
<h1 id="第14章-视图"><a href="#第14章-视图" class="headerlink" title="第14章_视图"></a>第14章_视图</h1><hr>
<h2 id="1-常见的数据库对象"><a href="#1-常见的数据库对象" class="headerlink" title="1. 常见的数据库对象"></a>1. 常见的数据库对象</h2><table>
<thead>
<tr>
<th>对象</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>表(TABLE)</td>
<td>表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录</td>
</tr>
<tr>
<td>数据字典</td>
<td>就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护，程序员通常不应该修改，只可查看</td>
</tr>
<tr>
<td>约束(CONSTRAINT)</td>
<td>执行数据校验的规则，用于保证数据完整性的规则</td>
</tr>
<tr>
<td>视图(VIEW)</td>
<td>一个或者多个数据表里的数据的逻辑显示，视图并不存储数据</td>
</tr>
<tr>
<td>索引(INDEX)</td>
<td>用于提高查询性能，相当于书的目录</td>
</tr>
<tr>
<td>存储过程(PROCEDURE)</td>
<td>用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境</td>
</tr>
<tr>
<td>存储函数(FUNCTION)</td>
<td>用于完成一次特定的计算，具有一个返回值</td>
</tr>
<tr>
<td>触发器(TRIGGER)</td>
<td>相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理</td>
</tr>
</tbody></table>
<h2 id="2-视图概述"><a href="#2-视图概述" class="headerlink" title="2. 视图概述"></a>2. 视图概述</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/1555430281798.png"
                        alt="1555430281798"
                 ></p>
<h3 id="2-1-为什么使用视图？"><a href="#2-1-为什么使用视图？" class="headerlink" title="2.1 为什么使用视图？"></a>2.1 为什么使用视图？</h3><p>视图一方面可以帮我们使用表的一部分而不是所有的表，另一方面也可以针对不同的用户制定不同的查询视图。比如，针对一个公司的销售人员，我们只想给他看部分数据，而某些特殊的数据，比如采购的价格，则不会提供给他。再比如，人员薪酬是个敏感的字段，那么只给某个级别以上的人员开放，其他人的查询视图中则不提供这个字段。</p>
<p>刚才讲的只是视图的一个使用场景，实际上视图还有很多作用。最后，我们总结视图的优点。</p>
<h3 id="2-2-视图的理解"><a href="#2-2-视图的理解" class="headerlink" title="2.2 视图的理解"></a>2.2 视图的理解</h3><ul>
<li><p>视图是一种<code>虚拟表</code>，本身是<code>不具有数据</code>的，占用很少的内存空间，它是 SQL 中的一个重要概念。</p>
</li>
<li><p><strong>视图建立在已有表的基础上</strong>, 视图赖以建立的这些表称为<strong>基表</strong>。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/image-20211006211206990.png"
                         alt="image-20211006211206990" style="zoom:67%;" 
                 >
</li>
<li><p>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。</p>
</li>
<li><p>向视图提供数据内容的语句为 SELECT 语句, 可以将视图理解为<strong>存储起来的</strong> <strong>SELECT</strong> <strong>语句</strong></p>
<ul>
<li>在数据库中，视图不会保存数据，数据真正保存在数据表中。当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化；反之亦然。</li>
</ul>
</li>
<li><p>视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。</p>
</li>
</ul>
<h2 id="3-创建视图"><a href="#3-创建视图" class="headerlink" title="3. 创建视图"></a>3. 创建视图</h2><ul>
<li><strong>在</strong> <strong>CREATE VIEW</strong> <strong>语句中嵌入子查询</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE [OR REPLACE] </span><br><span class="line">[ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] </span><br><span class="line">VIEW 视图名称 [(字段列表)]</span><br><span class="line">AS 查询语句</span><br><span class="line">[WITH [CASCADED|LOCAL] CHECK OPTION]</span><br></pre></td></tr></table></figure>

<ul>
<li>精简版</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW 视图名称 </span><br><span class="line">AS 查询语句</span><br></pre></td></tr></table></figure>

<h3 id="3-1-创建单表视图"><a href="#3-1-创建单表视图" class="headerlink" title="3.1 创建单表视图"></a>3.1 创建单表视图</h3><p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW empvu80</span><br><span class="line">AS </span><br><span class="line">SELECT  employee_id, last_name, salary</span><br><span class="line">FROM    employees</span><br><span class="line">WHERE   department_id = 80;</span><br></pre></td></tr></table></figure>

<p>查询视图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM	salvu80;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="MySQL/1555430882363.png"
                         alt="1555430882363" style="zoom:80%;" 
                 >

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW emp_year_salary (ename,year_salary)</span><br><span class="line">AS </span><br><span class="line">SELECT ename,salary*12*(1+IFNULL(commission_pct,0))</span><br><span class="line">FROM t_employee;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW salvu50</span><br><span class="line">AS </span><br><span class="line">SELECT  employee_id ID_NUMBER, last_name NAME,salary*12 ANN_SALARY</span><br><span class="line">FROM    employees</span><br><span class="line">WHERE   department_id = 50;</span><br></pre></td></tr></table></figure>

<p>说明1：实际上就是我们在 SQL 查询语句的基础上封装了视图 VIEW，这样就会基于 SQL 语句的结果集形成一张虚拟表。</p>
<p>说明2：在创建视图时，没有在视图名后面指定字段列表，则视图中字段列表默认和SELECT语句中的字段列表一致。如果SELECT语句中给字段取了别名，那么视图中的字段名和别名相同。</p>
<h3 id="3-2-创建多表联合视图"><a href="#3-2-创建多表联合视图" class="headerlink" title="3.2 创建多表联合视图"></a>3.2 创建多表联合视图</h3><p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW empview </span><br><span class="line">AS </span><br><span class="line">SELECT employee_id emp_id,last_name NAME,department_name</span><br><span class="line">FROM employees e,departments d</span><br><span class="line">WHERE e.department_id = d.department_id;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW emp_dept</span><br><span class="line">AS </span><br><span class="line">SELECT ename,dname</span><br><span class="line">FROM t_employee LEFT JOIN t_department</span><br><span class="line">ON t_employee.did = t_department.did;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW	dept_sum_vu</span><br><span class="line">(name, minsal, maxsal, avgsal)</span><br><span class="line">AS </span><br><span class="line">SELECT d.department_name, MIN(e.salary), MAX(e.salary),AVG(e.salary)</span><br><span class="line">FROM employees e, departments d</span><br><span class="line">WHERE e.department_id = d.department_id </span><br><span class="line">GROUP BY  d.department_name;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>利用视图对数据进行格式化</strong></li>
</ul>
<p>我们经常需要输出某个格式的内容，比如我们想输出员工姓名和对应的部门名，对应格式为 emp_name(department_name)，就可以使用视图来完成数据格式化的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW emp_depart</span><br><span class="line">AS</span><br><span class="line">SELECT CONCAT(last_name,&#x27;(&#x27;,department_name,&#x27;)&#x27;) AS emp_dept</span><br><span class="line">FROM employees e JOIN departments d</span><br><span class="line">WHERE e.department_id = d.department_id</span><br></pre></td></tr></table></figure>

<h3 id="3-3-基于视图创建视图"><a href="#3-3-基于视图创建视图" class="headerlink" title="3.3 基于视图创建视图"></a>3.3 基于视图创建视图</h3><p>当我们创建好一张视图之后，还可以在它的基础上继续创建视图。</p>
<p>举例：联合“emp_dept”视图和“emp_year_salary”视图查询员工姓名、部门名称、年薪信息创建 “emp_dept_ysalary”视图。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW emp_dept_ysalary</span><br><span class="line">AS </span><br><span class="line">SELECT emp_dept.ename,dname,year_salary</span><br><span class="line">FROM emp_dept INNER JOIN emp_year_salary</span><br><span class="line">ON emp_dept.ename = emp_year_salary.ename;</span><br></pre></td></tr></table></figure>

<h2 id="4-查看视图"><a href="#4-查看视图" class="headerlink" title="4. 查看视图"></a>4. 查看视图</h2><p>语法1：查看数据库的表对象、视图对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure>

<p>语法2：查看视图的结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC / DESCRIBE 视图名称;</span><br></pre></td></tr></table></figure>

<p>语法3：查看视图的属性信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看视图信息（显示数据表的存储引擎、版本、数据行数和数据大小等）</span><br><span class="line">SHOW TABLE STATUS LIKE &#x27;视图名称&#x27;\G</span><br></pre></td></tr></table></figure>

<p>执行结果显示，注释Comment为VIEW，说明该表为视图，其他的信息为NULL，说明这是一个虚表。</p>
<p>语法4：查看视图的详细定义信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE VIEW 视图名称;</span><br></pre></td></tr></table></figure>

<h2 id="5-更新视图的数据"><a href="#5-更新视图的数据" class="headerlink" title="5. 更新视图的数据"></a>5. 更新视图的数据</h2><h3 id="5-1-一般情况"><a href="#5-1-一般情况" class="headerlink" title="5.1 一般情况"></a>5.1 一般情况</h3><p>MySQL支持使用INSERT、UPDATE和DELETE语句对视图中的数据进行插入、更新和删除操作。当视图中的数据发生变化时，数据表中的数据也会发生变化，反之亦然。</p>
<p>举例：UPDATE操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">+---------+-------------+</span><br><span class="line">| ename   | tel         |</span><br><span class="line">+---------+-------------+</span><br><span class="line">| 孙洪亮 	| 13789098765 |</span><br><span class="line">+---------+-------------+</span><br><span class="line">1 row in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE emp_tel SET tel = &#x27;13789091234&#x27; WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">+---------+-------------+</span><br><span class="line">| ename	  | tel         |</span><br><span class="line">+---------+-------------+</span><br><span class="line">| 	孙洪亮 | 13789091234 |</span><br><span class="line">+---------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT ename,tel FROM t_employee WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">+---------+-------------+</span><br><span class="line">| ename   | tel         |</span><br><span class="line">+---------+-------------+</span><br><span class="line">| 孙洪亮 	| 13789091234 |</span><br><span class="line">+---------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>举例：DELETE操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">+---------+-------------+</span><br><span class="line">| ename  	| tel           |</span><br><span class="line">+---------+-------------+</span><br><span class="line">| 孙洪亮 	| 13789091234 |</span><br><span class="line">+---------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; DELETE FROM emp_tel  WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT ename,tel FROM emp_tel WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT ename,tel FROM t_employee WHERE ename = &#x27;孙洪亮&#x27;;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-2-不可更新的视图"><a href="#5-2-不可更新的视图" class="headerlink" title="5.2 不可更新的视图"></a>5.2 不可更新的视图</h3><p>要使视图可更新，视图中的行和底层基本表中的行之间必须存在<code>一对一</code>的关系。另外当视图定义出现如下情况时，视图不支持更新操作：</p>
<ul>
<li>在定义视图的时候指定了“ALGORITHM &#x3D; TEMPTABLE”，视图将不支持INSERT和DELETE操作；</li>
<li>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作；</li>
<li>在定义视图的SELECT语句中使用了<code>JOIN联合查询</code>，视图将不支持INSERT和DELETE操作；</li>
<li>在定义视图的SELECT语句后的字段列表中使用了<code>数学表达式</code>或<code>子查询</code>，视图将不支持INSERT，也不支持UPDATE使用了数学表达式、子查询的字段值；</li>
<li>在定义视图的SELECT语句后的字段列表中使用<code>DISTINCT</code>、<code>聚合函数</code>、<code>GROUP BY</code>、<code>HAVING</code>、<code>UNION</code>等，视图将不支持INSERT、UPDATE、DELETE；</li>
<li>在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持INSERT、UPDATE、DELETE；</li>
<li>视图定义基于一个<code>不可更新视图</code>；</li>
<li>常量视图。</li>
</ul>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE OR REPLACE VIEW emp_dept</span><br><span class="line">    -&gt; (ename,salary,birthday,tel,email,hiredate,dname)</span><br><span class="line">    -&gt; AS SELECT ename,salary,birthday,tel,email,hiredate,dname</span><br><span class="line">    -&gt; FROM t_employee INNER JOIN t_department</span><br><span class="line">    -&gt; ON t_employee.did = t_department.did ;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; INSERT INTO emp_dept(ename,salary,birthday,tel,email,hiredate,dname)</span><br><span class="line">    -&gt; VALUES(&#x27;张三&#x27;,15000,&#x27;1995-01-08&#x27;,&#x27;18201587896&#x27;,</span><br><span class="line">    -&gt; &#x27;zs@atguigu.com&#x27;,&#x27;2022-02-14&#x27;,&#x27;新部门&#x27;);</span><br><span class="line">    </span><br><span class="line">#ERROR 1393 (HY000): Can not modify more than one base table through a join view &#x27;atguigu_chapter9.emp_dept&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面的SQL执行结果可以看出，在定义视图的SELECT语句中使用了JOIN联合查询，视图将不支持更新操作。</p>
<blockquote>
<p>虽然可以更新视图数据，但总的来说，视图作为<code>虚拟表</code>，主要用于<code>方便查询</code>，不建议更新视图的数据。<strong>对视图数据的更改，都是通过对实际数据表里数据的操作来完成的。</strong></p>
</blockquote>
<h2 id="6-修改、删除视图"><a href="#6-修改、删除视图" class="headerlink" title="6. 修改、删除视图"></a>6. 修改、删除视图</h2><h3 id="6-1-修改视图"><a href="#6-1-修改视图" class="headerlink" title="6.1 修改视图"></a>6.1 修改视图</h3><p>方式1：使用CREATE <strong>OR REPLACE</strong> VIEW 子句<strong>修改视图</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW empvu80</span><br><span class="line">(id_number, name, sal, department_id)</span><br><span class="line">AS </span><br><span class="line">SELECT  employee_id, first_name || &#x27; &#x27; || last_name, salary, department_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department_id = 80;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：CREATE VIEW 子句中各列的别名应和子查询中各列相对应。</p>
</blockquote>
<p>方式2：ALTER VIEW</p>
<p>修改视图的语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER VIEW 视图名称 </span><br><span class="line">AS</span><br><span class="line">查询语句</span><br></pre></td></tr></table></figure>

<h3 id="6-2-删除视图"><a href="#6-2-删除视图" class="headerlink" title="6.2 删除视图"></a>6.2 删除视图</h3><ul>
<li><p>删除视图只是删除视图的定义，并不会删除基表的数据。</p>
</li>
<li><p>删除视图的语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW IF EXISTS 视图名称;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW IF EXISTS 视图名称1,视图名称2,视图名称3,...;</span><br></pre></td></tr></table></figure>
</li>
<li><p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW empvu80;</span><br></pre></td></tr></table></figure>
</li>
<li><p>说明：基于视图a、b创建了新的视图c，如果将视图a或者视图b删除，会导致视图c的查询失败。这样的视图c需要手动删除或修改，否则影响使用。</p>
</li>
</ul>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><h3 id="7-1-视图优点"><a href="#7-1-视图优点" class="headerlink" title="7.1 视图优点"></a>7.1 视图优点</h3><p><strong>1. 操作简单</strong></p>
<p>将经常使用的查询操作定义为视图，可以使开发人员不需要关心视图对应的数据表的结构、表与表之间的关联关系，也不需要关心数据表之间的业务逻辑和查询条件，而只需要简单地操作视图即可，极大简化了开发人员对数据库的操作。</p>
<p><strong>2. 减少数据冗余</strong></p>
<p>视图跟实际数据表不一样，它存储的是查询语句。所以，在使用的时候，我们要通过定义视图的查询语句来获取结果集。而视图本身不存储数据，不占用数据存储的资源，减少了数据冗余。</p>
<p><strong>3. 数据安全</strong></p>
<p>MySQL将用户对数据的<code>访问限制</code>在某些数据的结果集上，而这些数据的结果集可以使用视图来实现。用户不必直接查询或操作数据表。这也可以理解为视图具有<code>隔离性</code>。视图相当于在用户和实际的数据表之间加了一层虚拟表。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211010211744459.png"
                        alt="image-20211010211744459"
                 ></p>
<p>同时，MySQL可以根据权限将用户对数据的访问限制在某些视图上，<strong>用户不需要查询数据表，可以直接通过视图获取数据表中的信息</strong>。这在一定程度上保障了数据表中数据的安全性。</p>
<p><strong>4. 适应灵活多变的需求</strong><br>当业务系统的需求发生变化后，如果需要改动数据表的结构，则工作量相对较大，可以使用视图来减少改动的工作量。这种方式在实际工作中使用得比较多。</p>
<p><strong>5. 能够分解复杂的查询逻辑</strong><br>数据库中如果存在复杂的查询逻辑，则可以将问题进行分解，创建多个视图获取数据，再将创建的多个视图结合起来，完成复杂的查询逻辑。</p>
<h3 id="7-2-视图不足"><a href="#7-2-视图不足" class="headerlink" title="7.2 视图不足"></a>7.2 视图不足</h3><p>如果我们在实际数据表的基础上创建了视图，那么，<strong>如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护</strong>。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂，<code>可读性不好</code>，容易变成系统的潜在隐患。因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本。</p>
<p>实际项目中，如果视图过多，会导致数据库维护成本的问题。</p>
<p>所以，在创建视图的时候，你要结合实际项目需求，综合考虑视图的优点和不足，这样才能正确使用视图，使系统整体达到最优。</p>
<hr>
<h1 id="第15章-存储过程与函数"><a href="#第15章-存储过程与函数" class="headerlink" title="第15章_存储过程与函数"></a>第15章_存储过程与函数</h1><hr>
<p>MySQL从5.0版本开始支持存储过程和函数。存储过程和函数能够将复杂的SQL逻辑封装在一起，应用程序无须关注存储过程和函数内部复杂的SQL逻辑，而只需要简单地调用存储过程和函数即可。</p>
<h2 id="1-存储过程概述"><a href="#1-存储过程概述" class="headerlink" title="1. 存储过程概述"></a>1. 存储过程概述</h2><h3 id="1-1-理解"><a href="#1-1-理解" class="headerlink" title="1.1 理解"></a>1.1 理解</h3><p><strong>含义</strong>：存储过程的英文是 <code>Stored Procedure</code>。它的思想很简单，就是一组经过<code>预先编译</code>的 SQL 语句的封装。</p>
<p>执行过程：存储过程预先存储在 MySQL 服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。</p>
<p><strong>好处</strong>：</p>
<p>1、简化操作，提高了sql语句的重用性，减少了开发程序员的压力<br>2、减少操作过程中的失误，提高效率<br>3、减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器）<br>4、减少了 SQL 语句暴露在网上的风险，也提高了数据查询的安全性</p>
<p><strong>和视图、函数的对比</strong>：</p>
<p>它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是<code>虚拟表</code>，通常不对底层数据表直接操作，而存储过程是程序化的 SQL，可以<code>直接操作底层数据表</code>，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。</p>
<p>一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于函数，存储过程是<code>没有返回值</code>的。</p>
<h3 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1.2 分类"></a>1.2 分类</h3><p>存储过程的参数类型可以是IN、OUT和INOUT。根据这点分类如下：</p>
<p>1、没有参数（无参数无返回）<br>2、仅仅带 IN 类型（有参数无返回）<br>3、仅仅带 OUT 类型（无参数有返回）<br>4、既带 IN 又带 OUT（有参数有返回）<br>5、带 INOUT（有参数有返回）</p>
<p>注意：IN、OUT、INOUT 都可以在一个存储过程中带多个。</p>
<h2 id="2-创建存储过程"><a href="#2-创建存储过程" class="headerlink" title="2. 创建存储过程"></a>2. 创建存储过程</h2><h3 id="2-1-语法分析"><a href="#2-1-语法分析" class="headerlink" title="2.1 语法分析"></a>2.1 语法分析</h3><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名 参数类型,...)</span><br><span class="line">[characteristics ...]</span><br><span class="line">BEGIN</span><br><span class="line">	存储过程体</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>类似于Java中的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回类型 方法名(参数类型 参数名,...)&#123;</span><br><span class="line"></span><br><span class="line">	方法体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>1、参数前面的符号的意思</p>
<ul>
<li><p><code>IN</code>：当前参数为输入参数，也就是表示入参；</p>
<p>存储过程只是读取这个参数的值。如果没有定义参数种类，<code>默认就是 IN</code>，表示输入参数。</p>
</li>
<li><p><code>OUT</code>：当前参数为输出参数，也就是表示出参；</p>
<p>执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。</p>
</li>
<li><p><code>INOUT</code>：当前参数既可以为输入参数，也可以为输出参数。</p>
</li>
</ul>
<p>2、形参类型可以是 MySQL数据库中的任意类型。</p>
<p>3、<code>characteristics</code> 表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LANGUAGE SQL</span><br><span class="line">| [NOT] DETERMINISTIC</span><br><span class="line">| &#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;</span><br><span class="line">| SQL SECURITY &#123; DEFINER | INVOKER &#125;</span><br><span class="line">| COMMENT &#x27;string&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>LANGUAGE SQL</code>：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL。</li>
<li><code>[NOT] DETERMINISTIC</code>：指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC表示结果是不确定的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为NOT DETERMINISTIC。</li>
<li><code>&#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;</code>：指明子程序使用SQL语句的限制。<ul>
<li>CONTAINS SQL表示当前存储过程的子程序包含SQL语句，但是并不包含读写数据的SQL语句；</li>
<li>NO SQL表示当前存储过程的子程序中不包含任何SQL语句；</li>
<li>READS SQL DATA表示当前存储过程的子程序中包含读数据的SQL语句；</li>
<li>MODIFIES SQL DATA表示当前存储过程的子程序中包含写数据的SQL语句。</li>
<li>默认情况下，系统会指定为CONTAINS SQL。</li>
</ul>
</li>
<li><code>SQL SECURITY &#123; DEFINER | INVOKER &#125;</code>：执行当前存储过程的权限，即指明哪些用户能够执行当前存储过程。<ul>
<li><code>DEFINER</code>表示只有当前存储过程的创建者或者定义者才能执行当前存储过程；</li>
<li><code>INVOKER</code>表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。</li>
<li>如果没有设置相关的值，则MySQL默认指定值为DEFINER。</li>
</ul>
</li>
<li><code>COMMENT &#39;string&#39;</code>：注释信息，可以用来描述存储过程。</li>
</ul>
<p>4、存储过程体中可以有多条 SQL 语句，如果仅仅一条SQL 语句，则可以省略 BEGIN 和 END</p>
<p>编写存储过程并不是一件简单的事情，可能存储过程中需要复杂的 SQL 语句。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. BEGIN…END：BEGIN…END 中间包含了多个语句，每个语句都以（;）号为结束符。</span><br><span class="line">2. DECLARE：DECLARE 用来声明变量，使用的位置在于 BEGIN…END 语句中间，而且需要在其他语句使用之前进行变量的声明。</span><br><span class="line">3. SET：赋值语句，用于对变量进行赋值。</span><br><span class="line">4. SELECT… INTO：把从数据表中查询的结果存放到变量中，也就是为变量赋值。</span><br></pre></td></tr></table></figure>

<p>5、需要设置新的结束标记</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER 新的结束标记</span><br></pre></td></tr></table></figure>

<p>因为MySQL默认的语句结束符号为分号‘;’。为了避免与存储过程中SQL语句结束符相冲突，需要使用DELIMITER改变存储过程的结束符。</p>
<p>比如：“DELIMITER &#x2F;&#x2F;”语句的作用是将MySQL的结束符设置为&#x2F;&#x2F;，并以“END &#x2F;&#x2F;”结束存储过程。存储过程定义完毕之后再使用“DELIMITER ;”恢复默认结束符。DELIMITER也可以指定其他符号作为结束符。</p>
<p>当使用DELIMITER命令时，应该避免使用反斜杠（‘\’）字符，因为反斜线是MySQL的转义字符。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)</span><br><span class="line">[characteristics ...]</span><br><span class="line">BEGIN</span><br><span class="line">	sql语句1;</span><br><span class="line">	sql语句2;</span><br><span class="line"></span><br><span class="line">END $</span><br></pre></td></tr></table></figure>

<h3 id="2-2-代码举例"><a href="#2-2-代码举例" class="headerlink" title="2.2 代码举例"></a>2.2 代码举例</h3><p>举例1：创建存储过程select_all_data()，查看 emps 表的所有数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE select_all_data()</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT * FROM emps;</span><br><span class="line">	</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>举例2：创建存储过程avg_employee_salary()，返回所有员工的平均工资</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE avg_employee_salary ()</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT AVG(salary) AS avg_salary FROM emps;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>举例3：创建存储过程show_max_salary()，用来查看“emps”表的最高薪资值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE show_max_salary()</span><br><span class="line">	LANGUAGE SQL</span><br><span class="line">	NOT DETERMINISTIC</span><br><span class="line">	CONTAINS SQL</span><br><span class="line">	SQL SECURITY DEFINER</span><br><span class="line">	COMMENT &#x27;查看最高薪资&#x27;</span><br><span class="line">	BEGIN</span><br><span class="line">		SELECT MAX(salary) FROM emps;</span><br><span class="line">	END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>举例4：创建存储过程show_min_salary()，查看“emps”表的最低薪资值。并将最低薪资通过OUT参数“ms”输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE show_min_salary(OUT ms DOUBLE)</span><br><span class="line">	BEGIN</span><br><span class="line">		SELECT MIN(salary) INTO ms FROM emps;</span><br><span class="line">	END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>举例5：创建存储过程show_someone_salary()，查看“emps”表的某个员工的薪资，并用IN参数empname输入员工姓名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE show_someone_salary(IN empname VARCHAR(20))</span><br><span class="line">	BEGIN</span><br><span class="line">		SELECT salary FROM emps WHERE ename = empname;</span><br><span class="line">	END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>举例6：创建存储过程show_someone_salary2()，查看“emps”表的某个员工的薪资，并用IN参数empname输入员工姓名，用OUT参数empsalary输出员工薪资。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE show_someone_salary2(IN empname VARCHAR(20),OUT empsalary DOUBLE)</span><br><span class="line">	BEGIN</span><br><span class="line">		SELECT salary INTO empsalary FROM emps WHERE ename = empname;</span><br><span class="line">	END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>举例7：创建存储过程show_mgr_name()，查询某个员工领导的姓名，并用INOUT参数“empname”输入员工姓名，输出领导的姓名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE show_mgr_name(INOUT empname VARCHAR(20))</span><br><span class="line">	BEGIN</span><br><span class="line">		SELECT ename INTO empname FROM emps</span><br><span class="line">		WHERE eid = (SELECT MID FROM emps WHERE ename=empname);</span><br><span class="line">	END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h2 id="3-调用存储过程"><a href="#3-调用存储过程" class="headerlink" title="3. 调用存储过程"></a>3. 调用存储过程</h2><h3 id="3-1-调用格式"><a href="#3-1-调用格式" class="headerlink" title="3.1 调用格式"></a>3.1 调用格式</h3><p>存储过程有多种调用方法。存储过程必须使用CALL语句调用，并且存储过程和数据库相关，如果要执行其他数据库中的存储过程，需要指定数据库名称，例如CALL dbname.procname。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL 存储过程名(实参列表)</span><br></pre></td></tr></table></figure>

<p><strong>格式：</strong></p>
<p>1、调用in模式的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL sp1(&#x27;值&#x27;);</span><br></pre></td></tr></table></figure>

<p>2、调用out模式的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @name;</span><br><span class="line">CALL sp1(@name);</span><br><span class="line">SELECT @name;</span><br></pre></td></tr></table></figure>

<p>3、调用inout模式的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @name=值;</span><br><span class="line">CALL sp1(@name);</span><br><span class="line">SELECT @name;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-代码举例"><a href="#3-2-代码举例" class="headerlink" title="3.2 代码举例"></a>3.2 代码举例</h3><p><strong>举例1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE CountProc(IN sid INT,OUT num INT)</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT COUNT(*) INTO num FROM fruits </span><br><span class="line">	WHERE s_id = sid;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>调用存储过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CALL CountProc (101, @num);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>查看返回结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT @num;</span><br></pre></td></tr></table></figure>

<p>该存储过程返回了指定 s_id&#x3D;101 的水果商提供的水果种类，返回值存储在num变量中，使用SELECT查看，返回结果为3。</p>
<p>**举例2：**创建存储过程，实现累加运算，计算 1+2+…+n 等于多少。具体的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE `add_num`(IN n INT)</span><br><span class="line">BEGIN</span><br><span class="line">       DECLARE i INT;</span><br><span class="line">       DECLARE sum INT;</span><br><span class="line">       </span><br><span class="line">       SET i = 1;</span><br><span class="line">       SET sum = 0;</span><br><span class="line">       WHILE i &lt;= n DO</span><br><span class="line">              SET sum = sum + i;</span><br><span class="line">              SET i = i +1;</span><br><span class="line">       END WHILE;</span><br><span class="line">       SELECT sum;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>如果你用的是 Navicat 工具，那么在编写存储过程的时候，Navicat 会自动设置 DELIMITER 为其他符号，我们不需要再进行 DELIMITER 的操作。</p>
<p>直接使用 <code>CALL add_num(50);</code>即可。这里我传入的参数为 50，也就是统计 1+2+…+50 的积累之和。</p>
<h3 id="3-3-如何调试"><a href="#3-3-如何调试" class="headerlink" title="3.3 如何调试"></a>3.3 如何调试</h3><p>在 MySQL 中，存储过程不像普通的编程语言（比如 VC++、Java 等）那样有专门的集成开发环境。因此，你可以通过 SELECT 语句，把程序执行的中间结果查询出来，来调试一个 SQL 语句的正确性。调试成功之后，把 SELECT 语句后移到下一个 SQL 语句之后，再调试下一个 SQL 语句。这样<code>逐步推进</code>，就可以完成对存储过程中所有操作的调试了。当然，你也可以把存储过程中的 SQL 语句复制出来，逐段单独调试。</p>
<h2 id="4-存储函数的使用"><a href="#4-存储函数的使用" class="headerlink" title="4. 存储函数的使用"></a>4. 存储函数的使用</h2><p>前面学习了很多函数，使用这些函数可以对数据进行的各种处理操作，极大地提高用户对数据库的管理效率。MySQL支持自定义函数，定义好之后，调用方式与调用MySQL预定义的系统函数一样。</p>
<h3 id="4-1-语法分析"><a href="#4-1-语法分析" class="headerlink" title="4.1 语法分析"></a>4.1 语法分析</h3><p>学过的函数：LENGTH、SUBSTR、CONCAT等</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE FUNCTION 函数名(参数名 参数类型,...) </span><br><span class="line">RETURNS 返回值类型</span><br><span class="line">[characteristics ...]</span><br><span class="line">BEGIN</span><br><span class="line">	函数体   #函数体中肯定有 RETURN 语句</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>1、参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参数。</p>
<p>2、RETURNS type 语句表示函数返回数据的类型；</p>
<p>RETURNS子句只能对FUNCTION做指定，对函数而言这是<code>强制</code>的。它用来指定函数的返回类型，而且函数体必须包含一个<code>RETURN value</code>语句。</p>
<p>3、characteristic 创建函数时指定的对函数的约束。取值与创建存储过程时相同，这里不再赘述。</p>
<p>4、函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END。</p>
<h3 id="4-2-调用存储函数"><a href="#4-2-调用存储函数" class="headerlink" title="4.2 调用存储函数"></a>4.2 调用存储函数</h3><p>在MySQL中，存储函数的使用方法与MySQL内部函数的使用方法是一样的。换言之，用户自己定义的存储函数与MySQL内部函数是一个性质的。区别在于，存储函数是<code>用户自己定义</code>的，而内部函数是MySQL的<code>开发者定义</code>的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 函数名(实参列表)</span><br></pre></td></tr></table></figure>

<h3 id="4-3-代码举例"><a href="#4-3-代码举例" class="headerlink" title="4.3 代码举例"></a>4.3 代码举例</h3><p><strong>举例1：</strong></p>
<p>创建存储函数，名称为email_by_name()，参数定义为空，该函数查询Abel的email，并返回，数据类型为字符串型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION email_by_name()</span><br><span class="line">RETURNS VARCHAR(25)</span><br><span class="line">DETERMINISTIC</span><br><span class="line">CONTAINS SQL</span><br><span class="line">BEGIN</span><br><span class="line">	RETURN (SELECT email FROM employees WHERE last_name = &#x27;Abel&#x27;);</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT email_by_name();</span><br></pre></td></tr></table></figure>

<p><strong>举例2：</strong></p>
<p>创建存储函数，名称为email_by_id()，参数传入emp_id，该函数查询emp_id的email，并返回，数据类型为字符串型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION email_by_id(emp_id INT)</span><br><span class="line">RETURNS VARCHAR(25)</span><br><span class="line">DETERMINISTIC</span><br><span class="line">CONTAINS SQL</span><br><span class="line">BEGIN</span><br><span class="line">	RETURN (SELECT email FROM employees WHERE employee_id = emp_id);</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @emp_id = 102;</span><br><span class="line">SELECT email_by_id(102);</span><br></pre></td></tr></table></figure>

<p><strong>举例3：</strong></p>
<p>创建存储函数count_by_id()，参数传入dept_id，该函数查询dept_id部门的员工人数，并返回，数据类型为整型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION count_by_id(dept_id INT)</span><br><span class="line">RETURNS INT</span><br><span class="line">	LANGUAGE SQL</span><br><span class="line">	NOT DETERMINISTIC</span><br><span class="line">	READS SQL DATA</span><br><span class="line">	SQL SECURITY DEFINER</span><br><span class="line">	COMMENT &#x27;查询部门平均工资&#x27;</span><br><span class="line">BEGIN</span><br><span class="line">	RETURN (SELECT COUNT(*) FROM employees WHERE department_id = dept_id);</span><br><span class="line">	</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @dept_id = 50;</span><br><span class="line">SELECT count_by_id(@dept_id);</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>若在创建存储函数中报错“<code>you might want to use the less safe log_bin_trust_function_creators variable</code>”，有两种处理方法：</p>
<ul>
<li><p>方式1：加上必要的函数特性“[NOT] DETERMINISTIC”和“{CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA}”</p>
</li>
<li><p>方式2：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL log_bin_trust_function_creators = 1;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-对比存储函数和存储过程"><a href="#4-4-对比存储函数和存储过程" class="headerlink" title="4.4 对比存储函数和存储过程"></a>4.4 对比存储函数和存储过程</h3><table>
<thead>
<tr>
<th></th>
<th>关键字</th>
<th>调用语法</th>
<th>返回值</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>存储过程</td>
<td>PROCEDURE</td>
<td>CALL 存储过程()</td>
<td>理解为有0个或多个</td>
<td>一般用于更新</td>
</tr>
<tr>
<td>存储函数</td>
<td>FUNCTION</td>
<td>SELECT 函数()</td>
<td>只能是一个</td>
<td>一般用于查询结果为一个值并返回时</td>
</tr>
</tbody></table>
<p>此外，<strong>存储函数可以放在查询语句中使用，存储过程不行</strong>。反之，存储过程的功能更加强大，包括能够执行对表的操作（比如创建表，删除表等）和事务操作，这些功能是存储函数不具备的。</p>
<h2 id="5-存储过程和函数的查看、修改、删除"><a href="#5-存储过程和函数的查看、修改、删除" class="headerlink" title="5. 存储过程和函数的查看、修改、删除"></a>5. 存储过程和函数的查看、修改、删除</h2><h3 id="5-1-查看"><a href="#5-1-查看" class="headerlink" title="5.1 查看"></a>5.1 查看</h3><p>创建完之后，怎么知道我们创建的存储过程、存储函数是否成功了呢？</p>
<p>MySQL存储了存储过程和函数的状态信息，用户可以使用SHOW STATUS语句或SHOW CREATE语句来查看，也可直接从系统的information_schema数据库中查询。这里介绍3种方法。</p>
<p><strong>1. 使用SHOW CREATE语句查看存储过程和函数的创建信息</strong></p>
<p>基本语法结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE &#123;PROCEDURE | FUNCTION&#125; 存储过程名或函数名</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE FUNCTION test_db.CountProc \G</span><br></pre></td></tr></table></figure>

<p><strong>2. 使用SHOW STATUS语句查看存储过程和函数的状态信息</strong></p>
<p>基本语法结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW &#123;PROCEDURE | FUNCTION&#125; STATUS [LIKE &#x27;pattern&#x27;]</span><br></pre></td></tr></table></figure>

<p>这个语句返回子程序的特征，如数据库、名字、类型、创建者及创建和修改日期。</p>
<p>[LIKE ‘pattern’]：匹配存储过程或函数的名称，可以省略。当省略不写时，会列出MySQL数据库中存在的所有存储过程或函数的信息。<br>举例：SHOW STATUS语句示例，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW PROCEDURE STATUS LIKE &#x27;SELECT%&#x27; \G </span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">                  Db: test_db</span><br><span class="line">                Name: SelectAllData</span><br><span class="line">                Type: PROCEDURE</span><br><span class="line">             Definer: root@localhost</span><br><span class="line">            Modified: 2021-10-16 15:55:07</span><br><span class="line">             Created: 2021-10-16 15:55:07</span><br><span class="line">       Security_type: DEFINER</span><br><span class="line">             Comment: </span><br><span class="line">character_set_client: utf8mb4</span><br><span class="line">collation_connection: utf8mb4_general_ci</span><br><span class="line">  Database Collation: utf8mb4_general_ci</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>3. 从information_schema.Routines表中查看存储过程和函数的信息</strong></p>
<p>MySQL中存储过程和函数的信息存储在information_schema数据库下的Routines表中。可以通过查询该表的记录来查询存储过程和函数的信息。其基本语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.Routines</span><br><span class="line">WHERE ROUTINE_NAME=&#x27;存储过程或函数的名&#x27; [AND ROUTINE_TYPE = &#123;&#x27;PROCEDURE|FUNCTION&#x27;&#125;];</span><br></pre></td></tr></table></figure>

<p>说明：如果在MySQL数据库中存在存储过程和函数名称相同的情况，最好指定ROUTINE_TYPE查询条件来指明查询的是存储过程还是函数。</p>
<p>举例：从Routines表中查询名称为CountProc的存储函数的信息，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.Routines</span><br><span class="line">WHERE ROUTINE_NAME=&#x27;count_by_id&#x27;　AND　ROUTINE_TYPE = &#x27;FUNCTION&#x27; \G</span><br></pre></td></tr></table></figure>

<h3 id="5-2-修改"><a href="#5-2-修改" class="headerlink" title="5.2 修改"></a>5.2 修改</h3><p>修改存储过程或函数，不影响存储过程或函数功能，只是修改相关特性。使用ALTER语句实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER &#123;PROCEDURE | FUNCTION&#125; 存储过程或函数的名 [characteristic ...]</span><br></pre></td></tr></table></figure>

<p>其中，characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;</span><br><span class="line">| SQL SECURITY &#123; DEFINER | INVOKER &#125;</span><br><span class="line">| COMMENT &#x27;string&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CONTAINS SQL</code>，表示子程序包含SQL语句，但不包含读或写数据的语句。</li>
<li><code>NO SQL</code>，表示子程序中不包含SQL语句。</li>
<li><code>READS SQL DATA</code>，表示子程序中包含读数据的语句。</li>
<li><code>MODIFIES SQL DATA</code>，表示子程序中包含写数据的语句。</li>
<li><code>SQL SECURITY &#123; DEFINER | INVOKER &#125;</code>，指明谁有权限来执行。<ul>
<li><code>DEFINER</code>，表示只有定义者自己才能够执行。</li>
<li><code>INVOKER</code>，表示调用者可以执行。</li>
</ul>
</li>
<li><code>COMMENT &#39;string&#39;</code>，表示注释信息。</li>
</ul>
<blockquote>
<p>修改存储过程使用ALTER PROCEDURE语句，修改存储函数使用ALTER FUNCTION语句。但是，这两个语句的结构是一样的，语句中的所有参数也是一样的。</p>
</blockquote>
<p><strong>举例1：</strong></p>
<p>修改存储过程CountProc的定义。将读写权限改为MODIFIES SQL DATA，并指明调用者可以执行，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER　PROCEDURE　CountProc</span><br><span class="line">MODIFIES SQL DATA</span><br><span class="line">SQL SECURITY INVOKER ;</span><br></pre></td></tr></table></figure>

<p>查询修改后的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT specific_name,sql_data_access,security_type</span><br><span class="line">FROM information_schema.`ROUTINES`</span><br><span class="line">WHERE routine_name = &#x27;CountProc&#x27; AND routine_type = &#x27;PROCEDURE&#x27;;</span><br></pre></td></tr></table></figure>

<p>结果显示，存储过程修改成功。从查询的结果可以看出，访问数据的权限（SQL_DATA_ ACCESS）已经变成MODIFIES SQL DATA，安全类型（SECURITY_TYPE）已经变成INVOKER。</p>
<p><strong>举例2：</strong></p>
<p>修改存储函数CountProc的定义。将读写权限改为READS SQL DATA，并加上注释信息“FIND NAME”，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER　FUNCTION　CountProc</span><br><span class="line">READS SQL DATA</span><br><span class="line">COMMENT &#x27;FIND NAME&#x27; ;</span><br></pre></td></tr></table></figure>

<p>存储函数修改成功。从查询的结果可以看出，访问数据的权限（SQL_DATA_ACCESS）已经变成READS SQL DATA，函数注释（ROUTINE_COMMENT）已经变成FIND NAME。</p>
<h3 id="5-3-删除"><a href="#5-3-删除" class="headerlink" title="5.3 删除"></a>5.3 删除</h3><p>删除存储过程和函数，可以使用DROP语句，其语法结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP &#123;PROCEDURE | FUNCTION&#125; [IF EXISTS] 存储过程或函数的名</span><br></pre></td></tr></table></figure>

<p>IF EXISTS：如果程序或函数不存储，它可以防止发生错误，产生一个用SHOW WARNINGS查看的警告。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE CountProc;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP FUNCTION CountProc;</span><br></pre></td></tr></table></figure>

<h2 id="6-关于存储过程使用的争议"><a href="#6-关于存储过程使用的争议" class="headerlink" title="6. 关于存储过程使用的争议"></a>6. 关于存储过程使用的争议</h2><p>尽管存储过程有诸多优点，但是对于存储过程的使用，<strong>一直都存在着很多争议</strong>，比如有些公司对于大型项目要求使用存储过程，而有些公司在手册中明确禁止使用存储过程，为什么这些公司对存储过程的使用需求差别这么大呢？</p>
<h3 id="6-1-优点"><a href="#6-1-优点" class="headerlink" title="6.1 优点"></a>6.1 优点</h3><p>**1、存储过程可以一次编译多次使用。**存储过程只在创建时进行编译，之后的使用都不需要重新编译，这就提升了 SQL 的执行效率。</p>
<p>**2、可以减少开发工作量。**将代码<code>封装</code>成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以<code>重复使用</code>，在减少开发工作量的同时，还能保证代码的结构清晰。</p>
<p>**3、存储过程的安全性强。**我们在设定存储过程的时候可以<code>设置对用户的使用权限</code>，这样就和视图一样具有较强的安全性。</p>
<p>**4、可以减少网络传输量。**因为代码封装到存储过程中，每次使用只需要调用存储过程即可，这样就减少了网络传输量。</p>
<p>**5、良好的封装性。**在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要<code>连接一次即可</code>。</p>
<h3 id="6-2-缺点"><a href="#6-2-缺点" class="headerlink" title="6.2 缺点"></a>6.2 缺点</h3><p>基于上面这些优点，不少大公司都要求大型项目使用存储过程，比如微软、IBM 等公司。但是国内的阿里并不推荐开发人员使用存储过程，这是为什么呢？</p>
<blockquote>
<h4 id="阿里开发规范"><a href="#阿里开发规范" class="headerlink" title="阿里开发规范"></a>阿里开发规范</h4><p>【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p>
</blockquote>
<p>存储过程虽然有诸如上面的好处，但缺点也是很明显的。</p>
<p>**1、可移植性差。**存储过程不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。</p>
<p>**2、调试困难。**只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容易。虽然也有一些第三方工具可以对存储过程进行调试，但要收费。</p>
<p>**3、存储过程的版本管理很困难。**比如数据表索引发生变化了，可能会导致存储过程失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</p>
<p>**4、它不适合高并发的场景。**高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，<code>增加数据库的压力</code>，显然就不适用了。</p>
<p>小结：</p>
<p>存储过程既方便，又有局限性。尽管不同的公司对存储过程的态度不一，但是对于我们开发人员来说，不论怎样，掌握存储过程都是必备的技能之一。</p>
<hr>
<h1 id="第16章-变量、流程控制与游标"><a href="#第16章-变量、流程控制与游标" class="headerlink" title="第16章_变量、流程控制与游标"></a>第16章_变量、流程控制与游标</h1><hr>
<h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h2><p>在MySQL数据库的存储过程和函数中，可以使用变量来存储查询或计算的中间结果数据，或者输出最终的结果数据。</p>
<p>在 MySQL 数据库中，变量分为<code>系统变量</code>以及<code>用户自定义变量</code>。</p>
<h3 id="1-1-系统变量"><a href="#1-1-系统变量" class="headerlink" title="1.1 系统变量"></a>1.1 系统变量</h3><h4 id="1-1-1-系统变量分类"><a href="#1-1-1-系统变量分类" class="headerlink" title="1.1.1 系统变量分类"></a>1.1.1 系统变量分类</h4><p>变量由系统定义，不是用户定义，属于<code>服务器</code>层面。启动MySQL服务，生成MySQL服务实例期间，MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特征。这些系统变量的值要么是<code>编译MySQL时参数</code>的默认值，要么是<code>配置文件</code>（例如my.ini等）中的参数值。大家可以通过网址 <code>https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html</code> 查看MySQL文档的系统变量。</p>
<p>系统变量分为全局系统变量（需要添加<code>global</code> 关键字）以及会话系统变量（需要添加 <code>session</code> 关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。**如果不写，默认会话级别。**静态变量（在 MySQL 服务实例运行期间它们的值不能使用 set 动态修改）属于特殊的全局系统变量。</p>
<p>每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变量值的复制。如下图：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211108114846634.png"
                        alt="image-20211108114846634"
                 ></p>
<ul>
<li>全局系统变量针对于所有会话（连接）有效，但<code>不能跨重启</code></li>
<li>会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值。</li>
<li>会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改。</li>
</ul>
<p>在MySQL中有些系统变量只能是全局的，例如 max_connections 用于限制服务器的最大连接数；有些系统变量作用域既可以是全局又可以是会话，例如 character_set_client 用于设置客户端的字符集；有些系统变量的作用域只能是当前会话，例如 pseudo_thread_id 用于标记当前会话的 MySQL 连接 ID。</p>
<h4 id="1-1-2-查看系统变量"><a href="#1-1-2-查看系统变量" class="headerlink" title="1.1.2 查看系统变量"></a>1.1.2 查看系统变量</h4><ul>
<li><strong>查看所有或部分系统变量</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看所有全局变量</span><br><span class="line">SHOW GLOBAL VARIABLES;</span><br><span class="line"></span><br><span class="line">#查看所有会话变量</span><br><span class="line">SHOW SESSION VARIABLES;</span><br><span class="line">或</span><br><span class="line">SHOW VARIABLES;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看满足条件的部分系统变量。</span><br><span class="line">SHOW GLOBAL VARIABLES LIKE &#x27;%标识符%&#x27;;</span><br><span class="line"></span><br><span class="line">#查看满足条件的部分会话变量</span><br><span class="line">SHOW SESSION VARIABLES LIKE &#x27;%标识符%&#x27;;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW GLOBAL VARIABLES LIKE &#x27;admin_%&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>查看指定系统变量</strong></li>
</ul>
<p>作为 MySQL 编码规范，MySQL 中的系统变量以<code>两个“@”</code>开头，其中“@@global”仅用于标记全局系统变量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在，则标记全局系统变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看指定的系统变量的值</span><br><span class="line">SELECT @@global.变量名;</span><br><span class="line"></span><br><span class="line">#查看指定的会话变量的值</span><br><span class="line">SELECT @@session.变量名;</span><br><span class="line">#或者</span><br><span class="line">SELECT @@变量名;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>修改系统变量的值</strong></li>
</ul>
<p>有些时候，数据库管理员需要修改系统变量的默认值，以便修改当前会话或者MySQL服务实例的属性、特征。具体方法：</p>
<p>方式1：修改MySQL<code>配置文件</code>，继而修改MySQL系统变量的值（该方法需要重启MySQL服务）</p>
<p>方式2：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#为某个系统变量赋值</span><br><span class="line">#方式1：</span><br><span class="line">SET @@global.变量名=变量值;</span><br><span class="line">#方式2：</span><br><span class="line">SET GLOBAL 变量名=变量值;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#为某个会话变量赋值</span><br><span class="line">#方式1：</span><br><span class="line">SET @@session.变量名=变量值;</span><br><span class="line">#方式2：</span><br><span class="line">SET SESSION 变量名=变量值;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @@global.autocommit;</span><br><span class="line">SET GLOBAL autocommit=0;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @@session.tx_isolation;</span><br><span class="line">SET @@session.tx_isolation=&#x27;read-uncommitted&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL max_connections = 1000;</span><br><span class="line">SELECT @@global.max_connections;</span><br></pre></td></tr></table></figure>



<h3 id="1-2-用户变量"><a href="#1-2-用户变量" class="headerlink" title="1.2 用户变量"></a>1.2 用户变量</h3><h4 id="1-2-1-用户变量分类"><a href="#1-2-1-用户变量分类" class="headerlink" title="1.2.1 用户变量分类"></a>1.2.1 用户变量分类</h4><p>用户变量是用户自己定义的，作为 MySQL 编码规范，MySQL 中的用户变量以<code>一个“@”</code>开头。根据作用范围不同，又分为<code>会话用户变量</code>和<code>局部变量</code>。</p>
<ul>
<li><p>会话用户变量：作用域和会话变量一样，只对<code>当前连接</code>会话有效。</p>
</li>
<li><p>局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在<code>存储过程和函数</code>中使用。</p>
</li>
</ul>
<h4 id="1-2-2-会话用户变量"><a href="#1-2-2-会话用户变量" class="headerlink" title="1.2.2 会话用户变量"></a>1.2.2 会话用户变量</h4><ul>
<li>变量的定义</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式1：“=”或“:=”</span><br><span class="line">SET @用户变量 = 值;</span><br><span class="line">SET @用户变量 := 值;</span><br><span class="line"></span><br><span class="line">#方式2：“:=” 或 INTO关键字</span><br><span class="line">SELECT @用户变量 := 表达式 [FROM 等子句];</span><br><span class="line">SELECT 表达式 INTO @用户变量  [FROM 等子句];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>查看用户变量的值 （查看、比较、运算等）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @用户变量</span><br></pre></td></tr></table></figure>

<ul>
<li>举例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @a = 1;</span><br><span class="line"></span><br><span class="line">SELECT @a;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @num := COUNT(*) FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT @num;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT AVG(salary) INTO @avgsalary FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT @avgsalary;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @big;  #查看某个未声明的变量时，将得到NULL值</span><br></pre></td></tr></table></figure>

<h4 id="1-2-3-局部变量"><a href="#1-2-3-局部变量" class="headerlink" title="1.2.3 局部变量"></a>1.2.3 局部变量</h4><p>定义：可以使用<code>DECLARE</code>语句定义一个局部变量</p>
<p>作用域：仅仅在定义它的 BEGIN … END 中有效</p>
<p>位置：只能放在 BEGIN … END 中，而且只能放在第一句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">	#声明局部变量</span><br><span class="line">	DECLARE 变量名1 变量数据类型 [DEFAULT 变量默认值];</span><br><span class="line">	DECLARE 变量名2,变量名3,... 变量数据类型 [DEFAULT 变量默认值];</span><br><span class="line"></span><br><span class="line">	#为局部变量赋值</span><br><span class="line">	SET 变量名1 = 值;</span><br><span class="line">	SELECT 值 INTO 变量名2 [FROM 子句];</span><br><span class="line"></span><br><span class="line">	#查看局部变量的值</span><br><span class="line">	SELECT 变量1,变量2,变量3;</span><br><span class="line">END</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>1.定义变量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE 变量名 类型 [default 值];  # 如果没有DEFAULT子句，初始值为NULL</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE　myparam　INT　DEFAULT 100;</span><br></pre></td></tr></table></figure>

<p><strong>2.变量赋值</strong></p>
<p>方式1：一般用于赋简单的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET 变量名=值;</span><br><span class="line">SET 变量名:=值;</span><br></pre></td></tr></table></figure>

<p>方式2：一般用于赋表中的字段值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段名或表达式 INTO 变量名 FROM 表;</span><br></pre></td></tr></table></figure>

<p><strong>3.使用变量</strong>（查看、比较、运算等）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 局部变量名;</span><br></pre></td></tr></table></figure>

<p>举例1：声明局部变量，并分别赋值为employees表中employee_id为102的last_name和salary</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE set_value()</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE emp_name VARCHAR(25);</span><br><span class="line">	DECLARE sal DOUBLE(10,2);</span><br><span class="line">	</span><br><span class="line">	SELECT last_name,salary INTO emp_name,sal</span><br><span class="line">	FROM employees </span><br><span class="line">	WHERE employee_id = 102;</span><br><span class="line">	</span><br><span class="line">	SELECT emp_name,sal;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>举例2：声明两个变量，求和并打印 （分别使用会话用户变量、局部变量的方式实现）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式1：使用用户变量</span><br><span class="line">SET @m=1;</span><br><span class="line">SET @n=1;</span><br><span class="line">SET @sum=@m+@n;</span><br><span class="line"></span><br><span class="line">SELECT @sum;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式2：使用局部变量</span><br><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE add_value()</span><br><span class="line">BEGIN</span><br><span class="line">	#局部变量</span><br><span class="line">	DECLARE m INT DEFAULT 1;</span><br><span class="line">	DECLARE n INT DEFAULT 3;</span><br><span class="line">	DECLARE SUM INT;</span><br><span class="line">	</span><br><span class="line">	SET SUM = m+n;</span><br><span class="line">	SELECT SUM;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>举例3：创建存储过程“different_salary”查询某员工和他领导的薪资差距，并用IN参数emp_id接收员工id，用OUT参数dif_salary输出薪资差距结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#声明</span><br><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE different_salary(IN emp_id INT,OUT dif_salary DOUBLE)</span><br><span class="line">BEGIN</span><br><span class="line">	#声明局部变量</span><br><span class="line">	DECLARE emp_sal,mgr_sal DOUBLE DEFAULT 0.0;</span><br><span class="line">	DECLARE mgr_id INT;</span><br><span class="line">	</span><br><span class="line">	SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;</span><br><span class="line">	SELECT manager_id INTO mgr_id FROM employees WHERE employee_id = emp_id;</span><br><span class="line">	SELECT salary INTO mgr_sal FROM employees WHERE employee_id = mgr_id;</span><br><span class="line">	SET dif_salary = mgr_sal - emp_sal;</span><br><span class="line"></span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line">SET @emp_id = 102;</span><br><span class="line">CALL different_salary(@emp_id,@diff_sal);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#查看</span><br><span class="line">SELECT @diff_sal;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-4-对比会话用户变量与局部变量"><a href="#1-2-4-对比会话用户变量与局部变量" class="headerlink" title="1.2.4 对比会话用户变量与局部变量"></a>1.2.4 对比会话用户变量与局部变量</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">			  作用域					定义位置				  语法</span><br><span class="line">会话用户变量	  当前会话				   会话的任何地方				加@符号，不用指定类型</span><br><span class="line">局部变量	   定义它的BEGIN END中 		BEGIN END的第一句话		  一般不用加@,需要指定类型</span><br></pre></td></tr></table></figure>

<h2 id="2-定义条件与处理程序"><a href="#2-定义条件与处理程序" class="headerlink" title="2. 定义条件与处理程序"></a>2. 定义条件与处理程序</h2><p><code>定义条件</code>是事先定义程序执行过程中可能遇到的问题，<code>处理程序</code>定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能力，避免程序异常停止运行。</p>
<p>说明：定义条件和处理程序在存储过程、存储函数中都是支持的。</p>
<h3 id="2-1-案例分析"><a href="#2-1-案例分析" class="headerlink" title="2.1 案例分析"></a>2.1 案例分析</h3><p>**案例分析：**创建一个名称为“UpdateDataNoCondition”的存储过程。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE UpdateDataNoCondition()</span><br><span class="line">	BEGIN</span><br><span class="line">		SET @x = 1;</span><br><span class="line">		UPDATE employees SET email = NULL WHERE last_name = &#x27;Abel&#x27;;</span><br><span class="line">		SET @x = 2;</span><br><span class="line">		UPDATE employees SET email = &#x27;aabbel&#x27; WHERE last_name = &#x27;Abel&#x27;;</span><br><span class="line">		SET @x = 3;</span><br><span class="line">	END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>调用存储过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CALL UpdateDataNoCondition();</span><br><span class="line">ERROR 1048 (23000): Column &#x27;email&#x27; cannot be null</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT @x;</span><br><span class="line">+------+</span><br><span class="line">| @x   |</span><br><span class="line">+------+</span><br><span class="line">|   1  |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，此时@x变量的值为1。结合创建存储过程的SQL语句代码可以得出：在存储过程中未定义条件和处理程序，且当存储过程中执行的SQL语句报错时，MySQL数据库会抛出错误，并退出当前SQL逻辑，不再向下继续执行。</p>
<h3 id="2-2-定义条件"><a href="#2-2-定义条件" class="headerlink" title="2.2 定义条件"></a>2.2 定义条件</h3><p>定义条件就是给MySQL中的错误码命名，这有助于存储的程序代码更清晰。它将一个<code>错误名字</code>和<code>指定的错误条件</code>关联起来。这个名字可以随后被用在定义处理程序的<code>DECLARE HANDLER</code>语句中。</p>
<p>定义条件使用DECLARE语句，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE 错误名称 CONDITION FOR 错误码（或错误条件）</span><br></pre></td></tr></table></figure>

<p>错误码的说明：</p>
<ul>
<li><code>MySQL_error_code</code>和<code>sqlstate_value</code>都可以表示MySQL的错误。<ul>
<li>MySQL_error_code是数值类型错误代码。</li>
<li>sqlstate_value是长度为5的字符串类型错误代码。</li>
</ul>
</li>
<li>例如，在ERROR 1418 (HY000)中，1418是MySQL_error_code，’HY000’是sqlstate_value。</li>
<li>例如，在ERROR 1142（42000）中，1142是MySQL_error_code，’42000’是sqlstate_value。</li>
</ul>
<p>**举例1：**定义“Field_Not_Be_NULL”错误名与MySQL中违反非空约束的错误类型是“ERROR 1048 (23000)”对应。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用MySQL_error_code</span><br><span class="line">DECLARE Field_Not_Be_NULL CONDITION FOR 1048;</span><br><span class="line"></span><br><span class="line">#使用sqlstate_value</span><br><span class="line">DECLARE Field_Not_Be_NULL CONDITION FOR SQLSTATE &#x27;23000&#x27;;</span><br></pre></td></tr></table></figure>

<p>**举例2：**定义”ERROR 1148(42000)”错误，名称为command_not_allowed。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#使用MySQL_error_code</span><br><span class="line">DECLARE command_not_allowed CONDITION FOR 1148;</span><br><span class="line"></span><br><span class="line">#使用sqlstate_value</span><br><span class="line">DECLARE command_not_allowed CONDITION FOR SQLSTATE &#x27;42000&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-定义处理程序"><a href="#2-3-定义处理程序" class="headerlink" title="2.3 定义处理程序"></a>2.3 定义处理程序</h3><p>可以为SQL执行过程中发生的某种类型的错误定义特殊的处理程序。定义处理程序时，使用DECLARE语句的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE 处理方式 HANDLER FOR 错误类型 处理语句</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>处理方式</strong>：处理方式有3个取值：CONTINUE、EXIT、UNDO。<ul>
<li><code>CONTINUE</code>：表示遇到错误不处理，继续执行。</li>
<li><code>EXIT</code>：表示遇到错误马上退出。</li>
<li><code>UNDO</code>：表示遇到错误后撤回之前的操作。MySQL中暂时不支持这样的操作。</li>
</ul>
</li>
<li><strong>错误类型</strong>（即条件）可以有如下取值：<ul>
<li><code>SQLSTATE &#39;字符串错误码&#39;</code>：表示长度为5的sqlstate_value类型的错误代码；</li>
<li><code>MySQL_error_code</code>：匹配数值类型错误代码；</li>
<li><code>错误名称</code>：表示DECLARE … CONDITION定义的错误条件名称。</li>
<li><code>SQLWARNING</code>：匹配所有以01开头的SQLSTATE错误代码；</li>
<li><code>NOT FOUND</code>：匹配所有以02开头的SQLSTATE错误代码；</li>
<li><code>SQLEXCEPTION</code>：匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误代码；</li>
</ul>
</li>
<li><strong>处理语句</strong>：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。语句可以是像“<code>SET 变量 = 值</code>”这样的简单语句，也可以是使用<code>BEGIN ... END</code>编写的复合语句。</li>
</ul>
<p>定义处理程序的几种方式，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方法1：捕获sqlstate_value</span><br><span class="line">DECLARE CONTINUE HANDLER FOR SQLSTATE &#x27;42S02&#x27; SET @info = &#x27;NO_SUCH_TABLE&#x27;;</span><br><span class="line"></span><br><span class="line">#方法2：捕获mysql_error_value</span><br><span class="line">DECLARE CONTINUE HANDLER FOR 1146 SET @info = &#x27;NO_SUCH_TABLE&#x27;;</span><br><span class="line"></span><br><span class="line">#方法3：先定义条件，再调用</span><br><span class="line">DECLARE no_such_table CONDITION FOR 1146;</span><br><span class="line">DECLARE CONTINUE HANDLER FOR NO_SUCH_TABLE SET @info = &#x27;NO_SUCH_TABLE&#x27;;</span><br><span class="line"></span><br><span class="line">#方法4：使用SQLWARNING</span><br><span class="line">DECLARE EXIT HANDLER FOR SQLWARNING SET @info = &#x27;ERROR&#x27;;</span><br><span class="line"></span><br><span class="line">#方法5：使用NOT FOUND</span><br><span class="line">DECLARE EXIT HANDLER FOR NOT FOUND SET @info = &#x27;NO_SUCH_TABLE&#x27;;</span><br><span class="line"></span><br><span class="line">#方法6：使用SQLEXCEPTION</span><br><span class="line">DECLARE EXIT HANDLER FOR SQLEXCEPTION SET @info = &#x27;ERROR&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-案例解决"><a href="#2-4-案例解决" class="headerlink" title="2.4 案例解决"></a>2.4 案例解决</h3><p>在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到MySQL_error_code值为1048时，执行CONTINUE操作，并且将@proc_value的值设置为-1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE UpdateDataNoCondition()</span><br><span class="line">	BEGIN</span><br><span class="line">		#定义处理程序</span><br><span class="line">		DECLARE CONTINUE HANDLER FOR 1048 SET @proc_value = -1;</span><br><span class="line">		</span><br><span class="line">		SET @x = 1;</span><br><span class="line">		UPDATE employees SET email = NULL WHERE last_name = &#x27;Abel&#x27;;</span><br><span class="line">		SET @x = 2;</span><br><span class="line">		UPDATE employees SET email = &#x27;aabbel&#x27; WHERE last_name = &#x27;Abel&#x27;;</span><br><span class="line">		SET @x = 3;</span><br><span class="line">	END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>调用过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CALL UpdateDataWithCondition();</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT @x,@proc_value;</span><br><span class="line">+------+-------------+</span><br><span class="line">| @x   | @proc_value |</span><br><span class="line">+------+-------------+</span><br><span class="line">|    3 |       	 -1  |</span><br><span class="line">+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>举例：</strong></p>
<p>创建一个名称为“InsertDataWithCondition”的存储过程，代码如下。</p>
<p>在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到sqlstate_value值为23000时，执行EXIT操作，并且将@proc_value的值设置为-1。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#准备工作</span><br><span class="line">CREATE TABLE departments</span><br><span class="line">AS</span><br><span class="line">SELECT * FROM atguigudb.`departments`;</span><br><span class="line"></span><br><span class="line">ALTER TABLE departments</span><br><span class="line">ADD CONSTRAINT uk_dept_name UNIQUE(department_id);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE InsertDataWithCondition()</span><br><span class="line">	BEGIN</span><br><span class="line">		DECLARE duplicate_entry CONDITION FOR SQLSTATE &#x27;23000&#x27; ;</span><br><span class="line">		DECLARE EXIT HANDLER FOR duplicate_entry SET @proc_value = -1;</span><br><span class="line">		</span><br><span class="line">		SET @x = 1;</span><br><span class="line">		INSERT INTO departments(department_name) VALUES(&#x27;测试&#x27;);</span><br><span class="line">		SET @x = 2;</span><br><span class="line">		INSERT INTO departments(department_name) VALUES(&#x27;测试&#x27;);</span><br><span class="line">		SET @x = 3;</span><br><span class="line">	END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>调用存储过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CALL InsertDataWithCondition();</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT @x,@proc_value;</span><br><span class="line">+------+-------------+</span><br><span class="line">| @x   | @proc_value |</span><br><span class="line">+------+-------------+</span><br><span class="line">|    2 |       	 -1  |</span><br><span class="line">+------+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-流程控制"><a href="#3-流程控制" class="headerlink" title="3. 流程控制"></a>3. 流程控制</h2><p>解决复杂问题不可能通过一个 SQL 语句完成，我们需要执行多个 SQL 操作。流程控制语句的作用就是控制存储过程中 SQL 语句的执行顺序，是我们完成复杂操作必不可少的一部分。只要是执行的程序，流程就分为三大类：</p>
<ul>
<li><code>顺序结构</code>：程序从上往下依次执行</li>
<li><code>分支结构</code>：程序按条件进行选择执行，从两条或多条路径中选择一条执行</li>
<li><code>循环结构</code>：程序满足一定条件下，重复执行一组语句</li>
</ul>
<p>针对于MySQL 的流程控制语句主要有 3 类。注意：只能用于存储程序。</p>
<ul>
<li><code>条件判断语句</code>：IF 语句和 CASE 语句</li>
<li><code>循环语句</code>：LOOP、WHILE 和 REPEAT 语句</li>
<li><code>跳转语句</code>：ITERATE 和 LEAVE 语句</li>
</ul>
<h3 id="3-1-分支结构之-IF"><a href="#3-1-分支结构之-IF" class="headerlink" title="3.1 分支结构之 IF"></a>3.1 分支结构之 IF</h3><ul>
<li>IF 语句的语法结构是：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IF 表达式1 THEN 操作1</span><br><span class="line">[ELSEIF 表达式2 THEN 操作2]……</span><br><span class="line">[ELSE 操作N]</span><br><span class="line">END IF</span><br></pre></td></tr></table></figure>

<p>根据表达式的结果为TRUE或FALSE执行相应的语句。这里“[]”中的内容是可选的。</p>
<ul>
<li><p>特点：① 不同的表达式对应不同的操作 ② 使用在begin end中</p>
</li>
<li><p><strong>举例1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IF val IS NULL </span><br><span class="line">	THEN SELECT &#x27;val is null&#x27;;</span><br><span class="line">ELSE SELECT &#x27;val is not null&#x27;;</span><br><span class="line"></span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**举例2：**声明存储过程“update_salary_by_eid1”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于8000元并且入职时间超过5年，就涨薪500元；否则就不变。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE update_salary_by_eid1(IN emp_id INT)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE emp_salary DOUBLE;</span><br><span class="line">	DECLARE hire_year DOUBLE;</span><br><span class="line"></span><br><span class="line">	SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;</span><br><span class="line"></span><br><span class="line">	SELECT DATEDIFF(CURDATE(),hire_date)/365 INTO hire_year</span><br><span class="line">	FROM employees WHERE employee_id = emp_id;</span><br><span class="line"></span><br><span class="line">	IF emp_salary &lt; 8000 AND hire_year &gt; 5</span><br><span class="line">	THEN UPDATE employees SET salary = salary + 500 WHERE employee_id = emp_id;</span><br><span class="line">	END IF;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**举例3：**声明存储过程“update_salary_by_eid2”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于9000元并且入职时间超过5年，就涨薪500元；否则就涨薪100元。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE update_salary_by_eid2(IN emp_id INT)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE emp_salary DOUBLE;</span><br><span class="line">	DECLARE hire_year DOUBLE;</span><br><span class="line"></span><br><span class="line">	SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;</span><br><span class="line"></span><br><span class="line">	SELECT DATEDIFF(CURDATE(),hire_date)/365 INTO hire_year</span><br><span class="line">	FROM employees WHERE employee_id = emp_id;</span><br><span class="line"></span><br><span class="line">	IF emp_salary &lt; 8000 AND hire_year &gt; 5</span><br><span class="line">		THEN UPDATE employees SET salary = salary + 500 WHERE employee_id = emp_id;</span><br><span class="line">	ELSE </span><br><span class="line">		UPDATE employees SET salary = salary + 100 WHERE employee_id = emp_id;</span><br><span class="line">	END IF;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**举例4：**声明存储过程“update_salary_by_eid3”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于9000元，就更新薪资为9000元；薪资如果大于等于9000元且低于10000的，但是奖金比例为NULL的，就更新奖金比例为0.01；其他的涨薪100元。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE update_salary_by_eid3(IN emp_id INT)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE emp_salary DOUBLE;</span><br><span class="line">	DECLARE bonus DECIMAL(3,2);</span><br><span class="line"></span><br><span class="line">	SELECT salary INTO emp_salary FROM employees WHERE employee_id = emp_id;</span><br><span class="line">	SELECT commission_pct INTO bonus FROM employees WHERE employee_id = emp_id;</span><br><span class="line"></span><br><span class="line">	IF emp_salary &lt; 9000</span><br><span class="line">		THEN UPDATE employees SET salary = 9000 WHERE employee_id = emp_id;</span><br><span class="line">	ELSEIF emp_salary &lt; 10000 AND bonus IS NULL</span><br><span class="line">		THEN UPDATE employees SET commission_pct = 0.01 WHERE employee_id = emp_id;</span><br><span class="line">	ELSE</span><br><span class="line">		UPDATE employees SET salary = salary + 100 WHERE employee_id = emp_id;</span><br><span class="line">	END IF;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-2-分支结构之-CASE"><a href="#3-2-分支结构之-CASE" class="headerlink" title="3.2 分支结构之 CASE"></a>3.2 分支结构之 CASE</h3><p>CASE 语句的语法结构1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#情况一：类似于switch</span><br><span class="line">CASE 表达式</span><br><span class="line">WHEN 值1 THEN 结果1或语句1(如果是语句，需要加分号) </span><br><span class="line">WHEN 值2 THEN 结果2或语句2(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line">ELSE 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line">END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）</span><br></pre></td></tr></table></figure>

<p>CASE 语句的语法结构2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#情况二：类似于多重if</span><br><span class="line">CASE </span><br><span class="line">WHEN 条件1 THEN 结果1或语句1(如果是语句，需要加分号) </span><br><span class="line">WHEN 条件2 THEN 结果2或语句2(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line">ELSE 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line">END [case]（如果是放在begin end中需要加上case，如果放在select后面不需要）</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>举例1：</strong></li>
</ul>
<p>使用CASE流程控制语句的第1种格式，判断val值等于1、等于2，或者两者都不等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CASE val</span><br><span class="line">　　　WHEN 1 THEN SELECT &#x27;val is 1&#x27;;</span><br><span class="line">　　　WHEN 2 THEN SELECT &#x27;val is 2&#x27;;</span><br><span class="line">　　　ELSE SELECT &#x27;val is not 1 or 2&#x27;;</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>举例2：</strong></li>
</ul>
<p>使用CASE流程控制语句的第2种格式，判断val是否为空、小于0、大于0或者等于0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CASE</span><br><span class="line">	WHEN val IS NULL THEN SELECT &#x27;val is null&#x27;;</span><br><span class="line">	WHEN val &lt; 0 THEN SELECT &#x27;val is less than 0&#x27;;</span><br><span class="line">	WHEN val &gt; 0 THEN SELECT &#x27;val is greater than 0&#x27;;</span><br><span class="line">	ELSE SELECT &#x27;val is 0&#x27;;</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>

<ul>
<li>**举例3：**声明存储过程“update_salary_by_eid4”，定义IN参数emp_id，输入员工编号。判断该员工薪资如果低于9000元，就更新薪资为9000元；薪资大于等于9000元且低于10000的，但是奖金比例为NULL的，就更新奖金比例为0.01；其他的涨薪100元。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE update_salary_by_eid4(IN emp_id INT)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE emp_sal DOUBLE;</span><br><span class="line">	DECLARE bonus DECIMAL(3,2);</span><br><span class="line"></span><br><span class="line">	SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;</span><br><span class="line">	SELECT commission_pct INTO bonus FROM employees WHERE employee_id = emp_id;</span><br><span class="line"></span><br><span class="line">	CASE</span><br><span class="line">	WHEN emp_sal&lt;9000</span><br><span class="line">		THEN UPDATE employees SET salary=9000 WHERE employee_id = emp_id;</span><br><span class="line">	WHEN emp_sal&lt;10000 AND bonus IS NULL</span><br><span class="line">		THEN UPDATE employees SET commission_pct=0.01 WHERE employee_id = emp_id;</span><br><span class="line">	ELSE</span><br><span class="line">		UPDATE employees SET salary=salary+100 WHERE employee_id = emp_id;</span><br><span class="line">	END CASE;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<ul>
<li>举例4：声明存储过程update_salary_by_eid5，定义IN参数emp_id，输入员工编号。判断该员工的入职年限，如果是0年，薪资涨50；如果是1年，薪资涨100；如果是2年，薪资涨200；如果是3年，薪资涨300；如果是4年，薪资涨400；其他的涨薪500。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE update_salary_by_eid5(IN emp_id INT)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE emp_sal DOUBLE;</span><br><span class="line">	DECLARE hire_year DOUBLE;</span><br><span class="line"></span><br><span class="line">	SELECT salary INTO emp_sal FROM employees WHERE employee_id = emp_id;</span><br><span class="line">	</span><br><span class="line">	SELECT ROUND(DATEDIFF(CURDATE(),hire_date)/365) INTO hire_year FROM employees WHERE employee_id = emp_id;</span><br><span class="line"></span><br><span class="line">	CASE hire_year</span><br><span class="line">		WHEN 0 THEN UPDATE employees SET salary=salary+50 WHERE employee_id = emp_id;</span><br><span class="line">		WHEN 1 THEN UPDATE employees SET salary=salary+100 WHERE employee_id = emp_id;</span><br><span class="line">		WHEN 2 THEN UPDATE employees SET salary=salary+200 WHERE employee_id = emp_id;</span><br><span class="line">		WHEN 3 THEN UPDATE employees SET salary=salary+300 WHERE employee_id = emp_id;</span><br><span class="line">		WHEN 4 THEN UPDATE employees SET salary=salary+400 WHERE employee_id = emp_id;</span><br><span class="line">		ELSE UPDATE employees SET salary=salary+500 WHERE employee_id = emp_id;</span><br><span class="line">	END CASE;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-循环结构之LOOP"><a href="#3-3-循环结构之LOOP" class="headerlink" title="3.3 循环结构之LOOP"></a>3.3 循环结构之LOOP</h3><p>LOOP循环语句用来重复执行某些语句。LOOP内的语句一直重复执行直到循环被退出（使用LEAVE子句），跳出循环过程。</p>
<p>LOOP语句的基本格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[loop_label:] LOOP</span><br><span class="line">	循环执行的语句</span><br><span class="line">END LOOP [loop_label]</span><br></pre></td></tr></table></figure>

<p>其中，loop_label表示LOOP语句的标注名称，该参数可以省略。</p>
<p><strong>举例1：</strong></p>
<p>使用LOOP语句进行循环操作，id值小于10时将重复执行循环过程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE id INT DEFAULT 0;</span><br><span class="line">add_loop:LOOP</span><br><span class="line">	SET id = id +1;</span><br><span class="line">	IF id &gt;= 10 THEN LEAVE add_loop;</span><br><span class="line">	END IF;</span><br><span class="line"></span><br><span class="line">END LOOP add_loop;</span><br></pre></td></tr></table></figure>

<p>**举例2：**当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程“update_salary_loop()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨为原来的1.1倍。直到全公司的平均薪资达到12000结束。并统计循环次数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE update_salary_loop(OUT num INT)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE avg_salary DOUBLE;</span><br><span class="line">	DECLARE loop_count INT DEFAULT 0;</span><br><span class="line">	</span><br><span class="line">	SELECT AVG(salary) INTO avg_salary FROM employees;</span><br><span class="line">	</span><br><span class="line">	label_loop:LOOP</span><br><span class="line">		IF avg_salary &gt;= 12000 THEN LEAVE label_loop;</span><br><span class="line">		END IF;</span><br><span class="line">		</span><br><span class="line">		UPDATE employees SET salary = salary * 1.1;</span><br><span class="line">		SET loop_count = loop_count + 1;</span><br><span class="line">		SELECT AVG(salary) INTO avg_salary FROM employees;</span><br><span class="line">	END LOOP label_loop;</span><br><span class="line">	</span><br><span class="line">	SET num = loop_count;</span><br><span class="line"></span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-循环结构之WHILE"><a href="#3-4-循环结构之WHILE" class="headerlink" title="3.4 循环结构之WHILE"></a>3.4 循环结构之WHILE</h3><p>WHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如果为真，就执行循环内的语句，否则退出循环。WHILE语句的基本格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[while_label:] WHILE 循环条件  DO</span><br><span class="line">	循环体</span><br><span class="line">END WHILE [while_label];</span><br></pre></td></tr></table></figure>

<p>while_label为WHILE语句的标注名称；如果循环条件结果为真，WHILE语句内的语句或语句群被执行，直至循环条件为假，退出循环。</p>
<p><strong>举例1：</strong></p>
<p>WHILE语句示例，i值小于10时，将重复执行循环过程，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE test_while()</span><br><span class="line">BEGIN	</span><br><span class="line">	DECLARE i INT DEFAULT 0;</span><br><span class="line">	</span><br><span class="line">	WHILE i &lt; 10 DO</span><br><span class="line">		SET i = i + 1;</span><br><span class="line">	END WHILE;</span><br><span class="line">	</span><br><span class="line">	SELECT i;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line">#调用</span><br><span class="line">CALL test_while();</span><br></pre></td></tr></table></figure>

<p>**举例2：**市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“update_salary_while()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家降薪，薪资降为原来的90%。直到全公司的平均薪资达到5000结束。并统计循环次数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE update_salary_while(OUT num INT)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE avg_sal DOUBLE ;</span><br><span class="line">	DECLARE while_count INT DEFAULT 0;</span><br><span class="line">	</span><br><span class="line">	SELECT AVG(salary) INTO avg_sal FROM employees;</span><br><span class="line">	</span><br><span class="line">	WHILE avg_sal &gt; 5000 DO</span><br><span class="line">		UPDATE employees SET salary = salary * 0.9;</span><br><span class="line">		</span><br><span class="line">		SET while_count = while_count + 1;</span><br><span class="line">		</span><br><span class="line">		SELECT AVG(salary) INTO avg_sal FROM employees;</span><br><span class="line">	END WHILE;</span><br><span class="line">	</span><br><span class="line">	SET num = while_count;</span><br><span class="line"></span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>



<h3 id="3-5-循环结构之REPEAT"><a href="#3-5-循环结构之REPEAT" class="headerlink" title="3.5 循环结构之REPEAT"></a>3.5 循环结构之REPEAT</h3><p>REPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT 循环首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。</p>
<p>REPEAT语句的基本格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[repeat_label:] REPEAT</span><br><span class="line">　　　　循环体的语句</span><br><span class="line">UNTIL 结束循环的条件表达式</span><br><span class="line">END REPEAT [repeat_label]</span><br></pre></td></tr></table></figure>

<p>repeat_label为REPEAT语句的标注名称，该参数可以省略；REPEAT语句内的语句或语句群被重复，直至expr_condition为真。</p>
<p><strong>举例1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE test_repeat()</span><br><span class="line">BEGIN	</span><br><span class="line">	DECLARE i INT DEFAULT 0;</span><br><span class="line">	</span><br><span class="line">	REPEAT </span><br><span class="line">		SET i = i + 1;</span><br><span class="line">	UNTIL i &gt;= 10</span><br><span class="line">	END REPEAT;</span><br><span class="line">	</span><br><span class="line">	SELECT i;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>**举例2：**当市场环境变好时，公司为了奖励大家，决定给大家涨工资。声明存储过程“update_salary_repeat()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨为原来的1.15倍。直到全公司的平均薪资达到13000结束。并统计循环次数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE update_salary_repeat(OUT num INT)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE avg_sal DOUBLE ;</span><br><span class="line">	DECLARE repeat_count INT DEFAULT 0;</span><br><span class="line">	</span><br><span class="line">	SELECT AVG(salary) INTO avg_sal FROM employees;</span><br><span class="line">	</span><br><span class="line">	REPEAT</span><br><span class="line">		UPDATE employees SET salary = salary * 1.15;</span><br><span class="line">		</span><br><span class="line">		SET repeat_count = repeat_count + 1;</span><br><span class="line">		</span><br><span class="line">		SELECT AVG(salary) INTO avg_sal FROM employees;</span><br><span class="line">	UNTIL avg_sal &gt;= 13000</span><br><span class="line">	END REPEAT;</span><br><span class="line">	</span><br><span class="line">	SET num = repeat_count;</span><br><span class="line">		</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p><strong>对比三种循环结构：</strong></p>
<p>1、这三种循环都可以省略名称，但如果循环中添加了循环控制语句（LEAVE或ITERATE）则必须添加名称。<br>2、<br>LOOP：一般用于实现简单的”死”循环<br>WHILE：先判断后执行<br>REPEAT：先执行后判断，无条件至少执行一次</p>
<h3 id="3-6-跳转语句之LEAVE语句"><a href="#3-6-跳转语句之LEAVE语句" class="headerlink" title="3.6 跳转语句之LEAVE语句"></a>3.6 跳转语句之LEAVE语句</h3><p>LEAVE语句：可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出程序体的操作。如果你有面向过程的编程语言的使用经验，你可以把 LEAVE 理解为 break。</p>
<p>基本格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEAVE 标记名</span><br></pre></td></tr></table></figure>

<p>其中，label参数表示循环的标志。LEAVE和BEGIN … END或循环一起被使用。</p>
<p>**举例1：**创建存储过程 “leave_begin()”，声明INT类型的IN参数num。给BEGIN…END加标记名，并在BEGIN…END中使用IF语句判断num参数的值。</p>
<ul>
<li>如果num&lt;&#x3D;0，则使用LEAVE语句退出BEGIN…END；</li>
<li>如果num&#x3D;1，则查询“employees”表的平均薪资；</li>
<li>如果num&#x3D;2，则查询“employees”表的最低薪资；</li>
<li>如果num&gt;2，则查询“employees”表的最高薪资。</li>
</ul>
<p>IF语句结束后查询“employees”表的总人数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE leave_begin(IN num INT)</span><br><span class="line"></span><br><span class="line">	begin_label: BEGIN</span><br><span class="line">		IF num&lt;=0 </span><br><span class="line">			THEN LEAVE begin_label;</span><br><span class="line">		ELSEIF num=1 </span><br><span class="line">			THEN SELECT AVG(salary) FROM employees;</span><br><span class="line">		ELSEIF num=2 </span><br><span class="line">			THEN SELECT MIN(salary) FROM employees;</span><br><span class="line">		ELSE </span><br><span class="line">			SELECT MAX(salary) FROM employees;</span><br><span class="line">		END IF;</span><br><span class="line">		</span><br><span class="line">		SELECT COUNT(*) FROM employees;</span><br><span class="line">	END //</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p><strong>举例2：</strong></p>
<p>当市场环境不好时，公司为了渡过难关，决定暂时降低大家的薪资。声明存储过程“leave_while()”，声明OUT参数num，输出循环次数，存储过程中使用WHILE循环给大家降低薪资为原来薪资的90%，直到全公司的平均薪资小于等于10000，并统计循环次数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE leave_while(OUT num INT)</span><br><span class="line"></span><br><span class="line">BEGIN </span><br><span class="line">	#</span><br><span class="line">	DECLARE avg_sal DOUBLE;#记录平均工资</span><br><span class="line">	DECLARE while_count INT DEFAULT 0; #记录循环次数</span><br><span class="line">	</span><br><span class="line">	SELECT AVG(salary) INTO avg_sal FROM employees; #① 初始化条件</span><br><span class="line">	</span><br><span class="line">	while_label:WHILE TRUE DO  #② 循环条件</span><br><span class="line">		</span><br><span class="line">		#③ 循环体</span><br><span class="line">		IF avg_sal &lt;= 10000 THEN</span><br><span class="line">			LEAVE while_label;</span><br><span class="line">		END IF;</span><br><span class="line">		</span><br><span class="line">		UPDATE employees SET salary  = salary * 0.9;</span><br><span class="line">		SET while_count = while_count + 1;</span><br><span class="line">		</span><br><span class="line">		#④ 迭代条件</span><br><span class="line">		SELECT AVG(salary) INTO avg_sal FROM employees;</span><br><span class="line">	</span><br><span class="line">	END WHILE;</span><br><span class="line">	</span><br><span class="line">	#赋值</span><br><span class="line">	SET num = while_count;</span><br><span class="line"></span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>



<h3 id="3-7-跳转语句之ITERATE语句"><a href="#3-7-跳转语句之ITERATE语句" class="headerlink" title="3.7 跳转语句之ITERATE语句"></a>3.7 跳转语句之ITERATE语句</h3><p>ITERATE语句：只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序转到语句段开头处。如果你有面向过程的编程语言的使用经验，你可以把 ITERATE 理解为 continue，意思为“再次循环”。</p>
<p>语句基本格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ITERATE label</span><br></pre></td></tr></table></figure>

<p>label参数表示循环的标志。ITERATE语句必须跟在循环标志前面。</p>
<p><strong>举例：</strong>  定义局部变量num，初始值为0。循环结构中执行num + 1操作。</p>
<ul>
<li>如果num &lt; 10，则继续执行循环；</li>
<li>如果num &gt; 15，则退出循环结构；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE test_iterate()</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE num INT DEFAULT 0;</span><br><span class="line">	</span><br><span class="line">	my_loop:LOOP</span><br><span class="line">		SET num = num + 1;</span><br><span class="line">	</span><br><span class="line">		IF num &lt; 10 </span><br><span class="line">			THEN ITERATE my_loop;</span><br><span class="line">		ELSEIF num &gt; 15 </span><br><span class="line">			THEN LEAVE my_loop;</span><br><span class="line">		END IF;</span><br><span class="line">	</span><br><span class="line">		SELECT &#x27;尚硅谷：让天下没有难学的技术&#x27;;</span><br><span class="line">	</span><br><span class="line">	END LOOP my_loop;</span><br><span class="line"></span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h2 id="4-游标"><a href="#4-游标" class="headerlink" title="4. 游标"></a>4. 游标</h2><h3 id="4-1-什么是游标（或光标）"><a href="#4-1-什么是游标（或光标）" class="headerlink" title="4.1 什么是游标（或光标）"></a>4.1 什么是游标（或光标）</h3><p>虽然我们也可以通过筛选条件 WHERE 和 HAVING，或者是限定返回记录的关键字 LIMIT 返回一条记录，但是，却无法在结果集中像指针一样，向前定位一条记录、向后定位一条记录，或者是<code>随意定位到某一条记录</code>，并对记录的数据进行处理。</p>
<p>这个时候，就可以用到游标。游标，提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。<strong>游标让 SQL 这种面向集合的语言有了面向过程开发的能力。</strong></p>
<p>在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标<code>充当了指针的作用</code>，我们可以通过操作游标来对数据行进行操作。</p>
<p>MySQL中游标可以在存储过程和函数中使用。</p>
<p>比如，我们查询了 employees 数据表中工资高于15000的员工都有哪些：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT employee_id,last_name,salary FROM employees</span><br><span class="line">WHERE salary &gt; 15000;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211111182656990.png"
                        alt="image-20211111182656990"
                 ></p>
<p>这里我们就可以通过游标来操作数据行，如图所示此时游标所在的行是“108”的记录，我们也可以在结果集上滚动游标，指向结果集中的任意一行。</p>
<h3 id="4-2-使用游标步骤"><a href="#4-2-使用游标步骤" class="headerlink" title="4.2 使用游标步骤"></a>4.2 使用游标步骤</h3><p>游标必须在声明处理程序之前被声明，并且变量和条件还必须在声明游标或处理程序之前被声明。</p>
<p>如果我们想要使用游标，一般需要经历四个步骤。不同的 DBMS 中，使用游标的语法可能略有不同。</p>
<p><strong>第一步，声明游标</strong></p>
<p>在MySQL中，使用DECLARE关键字来声明游标，其语法的基本形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE cursor_name CURSOR FOR select_statement; </span><br></pre></td></tr></table></figure>

<p>这个语法适用于 MySQL，SQL Server，DB2 和 MariaDB。如果是用 Oracle 或者 PostgreSQL，需要写成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE cursor_name CURSOR IS select_statement;</span><br></pre></td></tr></table></figure>

<p>要使用 SELECT 语句来获取数据结果集，而此时还没有开始遍历数据，这里 select_statement 代表的是 SELECT 语句，返回一个用于创建游标的结果集。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE cur_emp CURSOR FOR </span><br><span class="line">SELECT employee_id,salary FROM employees;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE cursor_fruit CURSOR FOR </span><br><span class="line">SELECT f_name, f_price FROM fruits ;</span><br></pre></td></tr></table></figure>

<p><strong>第二步，打开游标</strong></p>
<p>打开游标的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPEN cursor_name</span><br></pre></td></tr></table></figure>

<p>当我们定义好游标之后，如果想要使用游标，必须先打开游标。打开游标的时候 SELECT 语句的查询结果集就会送到游标工作区，为后面游标的<code>逐条读取</code>结果集中的记录做准备。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPEN　cur_emp ;</span><br></pre></td></tr></table></figure>

<p><strong>第三步，使用游标（从游标中取得数据）</strong></p>
<p>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FETCH cursor_name INTO var_name [, var_name] ...</span><br></pre></td></tr></table></figure>

<p>这句的作用是使用 cursor_name 这个游标来读取当前行，并且将数据保存到 var_name 这个变量中，游标指针指到下一行。如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可。</p>
<p>注意：var_name必须在声明游标之前就定义好。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FETCH　cur_emp INTO emp_id, emp_sal ;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>游标的查询结果集中的字段数，必须跟 INTO 后面的变量数一致</strong>，否则，在存储过程执行的时候，MySQL 会提示错误。</p>
<p><strong>第四步，关闭游标</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLOSE cursor_name</span><br></pre></td></tr></table></figure>

<p>有 OPEN 就会有 CLOSE，也就是打开和关闭游标。当我们使用完游标后需要关闭掉该游标。因为游标会<code>占用系统资源</code>，如果不及时关闭，<strong>游标会一直保持到存储过程结束</strong>，影响系统运行的效率。而关闭游标的操作，会释放游标占用的系统资源。</p>
<p>关闭游标之后，我们就不能再检索查询结果中的数据行，如果需要检索只能再次打开游标。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLOSE　cur_emp;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-举例"><a href="#4-3-举例" class="headerlink" title="4.3 举例"></a>4.3 举例</h3><p>创建存储过程“get_count_by_limit_total_salary()”，声明IN参数 limit_total_salary，DOUBLE类型；声明OUT参数total_count，INT类型。函数的功能可以实现累加薪资最高的几个员工的薪资值，直到薪资总和达到limit_total_salary参数的值，返回累加的人数给total_count。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE get_count_by_limit_total_salary(IN limit_total_salary DOUBLE,OUT total_count INT)</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE sum_salary DOUBLE DEFAULT 0;  #记录累加的总工资</span><br><span class="line">	DECLARE cursor_salary DOUBLE DEFAULT 0; #记录某一个工资值</span><br><span class="line">	DECLARE emp_count INT DEFAULT 0; #记录循环个数</span><br><span class="line">	#定义游标</span><br><span class="line">	DECLARE emp_cursor CURSOR FOR SELECT salary FROM employees ORDER BY salary DESC;</span><br><span class="line">	#打开游标</span><br><span class="line">	OPEN emp_cursor;</span><br><span class="line">	</span><br><span class="line">	REPEAT</span><br><span class="line">		#使用游标（从游标中获取数据）</span><br><span class="line">		FETCH emp_cursor INTO cursor_salary;</span><br><span class="line">		</span><br><span class="line">		SET sum_salary = sum_salary + cursor_salary;</span><br><span class="line">		SET emp_count = emp_count + 1;</span><br><span class="line">		</span><br><span class="line">		UNTIL sum_salary &gt;= limit_total_salary</span><br><span class="line">	END REPEAT;</span><br><span class="line">	</span><br><span class="line">	SET total_count = emp_count;</span><br><span class="line">	#关闭游标</span><br><span class="line">	CLOSE emp_cursor;</span><br><span class="line">	</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-小结"><a href="#4-5-小结" class="headerlink" title="4.5 小结"></a>4.5 小结</h3><p>游标是 MySQL 的一个重要的功能，为<code>逐条读取</code>结果集中的数据，提供了完美的解决方案。跟在应用层面实现相同的功能相比，游标可以在存储程序中使用，效率高，程序也更加简洁。</p>
<p>但同时也会带来一些性能问题，比如在使用游标的过程中，会对数据行进行<code>加锁</code>，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会<code>消耗系统资源</code>，造成内存不足，这是因为游标是在内存中进行的处理。</p>
<p>建议：养成用完之后就关闭的习惯，这样才能提高系统的整体效率。</p>
<h2 id="补充：MySQL-8-0的新特性—全局变量的持久化"><a href="#补充：MySQL-8-0的新特性—全局变量的持久化" class="headerlink" title="补充：MySQL 8.0的新特性—全局变量的持久化"></a>补充：MySQL 8.0的新特性—全局变量的持久化</h2><p>在MySQL数据库中，全局变量可以通过SET GLOBAL语句来设置。例如，设置服务器语句超时的限制，可以通过设置系统变量max_execution_time来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL MAX_EXECUTION_TIME=2000;</span><br></pre></td></tr></table></figure>

<p>使用SET GLOBAL语句设置的变量值只会<code>临时生效</code>。<code>数据库重启</code>后，服务器又会从MySQL配置文件中读取变量的默认值。<br>MySQL 8.0版本新增了<code>SET PERSIST</code>命令。例如，设置服务器的最大连接数为1000：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET PERSIST global max_connections = 1000;</span><br></pre></td></tr></table></figure>

<p>MySQL会将该命令的配置保存到数据目录下的<code>mysqld-auto.cnf</code>文件中，下次启动时会读取该文件，用其中的配置来覆盖默认的配置文件。</p>
<p>举例：</p>
<p>查看全局变量max_connections的值，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%max_connections%&#x27;;</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| max_connections        | 151   |</span><br><span class="line">| mysqlx_max_connections | 100   |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>设置全局变量max_connections的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; set persist max_connections=1000;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><code>重启MySQL服务器</code>，再次查询max_connections的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%max_connections%&#x27;;</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| max_connections        | 1000  |</span><br><span class="line">| mysqlx_max_connections | 100   |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>







<hr>
<h1 id="第17章-触发器"><a href="#第17章-触发器" class="headerlink" title="第17章_触发器"></a>第17章_触发器</h1><hr>
<p>在实际开发中，我们经常会遇到这样的情况：有 2 个或者多个相互关联的表，如<code>商品信息</code>和<code>库存信息</code>分别存放在 2 个不同的数据表中，我们在添加一条新商品记录的时候，为了保证数据的完整性，必须同时在库存表中添加一条库存记录。</p>
<p>这样一来，我们就必须把这两个关联的操作步骤写到程序里面，而且要用<code>事务</code>包裹起来，确保这两个操作成为一个<code>原子操作</code>，要么全部执行，要么全部不执行。要是遇到特殊情况，可能还需要对数据进行手动维护，这样就很<code>容易忘记其中的一步</code>，导致数据缺失。</p>
<p>这个时候，咱们可以使用触发器。**你可以创建一个触发器，让商品信息数据的插入操作自动触发库存数据的插入操作。**这样一来，就不用担心因为忘记添加库存数据而导致的数据缺失了。</p>
<h2 id="1-触发器概述"><a href="#1-触发器概述" class="headerlink" title="1. 触发器概述"></a>1. 触发器概述</h2><p>MySQL从<code>5.0.2</code>版本开始支持触发器。MySQL的触发器和存储过程一样，都是嵌入到MySQL服务器的一段程序。</p>
<p>触发器是由<code>事件来触发</code>某个操作，这些事件包括<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会<code>自动</code>激发触发器执行相应的操作。</p>
<p>当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。</p>
<h2 id="2-触发器的创建"><a href="#2-触发器的创建" class="headerlink" title="2. 触发器的创建"></a>2. 触发器的创建</h2><h3 id="2-1-创建触发器语法"><a href="#2-1-创建触发器语法" class="headerlink" title="2.1 创建触发器语法"></a>2.1 创建触发器语法</h3><p>创建触发器的语法结构是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER 触发器名称 </span><br><span class="line">&#123;BEFORE|AFTER&#125; &#123;INSERT|UPDATE|DELETE&#125; ON 表名 </span><br><span class="line">FOR EACH ROW </span><br><span class="line">触发器执行的语句块;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><p><code>表名</code>：表示触发器监控的对象。</p>
</li>
<li><p><code>BEFORE|AFTER</code>：表示触发的时间。BEFORE 表示在事件之前触发；AFTER 表示在事件之后触发。</p>
</li>
<li><p><code>INSERT|UPDATE|DELETE</code>：表示触发的事件。</p>
<ul>
<li>INSERT 表示插入记录时触发；</li>
<li>UPDATE 表示更新记录时触发；</li>
<li>DELETE 表示删除记录时触发。</li>
</ul>
</li>
<li><p><code>触发器执行的语句块</code>：可以是单条SQL语句，也可以是由BEGIN…END结构组成的复合语句块。</p>
</li>
</ul>
<h3 id="2-2-代码举例-1"><a href="#2-2-代码举例-1" class="headerlink" title="2.2 代码举例"></a>2.2 代码举例</h3><p><strong>举例1：</strong></p>
<p>1、创建数据表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE test_trigger (</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">t_note VARCHAR(30)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE test_trigger_log (</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">t_log VARCHAR(30)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>2、创建触发器：创建名称为before_insert的触发器，向test_trigger数据表插入数据之前，向test_trigger_log数据表中插入before_insert的日志信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER before_insert</span><br><span class="line">BEFORE INSERT ON test_trigger </span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">	INSERT INTO test_trigger_log (t_log)</span><br><span class="line">	VALUES(&#x27;before_insert&#x27;);</span><br><span class="line"></span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>3、向test_trigger数据表中插入数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_trigger (t_note) VALUES (&#x27;测试 BEFORE INSERT 触发器&#x27;);</span><br></pre></td></tr></table></figure>

<p>4、查看test_trigger_log数据表中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test_trigger_log;</span><br><span class="line">+----+---------------+</span><br><span class="line">| id | t_log         |</span><br><span class="line">+----+---------------+</span><br><span class="line">|  1 | before_insert |</span><br><span class="line">+----+---------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>举例2：</strong></p>
<p>1、创建名称为after_insert的触发器，向test_trigger数据表插入数据之后，向test_trigger_log数据表中插入after_insert的日志信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER after_insert</span><br><span class="line">AFTER INSERT ON test_trigger</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">	INSERT INTO test_trigger_log (t_log)</span><br><span class="line">	VALUES(&#x27;after_insert&#x27;);</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>2、向test_trigger数据表中插入数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO test_trigger (t_note) VALUES (&#x27;测试 AFTER INSERT 触发器&#x27;);</span><br></pre></td></tr></table></figure>

<p>3、查看test_trigger_log数据表中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM test_trigger_log;</span><br><span class="line">+----+---------------+</span><br><span class="line">| id | t_log         |</span><br><span class="line">+----+---------------+</span><br><span class="line">|  1 | before_insert |</span><br><span class="line">|  2 | before_insert |</span><br><span class="line">|  3 | after_insert  |</span><br><span class="line">+----+---------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>**举例3：**定义触发器“salary_check_trigger”，基于员工表“employees”的INSERT事件，在INSERT之前检查将要添加的新员工薪资是否大于他领导的薪资，如果大于领导薪资，则报sqlstate_value为’HY000’的错误，从而使得添加失败。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line"></span><br><span class="line">CREATE TRIGGER salary_check_trigger</span><br><span class="line">BEFORE INSERT ON employees FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE mgrsalary DOUBLE;</span><br><span class="line">	SELECT salary INTO mgrsalary FROM employees WHERE employee_id = NEW.manager_id;</span><br><span class="line"></span><br><span class="line">	IF NEW.salary &gt; mgrsalary THEN</span><br><span class="line">		SIGNAL SQLSTATE &#x27;HY000&#x27; SET MESSAGE_TEXT = &#x27;薪资高于领导薪资错误&#x27;;</span><br><span class="line">	END IF;</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>上面触发器声明过程中的NEW关键字代表INSERT添加语句的新记录。</p>
<h2 id="3-查看、删除触发器"><a href="#3-查看、删除触发器" class="headerlink" title="3. 查看、删除触发器"></a>3. 查看、删除触发器</h2><h3 id="3-1-查看触发器"><a href="#3-1-查看触发器" class="headerlink" title="3.1 查看触发器"></a>3.1 查看触发器</h3><p>查看触发器是查看数据库中已经存在的触发器的定义、状态和语法信息等。</p>
<p>方式1：查看当前数据库的所有触发器的定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TRIGGERS\G</span><br></pre></td></tr></table></figure>

<p>方式2：查看当前数据库中某个触发器的定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE TRIGGER 触发器名</span><br></pre></td></tr></table></figure>

<p>方式3：从系统库information_schema的TRIGGERS表中查询“salary_check_trigger”触发器的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM information_schema.TRIGGERS;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-删除触发器"><a href="#3-2-删除触发器" class="headerlink" title="3.2 删除触发器"></a>3.2 删除触发器</h3><p>触发器也是数据库对象，删除触发器也用DROP语句，语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TRIGGER  IF EXISTS 触发器名称;</span><br></pre></td></tr></table></figure>



<h2 id="4-触发器的优缺点"><a href="#4-触发器的优缺点" class="headerlink" title="4. 触发器的优缺点"></a>4. 触发器的优缺点</h2><h3 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1 优点"></a>4.1 优点</h3><p><strong>1、触发器可以确保数据的完整性</strong>。</p>
<p>假设我们用<code>进货单头表</code>（demo.importhead）来保存进货单的总体信息，包括进货单编号、供货商编号、仓库编号、总计进货数量、总计进货金额和验收日期。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211010233336012.png"
                        alt="image-20211010233336012"
                 ></p>
<p>用<code>进货单明细表</code>（demo.importdetails）来保存进货商品的明细，包括进货单编号、商品编号、进货数量、进货价格和进货金额。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211010233344125.png"
                        alt="image-20211010233344125"
                 ></p>
<p>每当我们录入、删除和修改一条进货单明细数据的时候，进货单明细表里的数据就会发生变动。这个时候，在进货单头表中的总计数量和总计金额就必须重新计算，否则，进货单头表中的总计数量和总计金额就不等于进货单明细表中数量合计和金额合计了，这就是数据不一致。</p>
<p>为了解决这个问题，我们就可以使用触发器，<strong>规定每当进货单明细表有数据插入、修改和删除的操作时，自动触发 2 步操作：</strong></p>
<p>1）重新计算进货单明细表中的数量合计和金额合计；</p>
<p>2）用第一步中计算出来的值更新进货单头表中的合计数量与合计金额。</p>
<p>这样一来，进货单头表中的合计数量与合计金额的值，就始终与进货单明细表中计算出来的合计数量与合计金额的值相同，数据就是一致的，不会互相矛盾。</p>
<p><strong>2、触发器可以帮助我们记录操作日志。</strong></p>
<p>利用触发器，可以具体记录什么时间发生了什么。比如，记录修改会员储值金额的触发器，就是一个很好的例子。这对我们还原操作执行时的具体场景，更好地定位问题原因很有帮助。</p>
<p><strong>3、触发器还可以用在操作数据前，对数据进行合法性检查。</strong></p>
<p>比如，超市进货的时候，需要库管录入进货价格。但是，人为操作很容易犯错误，比如说在录入数量的时候，把条形码扫进去了；录入金额的时候，看串了行，录入的价格远超售价，导致账面上的巨亏……这些都可以通过触发器，在实际插入或者更新操作之前，对相应的数据进行检查，及时提示错误，防止错误数据进入系统。</p>
<h3 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2 缺点"></a>4.2 缺点</h3><p><strong>1、触发器最大的一个问题就是可读性差。</strong></p>
<p>因为触发器存储在数据库中，并且由事件驱动，这就意味着触发器有可能<code>不受应用层的控制</code>。这对系统维护是非常有挑战的。</p>
<p>比如，创建触发器用于修改会员储值操作。如果触发器中的操作出了问题，会导致会员储值金额更新失败。我用下面的代码演示一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; update demo.membermaster set memberdeposit=20 where memberid = 2;</span><br><span class="line">ERROR 1054 (42S22): Unknown column &#x27;aa&#x27; in &#x27;field list&#x27;</span><br></pre></td></tr></table></figure>

<p>结果显示，系统提示错误，字段“aa”不存在。</p>
<p>这是因为，触发器中的数据插入操作多了一个字段，系统提示错误。可是，如果你不了解这个触发器，很可能会认为是更新语句本身的问题，或者是会员信息表的结构出了问题。说不定你还会给会员信息表添加一个叫“aa”的字段，试图解决这个问题，结果只能是白费力。</p>
<p><strong>2、相关数据的变更，可能会导致触发器出错。</strong></p>
<p>特别是数据表结构的变更，都可能会导致触发器出错，进而影响数据操作的正常运行。这些都会由于触发器本身的隐蔽性，影响到应用中错误原因排查的效率。</p>
<h3 id="4-3-注意点"><a href="#4-3-注意点" class="headerlink" title="4.3 注意点"></a>4.3 注意点</h3><p>注意，如果在子表中定义了外键约束，并且外键指定了ON UPDATE&#x2F;DELETE CASCADE&#x2F;SET NULL子句，此时修改父表被引用的键值或删除父表被引用的记录行时，也会引起子表的修改和删除操作，此时基于子表的UPDATE和DELETE语句定义的触发器并不会被激活。</p>
<p>例如：基于子表员工表（t_employee）的DELETE语句定义了触发器t1，而子表的部门编号（did）字段定义了外键约束引用了父表部门表（t_department）的主键列部门编号（did），并且该外键加了“ON DELETE SET NULL”子句，那么如果此时删除父表部门表（t_department）在子表员工表（t_employee）有匹配记录的部门记录时，会引起子表员工表（t_employee）匹配记录的部门编号（did）修改为NULL，但是此时不会激活触发器t1。只有直接对子表员工表（t_employee）执行DELETE语句时才会激活触发器t1。</p>
<hr>
<h1 id="第18章-MySQL8其它新特性"><a href="#第18章-MySQL8其它新特性" class="headerlink" title="第18章_MySQL8其它新特性"></a>第18章_MySQL8其它新特性</h1><hr>
<h2 id="1-MySQL8新特性概述"><a href="#1-MySQL8新特性概述" class="headerlink" title="1. MySQL8新特性概述"></a>1. MySQL8新特性概述</h2><p><code>MySQL从5.7版本直接跳跃发布了8.0版本</code>，可见这是一个令人兴奋的里程碑版本。MySQL 8版本在功能上做了显著的改进与增强，开发者对MySQL的源代码进行了重构，最突出的一点是多MySQL Optimizer优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。</p>
<h3 id="1-1-MySQL8-0-新增特性"><a href="#1-1-MySQL8-0-新增特性" class="headerlink" title="1.1 MySQL8.0 新增特性"></a>1.1 MySQL8.0 新增特性</h3><p><strong>1. 更简便的NoSQL支持</strong><br>NoSQL泛指非关系型数据库和数据存储。随着互联网平台的规模飞速发展，传统的关系型数据库已经越来越不能满足需求。从5.6版本开始，MySQL就开始支持简单的NoSQL存储功能。MySQL 8对这一功能做了优化，以更灵活的方式实现NoSQL功能，不再依赖模式（schema）。</p>
<p><strong>2. 更好的索引</strong><br>在查询中，正确地使用索引可以提高查询的效率。MySQL 8中新增了<code>隐藏索引</code>和<code>降序索引</code>。隐藏索引可以用来测试去掉索引对查询性能的影响。在查询中混合存在多列索引时，使用降序索引可以提高查询的性能。</p>
<p><strong>3.更完善的JSON支持</strong><br>MySQL从5.7开始支持原生JSON数据的存储，MySQL 8对这一功能做了优化，增加了聚合函数<code>JSON_ARRAYAGG()</code>和<code>JSON_OBJECTAGG()</code>，将参数聚合为JSON数组或对象，新增了行内操作符 -&gt;&gt;，是列路径运算符 -&gt;的增强，对JSON排序做了提升，并优化了JSON的更新操作。</p>
<p><strong>4.安全和账户管理</strong><br>MySQL 8中新增了<code>caching_sha2_password</code> 授权插件、角色、密码历史记录和FIPS模式支持，这些特性提高了数据库的安全性和性能，使数据库管理员能够更灵活地进行账户管理工作。</p>
<p><strong>5.InnoDB的变化</strong><br><code>InnoDB是MySQL默认的存储引擎</code>，是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。在MySQL 8 版本中，InnoDB在自增、索引、加密、死锁、共享锁等方面做了大量的<code>改进和优化</code>，并且支持原子数据定义语言（DDL），提高了数据安全性，对事务提供更好的支持。</p>
<p><strong>6.数据字典</strong><br>在之前的MySQL版本中，字典数据都存储在元数据文件和非事务表中。从MySQL 8开始新增了事务数据字典，在这个字典里存储着数据库对象信息，这些数据字典存储在内部事务表中。</p>
<p><strong>7. 原子数据定义语句</strong><br>MySQL 8开始支持原子数据定义语句（Automic DDL），即<code>原子DDL</code>。目前，只有InnoDB存储引擎支持原子DDL。原子数据定义语句（DDL）将与DDL操作相关的数据字典更新、存储引擎操作、二进制日志写入结合到一个单独的原子事务中，这使得即使服务器崩溃，事务也会提交或回滚。<br>使用支持原子操作的存储引擎所创建的表，在执行DROP TABLE、CREATE TABLE、ALTER TABLE、 RENAME TABLE、TRUNCATE TABLE、CREATE TABLESPACE、DROP TABLESPACE等操作时，都支持原子操作，即事务要么完全操作成功，要么失败后回滚，不再进行部分提交。<br>对于从MySQL 5.7复制到MySQL 8 版本中的语句，可以添加<code>IF EXISTS</code>或<code>IF NOT EXISTS</code>语句来避免发生错误。</p>
<p><strong>8.资源管理</strong><br>MySQL 8开始支持创建和管理资源组，允许将服务器内运行的线程分配给特定的分组，以便线程根据组内可用资源执行。组属性能够控制组内资源，启用或限制组内资源消耗。数据库管理员能够根据不同的工作负载适当地更改这些属性。<br>目前，CPU时间是可控资源，由“虚拟CPU”这个概念来表示，此术语包含CPU的核心数，超线程，硬件线程等等。服务器在启动时确定可用的虚拟CPU数量。拥有对应权限的数据库管理员可以将这些CPU与资源组关联，并为资源组分配线程。<br>资源组组件为MySQL中的资源组管理提供了SQL接口。资源组的属性用于定义资源组。MySQL中存在两个默认组，系统组和用户组，默认的组不能被删除，其属性也不能被更改。对于用户自定义的组，资源组创建时可初始化所有的属性，除去名字和类型，其他属性都可在创建之后进行更改。<br>在一些平台下，或进行了某些MySQL的配置时，资源管理的功能将受到限制，甚至不可用。例如，如果安装了线程池插件，或者使用的是macOS系统，资源管理将处于不可用状态。在FreeBSD和Solaris系统中，资源线程优先级将失效。在Linux系统中，只有配置了CAP_SYS_NICE属性，资源管理优先级才能发挥作用。</p>
<p><strong>9.字符集支持</strong><br>MySQL 8中默认的字符集由<code>latin1</code>更改为<code>utf8mb4</code>，并首次增加了日语所特定使用的集合，utf8mb4_ja_0900_as_cs。</p>
<p><strong>10.优化器增强</strong><br>MySQL优化器开始支持隐藏索引和降序索引。隐藏索引不会被优化器使用，验证索引的必要性时不需要删除索引，先将索引隐藏，如果优化器性能无影响就可以真正地删除索引。降序索引允许优化器对多个列进行排序，并且允许排序顺序不一致。</p>
<p><strong>11.公用表表达式</strong><br>公用表表达式（Common Table Expressions）简称为CTE，MySQL现在支持递归和非递归两种形式的CTE。CTE通过在SELECT语句或其他特定语句前<code>使用WITH语句对临时结果集</code>进行命名。</p>
<p>基础语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WITH cte_name (col_name1,col_name2 ...) AS (Subquery)</span><br><span class="line">SELECT * FROM cte_name;</span><br></pre></td></tr></table></figure>

<p>Subquery代表子查询，子查询前使用WITH语句将结果集命名为cte_name，在后续的查询中即可使用cte_name进行查询。</p>
<p><strong>12.窗口函数</strong><br>MySQL 8开始支持窗口函数。在之前的版本中已存在的大部分<code>聚合函数</code>在MySQL 8中也可以作为窗口函数来使用。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20210730165317542.png"
                        alt="image-20210730165317542"
                 ></p>
<p><strong>13.正则表达式支持</strong><br>MySQL在8.0.4以后的版本中采用支持Unicode的国际化组件库实现正则表达式操作，这种方式不仅能提供完全的Unicode支持，而且是多字节安全编码。MySQL增加了REGEXP_LIKE()、EGEXP_INSTR()、REGEXP_REPLACE()和 REGEXP_SUBSTR()等函数来提升性能。另外，regexp_stack_limit和regexp_time_limit 系统变量能够通过匹配引擎来控制资源消耗。</p>
<p><strong>14.内部临时表</strong><br><code>TempTable存储引擎取代MEMORY存储引擎成为内部临时表的默认存储引擎</code>。TempTable存储引擎为VARCHAR和VARBINARY列提供高效存储。internal_tmp_mem_storage_engine会话变量定义了内部临时表的存储引擎，可选的值有两个，TempTable和MEMORY，其中TempTable为默认的存储引擎。temptable_max_ram系统配置项定义了TempTable存储引擎可使用的最大内存数量。</p>
<p><strong>15.日志记录</strong><br>在MySQL 8中错误日志子系统由一系列MySQL组件构成。这些组件的构成由系统变量log_error_services来配置，能够实现日志事件的过滤和写入。</p>
<p><strong>16.备份锁</strong><br>新的备份锁允许在线备份期间执行数据操作语句，同时阻止可能造成快照不一致的操作。新备份锁由 LOCK INSTANCE FOR BACKUP 和 UNLOCK INSTANCE 语法提供支持，执行这些操作需要备份管理员特权。</p>
<p><strong>17.增强的MySQL复制</strong><br>MySQL 8复制支持对<code>JSON文档</code>进行部分更新的<code>二进制日志记录</code>，该记录<code>使用紧凑的二进制格式</code>，从而节省记录完整JSON文档的空间。当使用基于语句的日志记录时，这种紧凑的日志记录会自动完成，并且可以通过将新的binlog_row_value_options系统变量值设置为PARTIAL_JSON来启用。</p>
<h3 id="1-2-MySQL8-0移除的旧特性"><a href="#1-2-MySQL8-0移除的旧特性" class="headerlink" title="1.2 MySQL8.0移除的旧特性"></a>1.2 MySQL8.0移除的旧特性</h3><p>在MySQL 5.7版本上开发的应用程序如果使用了MySQL8.0 移除的特性，语句可能会失败，或者产生不同的执行结果。为了避免这些问题，对于使用了移除特性的应用，应当尽力修正避免使用这些特性，并尽可能使用替代方法。</p>
<p><strong>1. 查询缓存</strong><br><code>查询缓存已被移除</code>，删除的项有：<br>**（1）语句：**FLUSH QUERY CACHE和RESET QUERY CACHE。<br>**（2）系统变量：**query_cache_limit、query_cache_min_res_unit、query_cache_size、query_cache_type、query_cache_wlock_invalidate。<br>**（3）状态变量：**Qcache_free_blocks、Qcache_free_memory、Qcache_hits、Qcache_inserts、Qcache_lowmem_prunes、Qcache_not_cached、Qcache_queries_in_cache、Qcache_total_blocks。<br>**（4）线程状态：**checking privileges on cached query、checking query cache for query、invalidating query cache entries、sending cached result to client、storing result in query cache、waiting for query cache lock。</p>
<p><strong>2.加密相关</strong><br>删除的加密相关的内容有：ENCODE()、DECODE()、ENCRYPT()、DES_ENCRYPT()和DES_DECRYPT()函数，配置项des-key-file，系统变量have_crypt，FLUSH语句的DES_KEY_FILE选项，HAVE_CRYPT CMake选项。<br>对于移除的ENCRYPT()函数，考虑使用SHA2()替代，对于其他移除的函数，使用AES_ENCRYPT()和AES_DECRYPT()替代。</p>
<p><strong>3.空间函数相关</strong><br>在MySQL 5.7版本中，多个空间函数已被标记为过时。这些过时函数在MySQL 8中都已被移除，只保留了对应的ST_和MBR函数。</p>
<p><strong>4.\N和NULL</strong><br>在SQL语句中，解析器不再将\N视为NULL，所以在SQL语句中应使用NULL代替\N。这项变化不会影响使用LOAD DATA INFILE或者SELECT…INTO OUTFILE操作文件的导入和导出。在这类操作中，NULL仍等同于\N。</p>
<p><strong>5. mysql_install_db</strong><br>在MySQL分布中，已移除了mysql_install_db程序，数据字典初始化需要调用带着–initialize或者–initialize-insecure选项的mysqld来代替实现。另外，–bootstrap和INSTALL_SCRIPTDIR CMake也已被删除。</p>
<p><strong>6.通用分区处理程序</strong><br>通用分区处理程序已从MySQL服务中被移除。为了实现给定表分区，表所使用的存储引擎需要自有的分区处理程序。<br>提供本地分区支持的MySQL存储引擎有两个，即InnoDB和NDB，而在MySQL 8中只支持InnoDB。</p>
<p><strong>7.系统和状态变量信息</strong><br>在INFORMATION_SCHEMA数据库中，对系统和状态变量信息不再进行维护。GLOBAL_VARIABLES、SESSION_VARIABLES、GLOBAL_STATUS、SESSION_STATUS表都已被删除。另外，系统变量show_compatibility_56也已被删除。被删除的状态变量有Slave_heartbeat_period、Slave_last_heartbeat,Slave_received_heartbeats、Slave_retried_transactions、Slave_running。以上被删除的内容都可使用性能模式中对应的内容进行替代。</p>
<p><strong>8.mysql_plugin工具</strong><br>mysql_plugin工具用来配置MySQL服务器插件，现已被删除，可使用–plugin-load或–plugin-load-add选项在服务器启动时加载插件或者在运行时使用INSTALL PLUGIN语句加载插件来替代该工具。</p>
<h2 id="2-新特性1：窗口函数"><a href="#2-新特性1：窗口函数" class="headerlink" title="2. 新特性1：窗口函数"></a>2. 新特性1：窗口函数</h2><h3 id="2-1-使用窗口函数前后对比"><a href="#2-1-使用窗口函数前后对比" class="headerlink" title="2.1 使用窗口函数前后对比"></a>2.1 使用窗口函数前后对比</h3><p>假设我现在有这样一个数据表，它显示了某购物网站在每个城市每个区的销售额：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE sales(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">city VARCHAR(15),</span><br><span class="line">county VARCHAR(15),</span><br><span class="line">sales_value DECIMAL</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO sales(city,county,sales_value)</span><br><span class="line">VALUES</span><br><span class="line">(&#x27;北京&#x27;,&#x27;海淀&#x27;,10.00),</span><br><span class="line">(&#x27;北京&#x27;,&#x27;朝阳&#x27;,20.00),</span><br><span class="line">(&#x27;上海&#x27;,&#x27;黄埔&#x27;,30.00),</span><br><span class="line">(&#x27;上海&#x27;,&#x27;长宁&#x27;,10.00);</span><br></pre></td></tr></table></figure>

<p>查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM sales;</span><br><span class="line">+----+------+--------+-------------+</span><br><span class="line">| id | city | county | sales_value |</span><br><span class="line">+----+------+--------+-------------+</span><br><span class="line">|  1 | 北京 | 海淀    |          10 |</span><br><span class="line">|  2 | 北京 | 朝阳    |          20 |</span><br><span class="line">|  3 | 上海 | 黄埔    |          30 |</span><br><span class="line">|  4 | 上海 | 长宁    |          10 |</span><br><span class="line">+----+------+--------+-------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>**需求：**现在计算这个网站在每个城市的销售总额、在全国的销售总额、每个区的销售额占所在城市销售额中的比率，以及占总销售额中的比率。</p>
<p>如果用分组和聚合函数，就需要分好几步来计算。</p>
<p>第一步，计算总销售金额，并存入临时表 a：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TEMPORARY TABLE a       -- 创建临时表</span><br><span class="line">SELECT SUM(sales_value) AS sales_value -- 计算总计金额</span><br><span class="line">FROM sales;</span><br></pre></td></tr></table></figure>

<p>查看一下临时表 a ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM a;</span><br><span class="line">+-------------+</span><br><span class="line">| sales_value |</span><br><span class="line">+-------------+</span><br><span class="line">|          70 |</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>第二步，计算每个城市的销售总额并存入临时表 b：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TEMPORARY TABLE b    -- 创建临时表</span><br><span class="line">SELECT city,SUM(sales_value) AS sales_value  -- 计算城市销售合计</span><br><span class="line">FROM sales</span><br><span class="line">GROUP BY city;</span><br></pre></td></tr></table></figure>

<p>查看临时表 b ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM b;</span><br><span class="line">+------+-------------+</span><br><span class="line">| city | sales_value |</span><br><span class="line">+------+-------------+</span><br><span class="line">| 北京 |          30 |</span><br><span class="line">| 上海 |          40 |</span><br><span class="line">+------+-------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>第三步，计算各区的销售占所在城市的总计金额的比例，和占全部销售总计金额的比例。我们可以通过下面的连接查询获得需要的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT s.city AS 城市,s.county AS 区,s.sales_value AS 区销售额,</span><br><span class="line">    -&gt; b.sales_value AS 市销售额,s.sales_value/b.sales_value AS 市比率,</span><br><span class="line">    -&gt; a.sales_value AS 总销售额,s.sales_value/a.sales_value AS 总比率</span><br><span class="line">    -&gt; FROM sales s</span><br><span class="line">    -&gt; JOIN b ON (s.city=b.city) -- 连接市统计结果临时表</span><br><span class="line">    -&gt; JOIN a                   -- 连接总计金额临时表</span><br><span class="line">    -&gt; ORDER BY s.city,s.county;</span><br><span class="line">+------+------+----------+----------+--------+----------+--------+</span><br><span class="line">| 城市  | 区   | 区销售额  | 市销售额   | 市比率  | 总销售额  | 总比率  |</span><br><span class="line">+------+------+----------+----------+--------+----------+--------+</span><br><span class="line">| 上海  | 长宁 |       10 |       40 | 0.2500 |       70 | 0.1429 |</span><br><span class="line">| 上海  | 黄埔 |       30 |       40 | 0.7500 |       70 | 0.4286 |</span><br><span class="line">| 北京  | 朝阳 |       20 |       30 | 0.6667 |       70 | 0.2857 |</span><br><span class="line">| 北京  | 海淀 |       10 |       30 | 0.3333 |       70 | 0.1429 |</span><br><span class="line">+------+------+----------+----------+--------+----------+--------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>结果显示：市销售金额、市销售占比、总销售金额、总销售占比都计算出来了。</p>
<p>同样的查询，如果用窗口函数，就简单多了。我们可以用下面的代码来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT city AS 城市,county AS 区,sales_value AS 区销售额,</span><br><span class="line">    -&gt; SUM(sales_value) OVER(PARTITION BY city) AS 市销售额,  -- 计算市销售额</span><br><span class="line">    -&gt; sales_value/SUM(sales_value) OVER(PARTITION BY city) AS 市比率,</span><br><span class="line">    -&gt; SUM(sales_value) OVER() AS 总销售额,   -- 计算总销售额</span><br><span class="line">    -&gt; sales_value/SUM(sales_value) OVER() AS 总比率</span><br><span class="line">    -&gt; FROM sales</span><br><span class="line">    -&gt; ORDER BY city,county;</span><br><span class="line">+------+------+----------+----------+--------+----------+--------+</span><br><span class="line">| 城市  | 区   | 区销售额  | 市销售额   | 市比率  | 总销售额  | 总比率  |</span><br><span class="line">+------+------+----------+----------+--------+----------+--------+</span><br><span class="line">| 上海  | 长宁 |       10 |       40  | 0.2500 |       70 | 0.1429 |</span><br><span class="line">| 上海  | 黄埔 |       30 |       40  | 0.7500 |       70 | 0.4286 |</span><br><span class="line">| 北京  | 朝阳 |       20 |       30  | 0.6667 |       70 | 0.2857 |</span><br><span class="line">| 北京  | 海淀 |       10 |       30  | 0.3333 |       70 | 0.1429 |</span><br><span class="line">+------+------+----------+-----------+--------+----------+--------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>结果显示，我们得到了与上面那种查询同样的结果。</p>
<p>使用窗口函数，只用了一步就完成了查询。而且，由于没有用到临时表，执行的效率也更高了。很显然，<strong>在这种需要用到分组统计的结果对每一条记录进行计算的场景下，使用窗口函数更好</strong>。</p>
<h3 id="2-2-窗口函数分类"><a href="#2-2-窗口函数分类" class="headerlink" title="2.2 窗口函数分类"></a>2.2 窗口函数分类</h3><p>MySQL从8.0版本开始支持窗口函数。窗口函数的作用类似于在查询中对数据进行分组，不同的是，分组操作会把分组的结果聚合成一条记录，而窗口函数是将结果置于每一条数据记录中。</p>
<p>窗口函数可以分为<code>静态窗口函数</code>和<code>动态窗口函数</code>。</p>
<ul>
<li>静态窗口函数的窗口大小是固定的，不会因为记录的不同而不同；</li>
<li>动态窗口函数的窗口大小会随着记录的不同而变化。</li>
</ul>
<p>MySQL官方网站窗口函数的网址为<a class="link"   href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_row-number%E3%80%82" >https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_row-number。<i class="fas fa-external-link-alt"></i></a></p>
<p>窗口函数总体上可以分为序号函数、分布函数、前后函数、首尾函数和其他函数，如下表：</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/30/MySQL/image-20211012162944536.png"
                        alt="image-20211012162944536"
                 ></p>
<h3 id="2-3-语法结构"><a href="#2-3-语法结构" class="headerlink" title="2.3 语法结构"></a>2.3 语法结构</h3><p>窗口函数的语法结构是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数 OVER（[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]）</span><br></pre></td></tr></table></figure>

<p>或者是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数 OVER 窗口名 … WINDOW 窗口名 AS （[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]）</span><br></pre></td></tr></table></figure>

<ul>
<li>OVER 关键字指定函数窗口的范围。<ul>
<li>如果省略后面括号中的内容，则窗口会包含满足WHERE条件的所有记录，窗口函数会基于所有满足WHERE条件的记录进行计算。</li>
<li>如果OVER关键字后面的括号不为空，则可以使用如下语法设置窗口。</li>
</ul>
</li>
<li>窗口名：为窗口设置一个别名，用来标识窗口。</li>
<li>PARTITION BY子句：指定窗口函数按照哪些字段进行分组。分组后，窗口函数可以在每个分组中分别执行。</li>
<li>ORDER BY子句：指定窗口函数按照哪些字段进行排序。执行排序操作使窗口函数按照排序后的数据记录的顺序进行编号。</li>
<li>FRAME子句：为分区中的某个子集定义规则，可以用来作为滑动窗口使用。</li>
</ul>
<h3 id="2-4-分类讲解"><a href="#2-4-分类讲解" class="headerlink" title="2.4 分类讲解"></a>2.4 分类讲解</h3><p>创建表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE goods(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">category_id INT,</span><br><span class="line">category VARCHAR(15),</span><br><span class="line">NAME VARCHAR(30),</span><br><span class="line">price DECIMAL(10,2),</span><br><span class="line">stock INT,</span><br><span class="line">upper_time DATETIME</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>添加数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO goods(category_id,category,NAME,price,stock,upper_time)</span><br><span class="line">VALUES</span><br><span class="line">(1, &#x27;女装/女士精品&#x27;, &#x27;T恤&#x27;, 39.90, 1000, &#x27;2020-11-10 00:00:00&#x27;),</span><br><span class="line">(1, &#x27;女装/女士精品&#x27;, &#x27;连衣裙&#x27;, 79.90, 2500, &#x27;2020-11-10 00:00:00&#x27;),</span><br><span class="line">(1, &#x27;女装/女士精品&#x27;, &#x27;卫衣&#x27;, 89.90, 1500, &#x27;2020-11-10 00:00:00&#x27;),</span><br><span class="line">(1, &#x27;女装/女士精品&#x27;, &#x27;牛仔裤&#x27;, 89.90, 3500, &#x27;2020-11-10 00:00:00&#x27;),</span><br><span class="line">(1, &#x27;女装/女士精品&#x27;, &#x27;百褶裙&#x27;, 29.90, 500, &#x27;2020-11-10 00:00:00&#x27;),</span><br><span class="line">(1, &#x27;女装/女士精品&#x27;, &#x27;呢绒外套&#x27;, 399.90, 1200, &#x27;2020-11-10 00:00:00&#x27;),</span><br><span class="line">(2, &#x27;户外运动&#x27;, &#x27;自行车&#x27;, 399.90, 1000, &#x27;2020-11-10 00:00:00&#x27;),</span><br><span class="line">(2, &#x27;户外运动&#x27;, &#x27;山地自行车&#x27;, 1399.90, 2500, &#x27;2020-11-10 00:00:00&#x27;),</span><br><span class="line">(2, &#x27;户外运动&#x27;, &#x27;登山杖&#x27;, 59.90, 1500, &#x27;2020-11-10 00:00:00&#x27;),</span><br><span class="line">(2, &#x27;户外运动&#x27;, &#x27;骑行装备&#x27;, 399.90, 3500, &#x27;2020-11-10 00:00:00&#x27;),</span><br><span class="line">(2, &#x27;户外运动&#x27;, &#x27;运动外套&#x27;, 799.90, 500, &#x27;2020-11-10 00:00:00&#x27;),</span><br><span class="line">(2, &#x27;户外运动&#x27;, &#x27;滑板&#x27;, 499.90, 1200, &#x27;2020-11-10 00:00:00&#x27;);</span><br></pre></td></tr></table></figure>

<p>下面针对goods表中的数据来验证每个窗口函数的功能。</p>
<h4 id="1-序号函数"><a href="#1-序号函数" class="headerlink" title="1. 序号函数"></a>1. 序号函数</h4><p><strong>1．ROW_NUMBER()函数</strong></p>
<p>ROW_NUMBER()函数能够对数据中的序号进行顺序显示。</p>
<p>举例：查询 goods 数据表中每个商品分类下价格降序排列的各个商品信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT ROW_NUMBER() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,</span><br><span class="line">    -&gt; id, category_id, category, NAME, price, stock</span><br><span class="line">    -&gt; FROM goods;</span><br><span class="line">+---------+----+-------------+---------------+------------+---------+-------+</span><br><span class="line">| row_num | id | category_id | category      | NAME       | price   | stock |</span><br><span class="line">+---------+----+-------------+---------------+------------+---------+-------+</span><br><span class="line">|       1 |  6 |           1 | 女装/女士精品   | 呢绒外套    |  399.90 |  1200 |</span><br><span class="line">|       2 |  3 |           1 | 女装/女士精品   | 卫衣        |   89.90 |  1500 |</span><br><span class="line">|       3 |  4 |           1 | 女装/女士精品   | 牛仔裤      |   89.90 |  3500 |</span><br><span class="line">|       4 |  2 |           1 | 女装/女士精品   | 连衣裙      |   79.90 |  2500 |</span><br><span class="line">|       5 |  1 |           1 | 女装/女士精品   | T恤        |   39.90 |  1000 |</span><br><span class="line">|       6 |  5 |           1 | 女装/女士精品   | 百褶裙      |   29.90 |   500 |</span><br><span class="line">|       1 |  8 |           2 | 户外运动       | 山地自行车   | 1399.90 |  2500 |</span><br><span class="line">|       2 | 11 |           2 | 户外运动       | 运动外套     |  799.90 |   500 |</span><br><span class="line">|       3 | 12 |           2 | 户外运动       | 滑板        |  499.90 |  1200 |</span><br><span class="line">|       4 |  7 |           2 | 户外运动       | 自行车      |  399.90 |  1000 |</span><br><span class="line">|       5 | 10 |           2 | 户外运动       | 骑行装备    |  399.90 |  3500 |</span><br><span class="line">|       6 |  9 |           2 | 户外运动       | 登山杖      |   59.90 |  1500 |</span><br><span class="line">+---------+----+-------------+---------------+------------+---------+-------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>举例：查询 goods 数据表中每个商品分类下价格最高的3种商品信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT *</span><br><span class="line">    -&gt; FROM (</span><br><span class="line">    -&gt;  SELECT ROW_NUMBER() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,</span><br><span class="line">    -&gt;  id, category_id, category, NAME, price, stock</span><br><span class="line">    -&gt;  FROM goods) t</span><br><span class="line">    -&gt; WHERE row_num &lt;= 3;</span><br><span class="line">+---------+----+-------------+---------------+------------+---------+-------+</span><br><span class="line">| row_num | id | category_id | category      | NAME       | price   | stock |</span><br><span class="line">+---------+----+-------------+---------------+------------+---------+-------+</span><br><span class="line">|       1 |  6 |           1 | 女装/女士精品   | 呢绒外套    |  399.90  |  1200 |</span><br><span class="line">|       2 |  3 |           1 | 女装/女士精品   | 卫衣        |   89.90 |  1500 |</span><br><span class="line">|       3 |  4 |           1 | 女装/女士精品   | 牛仔裤      |   89.90  |  3500 |</span><br><span class="line">|       1 |  8 |           2 | 户外运动       | 山地自行车   | 1399.90  |  2500 |</span><br><span class="line">|       2 | 11 |           2 | 户外运动       | 运动外套     |  799.90  |   500 |</span><br><span class="line">|       3 | 12 |           2 | 户外运动       | 滑板        |  499.90  |  1200 |</span><br><span class="line">+---------+----+-------------+---------------+------------+----------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>在名称为“女装&#x2F;女士精品”的商品类别中，有两款商品的价格为89.90元，分别是卫衣和牛仔裤。两款商品的序号都应该为2，而不是一个为2，另一个为3。此时，可以使用RANK()函数和DENSE_RANK()函数解决。</p>
<p><strong>2．RANK()函数</strong></p>
<p>使用RANK()函数能够对序号进行并列排序，并且会跳过重复的序号，比如序号为1、1、3。</p>
<p>举例：使用RANK()函数获取 goods 数据表中各类别的价格从高到低排序的各商品信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT RANK() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,</span><br><span class="line">    -&gt; id, category_id, category, NAME, price, stock</span><br><span class="line">    -&gt; FROM goods;</span><br><span class="line">+---------+----+-------------+---------------+------------+---------+-------+</span><br><span class="line">| row_num | id | category_id | category      | NAME       | price   | stock |</span><br><span class="line">+---------+----+-------------+---------------+------------+---------+-------+</span><br><span class="line">|       1 |  6 |           1 | 女装/女士精品   | 呢绒外套    |  399.90 |  1200 |</span><br><span class="line">|       2 |  3 |           1 | 女装/女士精品   | 卫衣        |   89.90 |  1500 |</span><br><span class="line">|       2 |  4 |           1 | 女装/女士精品   | 牛仔裤      |   89.90 |  3500 |</span><br><span class="line">|       4 |  2 |           1 | 女装/女士精品   | 连衣裙      |   79.90 |  2500 |</span><br><span class="line">|       5 |  1 |           1 | 女装/女士精品   | T恤         |   39.90 |  1000 |</span><br><span class="line">|       6 |  5 |           1 | 女装/女士精品   | 百褶裙      |   29.90 |   500 |</span><br><span class="line">|       1 |  8 |           2 | 户外运动       | 山地自行车   | 1399.90 |  2500 |</span><br><span class="line">|       2 | 11 |           2 | 户外运动       | 运动外套     |  799.90 |   500 |</span><br><span class="line">|       3 | 12 |           2 | 户外运动       | 滑板        |  499.90 |  1200 |</span><br><span class="line">|       4 |  7 |           2 | 户外运动       | 自行车      |  399.90 |  1000 |</span><br><span class="line">|       4 | 10 |           2 | 户外运动       | 骑行装备    |  399.90 |  3500 |</span><br><span class="line">|       6 |  9 |           2 | 户外运动       | 登山杖      |   59.90 |  1500 |</span><br><span class="line">+---------+----+-------------+---------------+------------+---------+-------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>举例：使用RANK()函数获取 goods 数据表中类别为“女装&#x2F;女士精品”的价格最高的4款商品信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT *</span><br><span class="line">    -&gt; FROM(</span><br><span class="line">    -&gt;  SELECT RANK() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,</span><br><span class="line">    -&gt;  id, category_id, category, NAME, price, stock</span><br><span class="line">    -&gt;  FROM goods) t</span><br><span class="line">    -&gt; WHERE category_id = 1 AND row_num &lt;= 4;</span><br><span class="line">+---------+----+-------------+---------------+----------+--------+-------+</span><br><span class="line">| row_num | id | category_id | category      | NAME     | price  | stock |</span><br><span class="line">+---------+----+-------------+---------------+----------+--------+-------+</span><br><span class="line">|       1 |  6 |           1 | 女装/女士精品   | 呢绒外套  | 399.90 |  1200 |</span><br><span class="line">|       2 |  3 |           1 | 女装/女士精品   | 卫衣      |  89.90 |  1500 |</span><br><span class="line">|       2 |  4 |           1 | 女装/女士精品   | 牛仔裤    |  89.90 |  3500 |</span><br><span class="line">|       4 |  2 |           1 | 女装/女士精品   | 连衣裙    |  79.90 |  2500 |</span><br><span class="line">+---------+----+-------------+---------------+----------+--------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>可以看到，使用RANK()函数得出的序号为1、2、2、4，相同价格的商品序号相同，后面的商品序号是不连续的，跳过了重复的序号。</p>
<p><strong>3．DENSE_RANK()函数</strong></p>
<p>DENSE_RANK()函数对序号进行并列排序，并且不会跳过重复的序号，比如序号为1、1、2。</p>
<p>举例：使用DENSE_RANK()函数获取 goods 数据表中各类别的价格从高到低排序的各商品信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT DENSE_RANK() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,</span><br><span class="line">    -&gt; id, category_id, category, NAME, price, stock</span><br><span class="line">    -&gt; FROM goods;</span><br><span class="line">+---------+----+-------------+---------------+------------+---------+-------+</span><br><span class="line">| row_num | id | category_id | category      | NAME       | price   | stock |</span><br><span class="line">+---------+----+-------------+---------------+------------+---------+-------+</span><br><span class="line">|       1 |  6 |           1 | 女装/女士精品   | 呢绒外套    |  399.90 |  1200 |</span><br><span class="line">|       2 |  3 |           1 | 女装/女士精品   | 卫衣        |   89.90 |  1500 |</span><br><span class="line">|       2 |  4 |           1 | 女装/女士精品   | 牛仔裤      |   89.90 |  3500 |</span><br><span class="line">|       3 |  2 |           1 | 女装/女士精品   | 连衣裙      |   79.90 |  2500 |</span><br><span class="line">|       4 |  1 |           1 | 女装/女士精品   | T恤        |   39.90 |  1000 |</span><br><span class="line">|       5 |  5 |           1 | 女装/女士精品   | 百褶裙      |   29.90 |   500 |</span><br><span class="line">|       1 |  8 |           2 | 户外运动       | 山地自行车   | 1399.90 |  2500 |</span><br><span class="line">|       2 | 11 |           2 | 户外运动       | 运动外套     |  799.90 |   500 |</span><br><span class="line">|       3 | 12 |           2 | 户外运动       | 滑板        |  499.90 |  1200 |</span><br><span class="line">|       4 |  7 |           2 | 户外运动       | 自行车       |  399.90 |  1000 |</span><br><span class="line">|       4 | 10 |           2 | 户外运动       | 骑行装备     |  399.90 |  3500 |</span><br><span class="line">|       5 |  9 |           2 | 户外运动       | 登山杖       |   59.90 |  1500 |</span><br><span class="line">+---------+----+-------------+---------------+------------+---------+-------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>举例：使用DENSE_RANK()函数获取 goods 数据表中类别为“女装&#x2F;女士精品”的价格最高的4款商品信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT *</span><br><span class="line">    -&gt; FROM(</span><br><span class="line">    -&gt;  SELECT DENSE_RANK() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num,</span><br><span class="line">    -&gt;  id, category_id, category, NAME, price, stock</span><br><span class="line">    -&gt;  FROM goods) t</span><br><span class="line">    -&gt; WHERE category_id = 1 AND row_num &lt;= 3;</span><br><span class="line">+---------+----+-------------+---------------+----------+--------+-------+</span><br><span class="line">| row_num | id | category_id | category      | NAME     | price  | stock |</span><br><span class="line">+---------+----+-------------+---------------+----------+--------+-------+</span><br><span class="line">|       1 |  6 |           1 | 女装/女士精品   | 呢绒外套  | 399.90 |  1200 |</span><br><span class="line">|       2 |  3 |           1 | 女装/女士精品   | 卫衣     |  89.90  |  1500 |</span><br><span class="line">|       2 |  4 |           1 | 女装/女士精品   | 牛仔裤    |  89.90 |  3500 |</span><br><span class="line">|       3 |  2 |           1 | 女装/女士精品   | 连衣裙    |  79.90 |  2500 |</span><br><span class="line">+---------+----+-------------+---------------+----------+--------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>可以看到，使用DENSE_RANK()函数得出的行号为1、2、2、3，相同价格的商品序号相同，后面的商品序号是连续的，并且没有跳过重复的序号。</p>
<h4 id="2-分布函数"><a href="#2-分布函数" class="headerlink" title="2. 分布函数"></a>2. 分布函数</h4><p><strong>1．PERCENT_RANK()函数</strong></p>
<p>PERCENT_RANK()函数是等级值百分比函数。按照如下方式进行计算。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(rank - 1) / (rows - 1)</span><br></pre></td></tr></table></figure>

<p>其中，rank的值为使用RANK()函数产生的序号，rows的值为当前窗口的总记录数。</p>
<p>举例：计算 goods 数据表中名称为“女装&#x2F;女士精品”的类别下的商品的PERCENT_RANK值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#写法一：</span><br><span class="line">SELECT RANK() OVER (PARTITION BY category_id ORDER BY price DESC) AS r,</span><br><span class="line">PERCENT_RANK() OVER (PARTITION BY category_id ORDER BY price DESC) AS pr,</span><br><span class="line">id, category_id, category, NAME, price, stock</span><br><span class="line">FROM goods</span><br><span class="line">WHERE category_id = 1;</span><br><span class="line"></span><br><span class="line">#写法二：</span><br><span class="line">mysql&gt; SELECT RANK() OVER w AS r,</span><br><span class="line">    -&gt; PERCENT_RANK() OVER w AS pr,</span><br><span class="line">    -&gt; id, category_id, category, NAME, price, stock</span><br><span class="line">    -&gt; FROM goods</span><br><span class="line">    -&gt; WHERE category_id = 1 WINDOW w AS (PARTITION BY category_id ORDER BY price DESC);</span><br><span class="line">+---+-----+----+-------------+---------------+----------+--------+-------+</span><br><span class="line">| r | pr  | id | category_id | category      | NAME     | price  | stock |</span><br><span class="line">+---+-----+----+-------------+---------------+----------+--------+-------+</span><br><span class="line">| 1 |   0 |  6 |           1 | 女装/女士精品   | 呢绒外套  | 399.90 |  1200 |</span><br><span class="line">| 2 | 0.2 |  3 |           1 | 女装/女士精品   | 卫衣     |  89.90 |  1500 |</span><br><span class="line">| 2 | 0.2 |  4 |           1 | 女装/女士精品   | 牛仔裤   |  89.90 |  3500  |</span><br><span class="line">| 4 | 0.6 |  2 |           1 | 女装/女士精品   | 连衣裙   |  79.90 |  2500  |</span><br><span class="line">| 5 | 0.8 |  1 |           1 | 女装/女士精品   | T恤      |  39.90 |  1000 |</span><br><span class="line">| 6 |   1 |  5 |           1 | 女装/女士精品   | 百褶裙   |  29.90  |   500 |</span><br><span class="line">+---+-----+----+-------------+---------------+----------+--------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>2．CUME_DIST()函数</strong></p>
<p>CUME_DIST()函数主要用于查询小于或等于某个值的比例。</p>
<p>举例：查询goods数据表中小于或等于当前价格的比例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT CUME_DIST() OVER(PARTITION BY category_id ORDER BY price ASC) AS cd,</span><br><span class="line">    -&gt; id, category, NAME, price</span><br><span class="line">    -&gt; FROM goods;</span><br><span class="line">+---------------------+----+---------------+------------+---------+</span><br><span class="line">| cd                  | id | category      | NAME       | price   |</span><br><span class="line">+---------------------+----+---------------+------------+---------+</span><br><span class="line">| 0.16666666666666666 |  5 | 女装/女士精品   | 百褶裙      |   29.90 |</span><br><span class="line">|  0.3333333333333333 |  1 | 女装/女士精品   | T恤        |   39.90 |</span><br><span class="line">|                 0.5 |  2 | 女装/女士精品   | 连衣裙      |   79.90 |</span><br><span class="line">|  0.8333333333333334 |  3 | 女装/女士精品   | 卫衣        |   89.90 |</span><br><span class="line">|  0.8333333333333334 |  4 | 女装/女士精品   | 牛仔裤      |   89.90 |</span><br><span class="line">|                   1 |  6 | 女装/女士精品   | 呢绒外套    |  399.90 |</span><br><span class="line">| 0.16666666666666666 |  9 | 户外运动       | 登山杖      |   59.90 |</span><br><span class="line">|                 0.5 |  7 | 户外运动       | 自行车      |  399.90 |</span><br><span class="line">|                 0.5 | 10 | 户外运动       | 骑行装备     |  399.90 |</span><br><span class="line">|  0.6666666666666666 | 12 | 户外运动       | 滑板        |  499.90 |</span><br><span class="line">|  0.8333333333333334 | 11 | 户外运动       | 运动外套    |  799.90 |</span><br><span class="line">|                   1 |  8 | 户外运动       | 山地自行车   | 1399.90 |</span><br><span class="line">+---------------------+----+---------------+------------+---------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="3-前后函数"><a href="#3-前后函数" class="headerlink" title="3. 前后函数"></a>3. 前后函数</h4><p><strong>1．LAG(expr,n)函数</strong></p>
<p>LAG(expr,n)函数返回当前行的前n行的expr的值。</p>
<p>举例：查询goods数据表中前一个商品价格与当前商品价格的差值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT id, category, NAME, price, pre_price, price - pre_price AS diff_price</span><br><span class="line">    -&gt; FROM (</span><br><span class="line">    -&gt;  SELECT  id, category, NAME, price,LAG(price,1) OVER w AS pre_price</span><br><span class="line">    -&gt;  FROM goods</span><br><span class="line">    -&gt;  WINDOW w AS (PARTITION BY category_id ORDER BY price)) t;</span><br><span class="line">+----+---------------+------------+---------+-----------+------------+</span><br><span class="line">| id | category      | NAME       | price   | pre_price | diff_price |</span><br><span class="line">+----+---------------+------------+---------+-----------+------------+</span><br><span class="line">|  5 | 女装/女士精品   | 百褶裙      |   29.90 |      NULL |       NULL |</span><br><span class="line">|  1 | 女装/女士精品   | T恤        |   39.90 |     29.90 |      10.00 |</span><br><span class="line">|  2 | 女装/女士精品   | 连衣裙      |   79.90 |     39.90 |      40.00 |</span><br><span class="line">|  3 | 女装/女士精品   | 卫衣       |   89.90 |     79.90 |      10.00 |</span><br><span class="line">|  4 | 女装/女士精品   | 牛仔裤      |   89.90 |     89.90 |       0.00 |</span><br><span class="line">|  6 | 女装/女士精品   | 呢绒外套    |  399.90 |     89.90 |     310.00 |</span><br><span class="line">|  9 | 户外运动       | 登山杖      |   59.90 |      NULL |       NULL |</span><br><span class="line">|  7 | 户外运动       | 自行车      |  399.90 |     59.90 |     340.00 |</span><br><span class="line">| 10 | 户外运动       | 骑行装备    |  399.90 |    399.90 |       0.00 |</span><br><span class="line">| 12 | 户外运动       | 滑板       |  499.90 |    399.90 |     100.00 |</span><br><span class="line">| 11 | 户外运动       | 运动外套    |  799.90 |    499.90 |     300.00 |</span><br><span class="line">|  8 | 户外运动       | 山地自行车  | 1399.90 |    799.90 |     600.00 |</span><br><span class="line">+----+---------------+------------+---------+-----------+------------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>2．LEAD(expr,n)函数</strong></p>
<p>LEAD(expr,n)函数返回当前行的后n行的expr的值。</p>
<p>举例：查询goods数据表中后一个商品价格与当前商品价格的差值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT id, category, NAME, behind_price, price,behind_price - price AS diff_price</span><br><span class="line">    -&gt; FROM(</span><br><span class="line">    -&gt;  SELECT id, category, NAME, price,LEAD(price, 1) OVER w AS behind_price</span><br><span class="line">    -&gt;  FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price)) t;</span><br><span class="line">+----+---------------+------------+--------------+---------+------------+</span><br><span class="line">| id | category      | NAME       | behind_price | price   | diff_price |</span><br><span class="line">+----+---------------+------------+--------------+---------+------------+</span><br><span class="line">|  5 | 女装/女士精品   | 百褶裙      |        39.90 |   29.90 |      10.00 |</span><br><span class="line">|  1 | 女装/女士精品   | T恤        |        79.90 |   39.90 |      40.00 |</span><br><span class="line">|  2 | 女装/女士精品   | 连衣裙      |        89.90 |   79.90 |      10.00 |</span><br><span class="line">|  3 | 女装/女士精品   | 卫衣        |        89.90 |   89.90 |       0.00 |</span><br><span class="line">|  4 | 女装/女士精品   | 牛仔裤      |       399.90 |   89.90 |     310.00 |</span><br><span class="line">|  6 | 女装/女士精品   | 呢绒外套     |         NULL |  399.90 |       NULL |</span><br><span class="line">|  9 | 户外运动       | 登山杖       |       399.90 |   59.90 |     340.00 |</span><br><span class="line">|  7 | 户外运动       | 自行车       |       399.90 |  399.90 |       0.00 |</span><br><span class="line">| 10 | 户外运动       | 骑行装备     |       499.90 |  399.90 |     100.00 |</span><br><span class="line">| 12 | 户外运动       | 滑板        |       799.90 |  499.90 |     300.00 |</span><br><span class="line">| 11 | 户外运动       | 运动外套     |      1399.90 |  799.90 |     600.00 |</span><br><span class="line">|  8 | 户外运动       | 山地自行车   |         NULL | 1399.90 |       NULL |</span><br><span class="line">+----+---------------+------------+--------------+---------+------------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="4-首尾函数"><a href="#4-首尾函数" class="headerlink" title="4. 首尾函数"></a>4. 首尾函数</h4><p><strong>1．FIRST_VALUE(expr)函数</strong></p>
<p>FIRST_VALUE(expr)函数返回第一个expr的值。</p>
<p>举例：按照价格排序，查询第1个商品的价格信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT id, category, NAME, price, stock,FIRST_VALUE(price) OVER w AS first_price</span><br><span class="line">    -&gt; FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);</span><br><span class="line">+----+---------------+------------+---------+-------+-------------+</span><br><span class="line">| id | category      | NAME       | price   | stock | first_price |</span><br><span class="line">+----+---------------+------------+---------+-------+-------------+</span><br><span class="line">|  5 | 女装/女士精品   | 百褶裙      |   29.90 |   500 |       29.90 |</span><br><span class="line">|  1 | 女装/女士精品   | T恤        |   39.90 |  1000 |       29.90 |</span><br><span class="line">|  2 | 女装/女士精品   | 连衣裙      |   79.90 |  2500 |       29.90 |</span><br><span class="line">|  3 | 女装/女士精品   | 卫衣       |   89.90 |  1500 |       29.90 |</span><br><span class="line">|  4 | 女装/女士精品   | 牛仔裤      |   89.90 |  3500 |       29.90 |</span><br><span class="line">|  6 | 女装/女士精品   | 呢绒外套    |  399.90 |  1200 |       29.90 |</span><br><span class="line">|  9 | 户外运动       | 登山杖      |   59.90 |  1500 |       59.90 |</span><br><span class="line">|  7 | 户外运动       | 自行车      |  399.90 |  1000 |       59.90 |</span><br><span class="line">| 10 | 户外运动       | 骑行装备    |  399.90 |  3500 |       59.90 |</span><br><span class="line">| 12 | 户外运动       | 滑板       |  499.90 |  1200 |       59.90 |</span><br><span class="line">| 11 | 户外运动       | 运动外套    |  799.90 |   500 |       59.90 |</span><br><span class="line">|  8 | 户外运动       | 山地自行车  | 1399.90 |  2500 |       59.90 |</span><br><span class="line">+----+---------------+------------+---------+-------+-------------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>2．LAST_VALUE(expr)函数</strong></p>
<p>LAST_VALUE(expr)函数返回最后一个expr的值。</p>
<p>举例：按照价格排序，查询最后一个商品的价格信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT id, category, NAME, price, stock,LAST_VALUE(price) OVER w AS last_price</span><br><span class="line">    -&gt; FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);</span><br><span class="line">+----+---------------+------------+---------+-------+------------+</span><br><span class="line">| id | category      | NAME       | price   | stock | last_price |</span><br><span class="line">+----+---------------+------------+---------+-------+------------+</span><br><span class="line">|  5 | 女装/女士精品   | 百褶裙     |   29.90 |   500 |      29.90 |</span><br><span class="line">|  1 | 女装/女士精品   | T恤        |   39.90 |  1000 |      39.90 |</span><br><span class="line">|  2 | 女装/女士精品   | 连衣裙     |   79.90 |  2500 |      79.90 |</span><br><span class="line">|  3 | 女装/女士精品   | 卫衣       |   89.90 |  1500 |      89.90 |</span><br><span class="line">|  4 | 女装/女士精品   | 牛仔裤     |   89.90 |  3500 |      89.90 |</span><br><span class="line">|  6 | 女装/女士精品   | 呢绒外套   |  399.90 |  1200 |     399.90 |</span><br><span class="line">|  9 | 户外运动       | 登山杖     |   59.90 |  1500 |      59.90 |</span><br><span class="line">|  7 | 户外运动       | 自行车     |  399.90 |  1000 |     399.90 |</span><br><span class="line">| 10 | 户外运动       | 骑行装备   |  399.90 |  3500 |     399.90 |</span><br><span class="line">| 12 | 户外运动       | 滑板       |  499.90 |  1200 |     499.90 |</span><br><span class="line">| 11 | 户外运动       | 运动外套   |  799.90 |   500 |     799.90 |</span><br><span class="line">|  8 | 户外运动       | 山地自行车 | 1399.90 |  2500 |    1399.90 |</span><br><span class="line">+----+---------------+------------+---------+-------+------------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="5-其他函数"><a href="#5-其他函数" class="headerlink" title="5. 其他函数"></a>5. 其他函数</h4><p><strong>1．NTH_VALUE(expr,n)函数</strong></p>
<p>NTH_VALUE(expr,n)函数返回第n个expr的值。</p>
<p>举例：查询goods数据表中排名第2和第3的价格信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT id, category, NAME, price,NTH_VALUE(price,2) OVER w AS second_price,</span><br><span class="line">    -&gt; NTH_VALUE(price,3) OVER w AS third_price</span><br><span class="line">    -&gt; FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);</span><br><span class="line">+----+---------------+------------+---------+--------------+-------------+</span><br><span class="line">| id | category      | NAME       | price   | second_price | third_price |</span><br><span class="line">+----+---------------+------------+---------+--------------+-------------+</span><br><span class="line">|  5 | 女装/女士精品   | 百褶裙     |   29.90 |         NULL |        NULL |</span><br><span class="line">|  1 | 女装/女士精品   | T恤        |   39.90 |        39.90 |        NULL |</span><br><span class="line">|  2 | 女装/女士精品   | 连衣裙     |   79.90 |        39.90 |       79.90 |</span><br><span class="line">|  3 | 女装/女士精品   | 卫衣       |   89.90 |        39.90 |       79.90 |</span><br><span class="line">|  4 | 女装/女士精品   | 牛仔裤     |   89.90 |        39.90 |       79.90 |</span><br><span class="line">|  6 | 女装/女士精品   | 呢绒外套   |  399.90 |        39.90 |       79.90 |</span><br><span class="line">|  9 | 户外运动       | 登山杖     |   59.90 |         NULL |        NULL |</span><br><span class="line">|  7 | 户外运动       | 自行车     |  399.90 |       399.90 |      399.90 |</span><br><span class="line">| 10 | 户外运动       | 骑行装备   |  399.90 |       399.90 |      399.90 |</span><br><span class="line">| 12 | 户外运动       | 滑板       |  499.90 |       399.90 |      399.90 |</span><br><span class="line">| 11 | 户外运动       | 运动外套   |  799.90 |       399.90 |      399.90 |</span><br><span class="line">|  8 | 户外运动       | 山地自行车 | 1399.90 |       399.90 |      399.90 |</span><br><span class="line">+----+---------------+------------+---------+--------------+-------------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p><strong>2．NTILE(n)函数</strong></p>
<p>NTILE(n)函数将分区中的有序数据分为n个桶，记录桶编号。</p>
<p>举例：将goods表中的商品按照价格分为3组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT NTILE(3) OVER w AS nt,id, category, NAME, price</span><br><span class="line">    -&gt; FROM goods WINDOW w AS (PARTITION BY category_id ORDER BY price);</span><br><span class="line">+----+----+---------------+------------+---------+</span><br><span class="line">| nt | id | category      | NAME       | price   |</span><br><span class="line">+----+----+---------------+------------+---------+</span><br><span class="line">|  1 |  5 | 女装/女士精品 | 百褶裙     |   29.90 |</span><br><span class="line">|  1 |  1 | 女装/女士精品 | T恤        |   39.90 |</span><br><span class="line">|  2 |  2 | 女装/女士精品 | 连衣裙     |   79.90 |</span><br><span class="line">|  2 |  3 | 女装/女士精品 | 卫衣       |   89.90 |</span><br><span class="line">|  3 |  4 | 女装/女士精品 | 牛仔裤     |   89.90 |</span><br><span class="line">|  3 |  6 | 女装/女士精品 | 呢绒外套   |  399.90 |</span><br><span class="line">|  1 |  9 | 户外运动      | 登山杖     |   59.90 |</span><br><span class="line">|  1 |  7 | 户外运动      | 自行车     |  399.90 |</span><br><span class="line">|  2 | 10 | 户外运动      | 骑行装备   |  399.90 |</span><br><span class="line">|  2 | 12 | 户外运动      | 滑板       |  499.90 |</span><br><span class="line">|  3 | 11 | 户外运动      | 运动外套   |  799.90 |</span><br><span class="line">|  3 |  8 | 户外运动      | 山地自行车 | 1399.90 |</span><br><span class="line">+----+----+---------------+------------+---------+</span><br><span class="line">12 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="2-5-小-结"><a href="#2-5-小-结" class="headerlink" title="2.5 小 结"></a>2.5 小 结</h3><p>窗口函数的特点是可以分组，而且可以在分组内排序。另外，窗口函数不会因为分组而减少原表中的行数，这对我们在原表数据的基础上进行统计和排序非常有用。</p>
<h2 id="3-新特性2：公用表表达式"><a href="#3-新特性2：公用表表达式" class="headerlink" title="3. 新特性2：公用表表达式"></a>3. 新特性2：公用表表达式</h2><p>公用表表达式（或通用表表达式）简称为CTE（Common Table Expressions）。CTE是一个命名的临时结果集，作用范围是当前语句。CTE可以理解成一个可以复用的子查询，当然跟子查询还是有点区别的，CTE可以引用其他CTE，但子查询不能引用其他子查询。所以，可以考虑代替子查询。</p>
<p>依据语法结构和执行方式的不同，公用表表达式分为<code>普通公用表表达式</code>和<code>递归公用表表达式</code> 2 种。</p>
<h3 id="3-1-普通公用表表达式"><a href="#3-1-普通公用表表达式" class="headerlink" title="3.1 普通公用表表达式"></a>3.1 普通公用表表达式</h3><p>普通公用表表达式的语法结构是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WITH CTE名称 </span><br><span class="line">AS （子查询）</span><br><span class="line">SELECT|DELETE|UPDATE 语句;</span><br></pre></td></tr></table></figure>

<p>普通公用表表达式类似于子查询，不过，跟子查询不同的是，它可以被多次引用，而且可以被其他的普通公用表表达式所引用。</p>
<p>举例：查询员工所在的部门的详细信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM departments</span><br><span class="line">    -&gt; WHERE department_id IN (</span><br><span class="line">    -&gt;                  SELECT DISTINCT department_id</span><br><span class="line">    -&gt;                  FROM employees</span><br><span class="line">    -&gt;                  );</span><br><span class="line">+---------------+------------------+------------+-------------+</span><br><span class="line">| department_id | department_name  | manager_id | location_id |</span><br><span class="line">+---------------+------------------+------------+-------------+</span><br><span class="line">|            10 | Administration   |        200 |        1700 |</span><br><span class="line">|            20 | Marketing        |        201 |        1800 |</span><br><span class="line">|            30 | Purchasing       |        114 |        1700 |</span><br><span class="line">|            40 | Human Resources  |        203 |        2400 |</span><br><span class="line">|            50 | Shipping         |        121 |        1500 |</span><br><span class="line">|            60 | IT               |        103 |        1400 |</span><br><span class="line">|            70 | Public Relations |        204 |        2700 |</span><br><span class="line">|            80 | Sales            |        145 |        2500 |</span><br><span class="line">|            90 | Executive        |        100 |        1700 |</span><br><span class="line">|           100 | Finance          |        108 |        1700 |</span><br><span class="line">|           110 | Accounting       |        205 |        1700 |</span><br><span class="line">+---------------+------------------+------------+-------------+</span><br><span class="line">11 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>这个查询也可以用普通公用表表达式的方式完成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; WITH emp_dept_id</span><br><span class="line">    -&gt; AS (SELECT DISTINCT department_id FROM employees)</span><br><span class="line">    -&gt; SELECT *</span><br><span class="line">    -&gt; FROM departments d JOIN emp_dept_id e</span><br><span class="line">    -&gt; ON d.department_id = e.department_id;</span><br><span class="line">+---------------+------------------+------------+-------------+---------------+</span><br><span class="line">| department_id | department_name  | manager_id | location_id | department_id |</span><br><span class="line">+---------------+------------------+------------+-------------+---------------+</span><br><span class="line">|            90 | Executive        |        100 |        1700 |            90 |</span><br><span class="line">|            60 | IT               |        103 |        1400 |            60 |</span><br><span class="line">|           100 | Finance          |        108 |        1700 |           100 |</span><br><span class="line">|            30 | Purchasing       |        114 |        1700 |            30 |</span><br><span class="line">|            50 | Shipping         |        121 |        1500 |            50 |</span><br><span class="line">|            80 | Sales            |        145 |        2500 |            80 |</span><br><span class="line">|            10 | Administration   |        200 |        1700 |            10 |</span><br><span class="line">|            20 | Marketing        |        201 |        1800 |            20 |</span><br><span class="line">|            40 | Human Resources  |        203 |        2400 |            40 |</span><br><span class="line">|            70 | Public Relations |        204 |        2700 |            70 |</span><br><span class="line">|           110 | Accounting       |        205 |        1700 |           110 |</span><br><span class="line">+---------------+------------------+------------+-------------+---------------+</span><br><span class="line">11 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>例子说明，公用表表达式可以起到子查询的作用。以后如果遇到需要使用子查询的场景，你可以在查询之前，先定义公用表表达式，然后在查询中用它来代替子查询。而且，跟子查询相比，公用表表达式有一个优点，就是定义过公用表表达式之后的查询，可以像一个表一样多次引用公用表表达式，而子查询则不能。</p>
<h3 id="3-2-递归公用表表达式"><a href="#3-2-递归公用表表达式" class="headerlink" title="3.2 递归公用表表达式"></a>3.2 递归公用表表达式</h3><p>递归公用表表达式也是一种公用表表达式，只不过，除了普通公用表表达式的特点以外，它还有自己的特点，就是<strong>可以调用自己</strong>。它的语法结构是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WITH RECURSIVE</span><br><span class="line">CTE名称 AS （子查询）</span><br><span class="line">SELECT|DELETE|UPDATE 语句;</span><br></pre></td></tr></table></figure>

<p>递归公用表表达式由 2 部分组成，分别是种子查询和递归查询，中间通过关键字 UNION  [ALL]进行连接。这里的<strong>种子查询，意思就是获得递归的初始值</strong>。这个查询只会运行一次，以创建初始数据集，之后递归查询会一直执行，直到没有任何新的查询数据产生，递归返回。</p>
<p>**案例：**针对于我们常用的employees表，包含employee_id，last_name和manager_id三个字段。如果a是b的管理者，那么，我们可以把b叫做a的下属，如果同时b又是c的管理者，那么c就是b的下属，是a的下下属。</p>
<p>下面我们尝试用查询语句列出所有具有下下属身份的人员信息。</p>
<p>如果用我们之前学过的知识来解决，会比较复杂，至少要进行 4 次查询才能搞定：</p>
<ul>
<li><p>第一步，先找出初代管理者，就是不以任何别人为管理者的人，把结果存入临时表；</p>
</li>
<li><p>第二步，找出所有以初代管理者为管理者的人，得到一个下属集，把结果存入临时表；</p>
</li>
<li><p>第三步，找出所有以下属为管理者的人，得到一个下下属集，把结果存入临时表。</p>
</li>
<li><p>第四步，找出所有以下下属为管理者的人，得到一个结果集。</p>
</li>
</ul>
<p>如果第四步的结果集为空，则计算结束，第三步的结果集就是我们需要的下下属集了，否则就必须继续进行第四步，一直到结果集为空为止。比如上面的这个数据表，就需要到第五步，才能得到空结果集。而且，最后还要进行第六步：把第三步和第四步的结果集合并，这样才能最终获得我们需要的结果集。</p>
<p>如果用递归公用表表达式，就非常简单了。我介绍下具体的思路。</p>
<ul>
<li><p>用递归公用表表达式中的种子查询，找出初代管理者。字段 n 表示代次，初始值为 1，表示是第一代管理者。</p>
</li>
<li><p>用递归公用表表达式中的递归查询，查出以这个递归公用表表达式中的人为管理者的人，并且代次的值加 1。直到没有人以这个递归公用表表达式中的人为管理者了，递归返回。</p>
</li>
<li><p>在最后的查询中，选出所有代次大于等于 3 的人，他们肯定是第三代及以上代次的下属了，也就是下下属了。这样就得到了我们需要的结果集。</p>
</li>
</ul>
<p>这里看似也是 3 步，实际上是一个查询的 3 个部分，只需要执行一次就可以了。而且也不需要用临时表保存中间结果，比刚刚的方法简单多了。</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WITH RECURSIVE cte </span><br><span class="line">AS </span><br><span class="line">(</span><br><span class="line">SELECT employee_id,last_name,manager_id,1 AS n FROM employees WHERE employee_id = 100 -- 种子查询，找到第一代领导</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT a.employee_id,a.last_name,a.manager_id,n+1 FROM employees AS a JOIN cte</span><br><span class="line">ON (a.manager_id = cte.employee_id) -- 递归查询，找出以递归公用表表达式的人为领导的人</span><br><span class="line">)</span><br><span class="line">SELECT employee_id,last_name FROM cte WHERE n &gt;= 3; </span><br></pre></td></tr></table></figure>

<p>总之，递归公用表表达式对于查询一个有共同的根节点的树形结构数据，非常有用。它可以不受层级的限制，轻松查出所有节点的数据。如果用其他的查询方式，就比较复杂了。</p>
<h3 id="3-3-小-结"><a href="#3-3-小-结" class="headerlink" title="3.3 小 结"></a>3.3 小 结</h3><p>公用表表达式的作用是可以替代子查询，而且可以被多次引用。递归公用表表达式对查询有一个共同根节点的树形结构数据非常高效，可以轻松搞定其他查询方式难以处理的查询。</p>
]]></content>
  </entry>
  <entry>
    <title>MySQL 总结 (一)</title>
    <url>/2021/11/20/MySQL%E6%80%BB%E7%BB%931/</url>
    <content><![CDATA[<h1 id="MySQL-相关"><a href="#MySQL-相关" class="headerlink" title="MySQL 相关"></a>MySQL 相关</h1><h2 id="desc-表名"><a href="#desc-表名" class="headerlink" title="desc 表名"></a>desc 表名</h2><p>describe– 描述</p>
<p>descend– 下降</p>
<hr>
<blockquote>
<p>descibe 是查看表的结构，例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">describe tablename;</span><br></pre></td></tr></table></figure>

<p>desc 是 describe 的简写，例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">desc tablename;</span><br></pre></td></tr></table></figure>

</blockquote>
<p>另外 desc 在排序中的意义是降续排列（和 describe 的简写不是同一个），例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">order</span> <span class="keyword">by</span> id  <span class="keyword">desc</span> ;</span><br></pre></td></tr></table></figure>

<h1 id="关于-where"><a href="#关于-where" class="headerlink" title="关于 where"></a>关于 where</h1><hr>
<blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> stu <span class="keyword">set</span> score<span class="operator">=</span><span class="number">22</span> [<span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>如果不加 where 那么修改的是全局的</p>
</blockquote>
<blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> stu [<span class="keyword">where</span> id <span class="operator">=</span><span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>如果不加 where 那么删除的是全部的 所以要注意</p>
</blockquote>
<h1 id="select-中的-distinct"><a href="#select-中的-distinct" class="headerlink" title="select 中的 distinct"></a>select 中的 distinct</h1><p>–distinct  adj.  清晰的；清楚的；明白的；明显的；截然不同的；有区别的；不同种类的；确定无疑的；确实的；确切的；</p>
<hr>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span>  gender <span class="keyword">from</span> emp</span><br></pre></td></tr></table></figure>



<h1 id="Null-和仍和数据运算结果都是-null-以及有关-null-的运算"><a href="#Null-和仍和数据运算结果都是-null-以及有关-null-的运算" class="headerlink" title="Null 和仍和数据运算结果都是 null, 以及有关 null 的运算"></a>Null 和仍和数据运算结果都是 null, 以及有关 null 的运算</h1><hr>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> NAME</span><br><span class="line">	,</span><br><span class="line">	sal <span class="operator">+</span> bonus</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	sal <span class="operator">+</span> bonus <span class="operator">&gt;</span> <span class="number">3500</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>问题</strong>: 其中有一条数据 A 的 bonus 为 null, 但是他的 sal &gt;3500 了已经。<br>我们要求能把 null&#x3D;0 最好，而且查出来。</p>
<blockquote>
<p>方法 1: 将所有的奖金为 null 的列更新为 0</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> bonus <span class="operator">=</span><span class="number">0</span> <span class="keyword">where</span> bonus <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> bonus <span class="operator">=</span><span class="number">0</span> <span class="keyword">where</span> bonus <span class="keyword">is</span> <span class="keyword">not null</span>;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<blockquote>
<p>SELECT * from emp WHERE dept is not null<br>SELECT * from emp WHERE not (dept is  null)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></blockquote>
<blockquote>
<p>方法 2: 在查询时将 null 值 看做 0 来处理（这种方式不会对表中的数据产生仍和影响）</p>
<p><strong>ifnull（列名，值）</strong> 函数：判断指定的列是否包含 null, 若果有 null 就用第二个<strong>值</strong> 替换。<br>ifnull(bonus,0)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> NAME</span><br><span class="line">	,</span><br><span class="line">	IFNULL(bonus,<span class="number">0</span>) <span class="operator">+</span> sal</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">IFNULL(bonus,<span class="number">0</span>) <span class="operator">+</span> sal <span class="operator">&gt;</span> <span class="number">3500</span></span><br></pre></td></tr></table></figure></blockquote>
<h1 id="取别名的问题"><a href="#取别名的问题" class="headerlink" title="取别名的问题"></a>取别名的问题</h1><hr>
<h1 id="模糊查询-LIKE"><a href="#模糊查询-LIKE" class="headerlink" title="模糊查询 LIKE"></a>模糊查询 LIKE</h1><hr>
<p>like 操作符 用在 WHERE 子句中搜索列中的指定模式。</p>
<blockquote>
<p>可以和 % _ 使用。</p>
<p>其中 % 代表<strong>0 个或者多个</strong>任意字符，_代表<strong>一个</strong>任意字符。</p>
</blockquote>
<h1 id="多行函数查询"><a href="#多行函数查询" class="headerlink" title="多行函数查询"></a>多行函数查询</h1><p>– 多行函数也叫聚合函数，也叫聚集函数</p>
<p><strong>多行函数会默认过滤 null 值</strong> , 即不统计 null 值</p>
<hr>
<p>count（列名 | *):                  | 是或的意思</p>
<blockquote>
<p>count（列名）: 表示统计当前列有多少个值<br>count(*): 以行为单位，统计查询结果中有多少行记录</p>
</blockquote>
<p>max（列名）:<br>min（列名）:<br>sum（列名）: 统计这一列中所有值的和 (<strong>会过滤 null 值</strong>) 参考上面的<br>avg（列名）: 会过滤 null 值（所有值的和 &#x2F; 不是 null 值的个数）</p>
<ul>
<li><strong>在统计时，不要加格外的列，因为没有任何意义</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="built_in">COUNT</span>( <span class="operator">*</span> ),</span><br><span class="line">	`name`</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	EMP</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	EMP.sal <span class="operator">&gt;</span> <span class="number">3000</span></span><br><span class="line"><span class="comment">-- 如果没有分组 在进行统计时，不要添加格外的列，因为没有任何意义（这里的 name 只会将第一行的 name 显示出来）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="built_in">max</span>( sal ),</span><br><span class="line">	`name`</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	EMP</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	EMP.sal <span class="operator">&gt;</span> <span class="number">3000</span></span><br><span class="line"><span class="comment">-- 所以这里的 name 不能认为是最高薪资的那一个人，</span></span><br><span class="line"><span class="comment">-- 如果没有分组，那么最高薪资和姓名没有任何关系，薪资是所有薪资的最大值，但是 name 就是结果中的第一行的 name</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="built_in">sum</span>( bonus )</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	emp</span><br><span class="line"><span class="comment">-- 如果 bonus 是里面有 null 的话会过滤掉。前面说了的。不会参与统计</span></span><br></pre></td></tr></table></figure>

<ul>
<li>avg 是剔除了为 null 的 count 的那条记录的平均值，那一行不算在内</li>
</ul>
<h1 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h1><p>group by</p>
<hr>
<p>select count(*) from emp;<br>– 如果没有分组，</p>
<h1 id="升序和降序"><a href="#升序和降序" class="headerlink" title="升序和降序"></a>升序和降序</h1><hr>
<p>DESC 是 descend 降序意思<br>ASC 是 ascend 升序的意思 <strong>默认是 ASC</strong></p>
<h1 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h1><p><strong>limit</strong></p>
<hr>
<h1 id="删除的区别"><a href="#删除的区别" class="headerlink" title="删除的区别"></a>删除的区别</h1><hr>
<p>delete，drop，truncate 都有删除表的作用，区别在于：</p>
<ul>
<li>delete 和 truncate 仅仅删除表数据，所以会保存字段名，drop 连表数据和表结构一起删除，打个比方，delete 是单杀，truncate 是团灭，drop 是把电脑摔了。</li>
<li>delete 是 DML 语句，操作完以后如果没有不想提交事务还可以回滚，truncate 和 drop 是 DDL 语句，操作完马上生效，不能回滚，打个比方，delete 是发微信说分手，后悔还可以撤回，truncate 和 drop 是直接扇耳光说滚，不能反悔。</li>
<li>执行的速度上，<strong>drop&gt;truncate&gt;delete</strong>，打个比方，drop 是神舟火箭，truncate 是和谐号动车，delete 是自行车。</li>
</ul>
<h1 id="varchar-和-char"><a href="#varchar-和-char" class="headerlink" title="varchar 和 char"></a>varchar 和 char</h1><hr>
<p>区别一，定长和变长</p>
<blockquote>
<p>char 表示定长，长度固定，varch ar 表示变长，即长度可变。char 如果插入的长度小于定义长度时，则用空格填充；varchar 小于定义长度时，还是按实际长度存储，插入多长就存多长。</p>
</blockquote>
<blockquote>
<p> 因为其长度固定，char 的存取速度还是要比 varchar 要快得多，方便程序的存储与查找；但是 char 也为此付出的是空间的代价，因为其长度固定，所以会占据多余的空间，可谓是以空间换取时间效率。varchar 则刚好相反，以时间换空间。</p>
</blockquote>
<p>区别之二，存储的容量不同</p>
<blockquote>
<p>对 char 来说，最多能存放的字符个数 255，和 编码无关。<br>而 varchar 呢，最多能存放 65532 个字符。varchar 的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是 65,532 字节。</p>
</blockquote>
<p>区别之三，空格</p>
<p>char 在存储的时候会将右侧空格进行剔除，保留左侧空格。<br>varchar 在存储的时候保留所有空格，不进行任何删除</p>
<p>varchar 和 char 在查询的时候都只会根据 where 条件中的左侧空格进行判断，右侧末尾的空格会忽略</p>
<h1 id="自增"><a href="#自增" class="headerlink" title="自增"></a>自增</h1><p>auto_increment</p>
<hr>
<p>可以用 show create  table emp</p>
<blockquote>
<p> 设置完主键自增后，表中会维护一个 AUTO_INCREMENT 的值，这个值从<strong>1</strong>开始。如果插入的那一列没有给主键赋值。那就是从 AUTO_INCREMENT 获取值。用完后自加 1.<br>  所以查看具体的最下面有一个 auto_increment&#x3D; 多少；</p>
</blockquote>
<p>注意：</p>
<blockquote>
<p>auto_increment 会安照 <strong>最大</strong> 的去自增。</p>
</blockquote>
<h1 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h1><hr>
<p>唯一，非空。一般和 auto_increment 一起用</p>
<h1 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h1><hr>
<p>非空，但是可以重复</p>
<h1 id="唯一约束-–unique"><a href="#唯一约束-–unique" class="headerlink" title="唯一约束 –unique"></a>唯一约束 –unique</h1><hr>
<p>不能重复，可以为 null</p>
<h1 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h1><hr>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>  <span class="keyword">from</span> emp,dept</span><br></pre></td></tr></table></figure>

<p>以上有笛卡尔积。</p>
<p>消除笛卡尔积 用<strong>inner join 内连接</strong>. 把逗号，改成 inner join where 改成 on</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept <span class="keyword">on</span> emp.dept_id<span class="operator">=</span>dept.id</span><br><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">INNER</span> <span class="keyword">JOIN</span> emp <span class="keyword">on</span> emp.dept_id<span class="operator">=</span>dept.id</span><br></pre></td></tr></table></figure>

<p>以上两种都可以。但是 null 值不会显示出来</p>
<p>可以用左外连接和右外连接：</p>
<blockquote>
<p>左外连接。查询左边的所以值</p>
<p>右外连接：查询右边所有的值</p>
</blockquote>
<p>显示所有部门对应的员工值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">left</span> <span class="keyword">JOIN</span> emp <span class="keyword">on</span> emp.dept_id<span class="operator">=</span>dept.id</span><br><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">right</span> <span class="keyword">JOIN</span> dept <span class="keyword">on</span> emp.dept_id<span class="operator">=</span>dept.id</span><br></pre></td></tr></table></figure>

<p>显示所有员工对应的部门值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">right</span> <span class="keyword">JOIN</span> emp <span class="keyword">on</span> emp.dept_id<span class="operator">=</span>dept.id</span><br><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">LEFT</span>  <span class="keyword">JOIN</span> dept <span class="keyword">on</span> emp.dept_id<span class="operator">=</span>dept.id</span><br></pre></td></tr></table></figure>

<p>这样不能查询所以的对应的 null 值</p>
<p>而且 mysql 没有全外连接查询。</p>
<p>可以通过 union 模拟这种查询</p>
<h1 id="where-比-having-先执行"><a href="#where-比-having-先执行" class="headerlink" title="where 比 having 先执行"></a>where 比 having 先执行</h1><hr>
<p>having 和 where 区别：</p>
<blockquote>
<ul>
<li>where 放在 from 之后，group by 之前</li>
<li>where 不能使用多行函数（聚集函数）, 列别名也不能用在 where 中</li>
<li>where 是在分组之前之前。先过滤一些记录，再基于剩余的记录进行返祖。</li>
<li>要先分组再过滤，基于剩下的记录进行分组，就用 having</li>
</ul>
</blockquote>
<p>where 和 having 的区别：</p>
<blockquote>
<ul>
<li><p>where 和 having 都是对于表记录中的记录进行过滤筛选</p>
</li>
<li><p>where 用于在分组之前对记录进行过滤筛选，而 having 是对分组之后的记录进行过滤筛选</p>
</li>
<li><p>where 子句中不能使用多行函数（聚集函数）, 和列别名。但是可以用表别名</p>
<blockquote>
<p>select name as 姓名，sal as 薪资 from emp e;</p>
<p>– 其中上面的’姓名’,’薪资’都是列别名，而 e 是表别名</p>
</blockquote>
</li>
<li><p>having 子句中可以使用多行函数（聚集函数）, 列别名，表别名</p>
</li>
</ul>
</blockquote>
<h2 id="插入数据时，数值类型的数据可以用单引号括起来这样也会识别成数值，一般来说。没人这么闲。不过导出的-sql-一般会自带-‘"><a href="#插入数据时，数值类型的数据可以用单引号括起来这样也会识别成数值，一般来说。没人这么闲。不过导出的-sql-一般会自带-‘" class="headerlink" title="插入数据时，数值类型的数据可以用单引号括起来这样也会识别成数值，一般来说。没人这么闲。不过导出的 sql 一般会自带  ‘"></a>插入数据时，数值类型的数据可以用单引号括起来这样也会识别成数值，一般来说。没人这么闲。不过导出的 sql 一般会自带  ‘</h2><h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><hr>
<h2 id="写-sql-片段时-小于号会被识别为-xml-的标签，大于不会，因为大于没开始的标志"><a href="#写-sql-片段时-小于号会被识别为-xml-的标签，大于不会，因为大于没开始的标志" class="headerlink" title="写 sql 片段时 小于号会被识别为 xml 的标签，大于不会，因为大于没开始的标志"></a>写 sql 片段时 小于号会被识别为 xml 的标签，大于不会，因为大于没开始的标志</h2><hr>
<p>大于：&gt;</p>
<blockquote>
<p>可以用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&amp;gt;</span> // 记得加分号 great than</span><br></pre></td></tr></table></figure></blockquote>
<p>小于：&lt;</p>
<blockquote>
<p> <strong>必须用</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&amp;lt;</span> // 记得加分号 less than</span><br></pre></td></tr></table></figure></blockquote>
<h1 id="好像有一个万能的转义字符"><a href="#好像有一个万能的转义字符" class="headerlink" title="好像有一个万能的转义字符"></a>好像有一个万能的转义字符</h1><hr>
<![CDATA[hello]]>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;![CDATA『这里输入你要展示的仍何内容』]&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Mybatis-1"><a href="#Mybatis-1" class="headerlink" title="Mybatis"></a>Mybatis</h1><hr>
<h1 id="写-sql-片段时-小于号会被识别为-xml-的标签，大于不会，因为大于没开始的标志-1"><a href="#写-sql-片段时-小于号会被识别为-xml-的标签，大于不会，因为大于没开始的标志-1" class="headerlink" title="写 sql 片段时 小于号会被识别为 xml 的标签，大于不会，因为大于没开始的标志"></a>写 sql 片段时 小于号会被识别为 xml 的标签，大于不会，因为大于没开始的标志</h1><hr>
<p>大于：&gt;</p>
<blockquote>
<p>可以用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&amp;gt;</span> // 记得加分号 great than</span><br></pre></td></tr></table></figure></blockquote>
<p>小于：&lt;</p>
<blockquote>
<p> <strong>必须用</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&amp;lt;</span> // 记得加分号 less than</span><br></pre></td></tr></table></figure></blockquote>
<h1 id="好像有一个万能的转义字符-1"><a href="#好像有一个万能的转义字符-1" class="headerlink" title="好像有一个万能的转义字符"></a>好像有一个万能的转义字符</h1><hr>
<![CDATA[hello]]>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;![CDATA『这里输入你要展示的仍何内容』]&gt;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>MySQL 总结（二）</title>
    <url>/2021/11/25/MySQL%E6%80%BB%E7%BB%932/</url>
    <content><![CDATA[<h1 id="MySQL-注意的点："><a href="#MySQL-注意的点：" class="headerlink" title="MySQL 注意的点："></a>MySQL 注意的点：</h1><blockquote>
<p>写代码的时候突然觉得自己 SQL 方面有点弱，于是有了这篇文章</p>
</blockquote>
<hr>
<h2 id="为什么-where-不能用字段别名。因为-mysql-执行顺序："><a href="#为什么-where-不能用字段别名。因为-mysql-执行顺序：" class="headerlink" title="为什么 where 不能用字段别名。因为 mysql 执行顺序："></a>为什么 where 不能用<code>字段</code>别名。因为 mysql <strong>执行顺序</strong>：</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 错误：</span></span><br><span class="line"><span class="keyword">select</span> last_name <span class="keyword">as</span> name</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%shit%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正确：</span></span><br><span class="line"><span class="keyword">select</span> last_name <span class="keyword">as</span> name        <span class="comment">-- 最后再 select 生成字段</span></span><br><span class="line"><span class="keyword">from</span> employees                  <span class="comment">-- 先执行 from 哪个表</span></span><br><span class="line"><span class="keyword">where</span> last_name <span class="keyword">like</span> <span class="string">&#x27;%shit%&#x27;</span>;  <span class="comment">-- 再执行 where 条件</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="limit-使用方法"><a href="#limit-使用方法" class="headerlink" title="limit 使用方法"></a>limit 使用方法</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 这条语句意思是 从第 51 条数据（包括 51) 开始数，数 10 条数据出来</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line">limit <span class="number">50</span>,<span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 前端传第几页可以这样给：</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line">limit (currentPage<span class="number">-1</span>)<span class="operator">*</span>pageSize,pageSize;</span><br><span class="line"><span class="comment">---------------------------------</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line">limit <span class="number">0</span>,<span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line">limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="从-sql-优化来说，多表查询的字段最好都指明表名。减少-sql-找字段的时间。当然如果有同样的字段那肯定得指定的。"><a href="#从-sql-优化来说，多表查询的字段最好都指明表名。减少-sql-找字段的时间。当然如果有同样的字段那肯定得指定的。" class="headerlink" title="从 sql 优化来说，多表查询的字段最好都指明表名。减少 sql 找字段的时间。当然如果有同样的字段那肯定得指定的。"></a>从 sql 优化来说，多表查询的字段最好都指明表名。减少 sql 找字段的时间。当然如果有同样的字段那肯定得指定的。</h2><blockquote>
<p>E-R 图<br><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/25/MySQL%E6%80%BB%E7%BB%932/Snipaste_2022-03-17_17-35-04.jpg"
                        alt="PANGU_DISABLE"
                 ></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 正确：</span><br><span class="line">select employees.department_id, departments.department_id, employees.employee_id</span><br><span class="line">from employees,</span><br><span class="line">     departments</span><br><span class="line">where employees.department_id = departments.department_id;</span><br><span class="line"></span><br><span class="line">-- 正确（但是不高效）：</span><br><span class="line">select employees.department_id, departments.department_id, employee_id</span><br><span class="line">from employees,</span><br><span class="line">     departments</span><br><span class="line">where employees.department_id = departments.department_id;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="如果给表起了别名，在-select-或者-where-中使用表名的话，必须用别名，否则报错。因为-mysql-的执行顺序，表的别名会覆盖表名"><a href="#如果给表起了别名，在-select-或者-where-中使用表名的话，必须用别名，否则报错。因为-mysql-的执行顺序，表的别名会覆盖表名" class="headerlink" title="如果给表起了别名，在 select 或者 where 中使用表名的话，必须用别名，否则报错。因为 mysql 的执行顺序，表的别名会覆盖表名"></a>如果给表起了别名，在 select 或者 where 中使用表名的话，必须用别名，否则报错。因为 mysql 的执行顺序，表的别名会覆盖表名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 正确</span><br><span class="line">select employee_id, dept.department_id, employee_id</span><br><span class="line">from employees emp,</span><br><span class="line">     departments dept</span><br><span class="line">where emp.department_id = dept.department_id;</span><br><span class="line"></span><br><span class="line">-- 错误</span><br><span class="line">select employee_id, departments.department_id, employee_id</span><br><span class="line">from employees emp,</span><br><span class="line">     departments dept</span><br><span class="line">where employees.department_id = departments.department_id;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="UNION-操作会返回两个查询结果的并集，会去除相同的记录，而-UNION-ALL-不会去重，可以不去重就不去重的写法，去重是-mysql-去重的，所以-UNION-ALL-效率高。"><a href="#UNION-操作会返回两个查询结果的并集，会去除相同的记录，而-UNION-ALL-不会去重，可以不去重就不去重的写法，去重是-mysql-去重的，所以-UNION-ALL-效率高。" class="headerlink" title="UNION 操作会返回两个查询结果的并集，会去除相同的记录，而 UNION ALL 不会去重，可以不去重就不去重的写法，去重是 mysql 去重的，所以 UNION  ALL 效率高。"></a>UNION 操作会返回两个查询结果的并集，会去除相同的记录，而 UNION ALL 不会去重，可以不去重就不去重的写法，去重是 mysql 去重的，所以 UNION  ALL 效率高。</h2><hr>
<h2 id="COUNT-是计算不包括-null-的个数"><a href="#COUNT-是计算不包括-null-的个数" class="headerlink" title="COUNT() 是计算不包括 null 的个数"></a>COUNT() 是计算不包括 null 的个数</h2><hr>
<h2 id="酷COUNT-COUNT-1-COUNT（字段）哪个效率更高？"><a href="#酷COUNT-COUNT-1-COUNT（字段）哪个效率更高？" class="headerlink" title="酷COUNT(*),COUNT(1),COUNT（字段）哪个效率更高？"></a>酷<code>COUNT(*)</code>,<code>COUNT(1)</code>,<code>COUNT（字段）</code>哪个效率更高？</h2><p>如果是 MyISAM 存储引擎，三者效率都一样，因为这个引擎有一个字段专门存多少行的。<br>如果是 InnoDB 存储引擎，则效率：<code>COUNT(1)</code>&#x3D;<code>COUNT(*)</code>&gt;<code>COUNT（字段）</code>, 因为这个引擎会自动找 len 最短的去 count, 指定了字段没法优化。</p>
<hr>
<h2 id="这是结论：GROUP-BY-语句中，select-字段中只能存在除聚合函数的-GROUP-BY-字段。否则查出来的数据没有意义。"><a href="#这是结论：GROUP-BY-语句中，select-字段中只能存在除聚合函数的-GROUP-BY-字段。否则查出来的数据没有意义。" class="headerlink" title="这是结论：GROUP BY 语句中，select 字段中只能存在除聚合函数的 GROUP BY 字段。否则查出来的数据没有意义。"></a>这是结论：GROUP BY 语句中，select 字段中只能存在除聚合函数的 GROUP BY 字段。否则查出来的数据没有意义。</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">正确</span><br><span class="line"><span class="keyword">select</span> job_id j,<span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> j;</span><br><span class="line"></span><br><span class="line">也正确</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> job_id;</span><br><span class="line"></span><br><span class="line">错误：</span><br><span class="line"><span class="keyword">select</span> employee_id,<span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> job_id;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="HAVING-必须在-GROUP-BY-的后面，使用-HAVING-的前提是有-GROUP-BY"><a href="#HAVING-必须在-GROUP-BY-的后面，使用-HAVING-的前提是有-GROUP-BY" class="headerlink" title="HAVING 必须在 GROUP BY 的后面，使用 HAVING 的前提是有 GROUP BY"></a>HAVING 必须在 GROUP BY 的后面，使用 HAVING 的前提是有 GROUP BY</h2><hr>
<h2 id="where-和-having-效率区别，以及使用区别"><a href="#where-和-having-效率区别，以及使用区别" class="headerlink" title="where 和 having 效率区别，以及使用区别"></a>where 和 having 效率区别，以及使用区别</h2><p>没有聚合函数的情况下最好用 where 先判断条件。然后再分组再用 having 去操作条件，不然会 把没用的数据也给分组，浪费性能。<br>where 后面不能跟聚合函数，因为你就一组你没分组聚合按照条件没有意义啊。但是 HAVING 可以因为你分了很多个组所以就可以筛选。</p>
<hr>
<h2 id="mysql-执行顺序"><a href="#mysql-执行顺序" class="headerlink" title="mysql 执行顺序"></a>mysql 执行顺序</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> 这里后执行</span><br><span class="line"><span class="comment">------------</span></span><br><span class="line"><span class="keyword">JOIN</span>        这里先执行，且按顺序执行</span><br><span class="line"><span class="keyword">ON</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>    很奇怪的是这里可以用 <span class="keyword">SELECT</span> 字段的别名</span><br><span class="line"><span class="keyword">HAVING</span>      <span class="keyword">HAVING</span> 也能用，按道理执行顺序是不可以的</span><br><span class="line">            这是 MYSQL 可以的，特例这是。</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>    这里最后执行</span><br><span class="line">LIMIT</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="GROUP-BY-和-HAVING-可以使用-select-字段的别名，这是-MySQL-特殊的，按道理来说也就是执行顺序来说是不可以使用别名的。这是-MySQL-为了偷懒，我认为。"><a href="#GROUP-BY-和-HAVING-可以使用-select-字段的别名，这是-MySQL-特殊的，按道理来说也就是执行顺序来说是不可以使用别名的。这是-MySQL-为了偷懒，我认为。" class="headerlink" title="GROUP BY 和 HAVING 可以使用 select 字段的别名，这是 MySQL 特殊的，按道理来说也就是执行顺序来说是不可以使用别名的。这是 MySQL 为了偷懒，我认为。"></a>GROUP BY 和 HAVING 可以使用 select 字段的别名，这是 MySQL 特殊的，按道理来说也就是执行顺序来说是不可以使用别名的。这是 MySQL 为了偷懒，我认为。</h2><hr>
<h2 id="MYSQL-中不能聚合套聚合，这是他的缺陷，但是-ORACLE-可以"><a href="#MYSQL-中不能聚合套聚合，这是他的缺陷，但是-ORACLE-可以" class="headerlink" title="MYSQL 中不能聚合套聚合，这是他的缺陷，但是 ORACLE 可以"></a>MYSQL 中不能聚合套聚合，这是他的缺陷，但是 ORACLE 可以</h2><hr>
<h2 id="子查询和自连接相对来说，自连接好一些，因为子查询是通过未知表进行查询的条件判断，而自连接是通过已知的自身数据进行条件判断。因此大部分-DBMS-在自连接处理了优化"><a href="#子查询和自连接相对来说，自连接好一些，因为子查询是通过未知表进行查询的条件判断，而自连接是通过已知的自身数据进行条件判断。因此大部分-DBMS-在自连接处理了优化" class="headerlink" title="子查询和自连接相对来说，自连接好一些，因为子查询是通过未知表进行查询的条件判断，而自连接是通过已知的自身数据进行条件判断。因此大部分 DBMS 在自连接处理了优化"></a>子查询和自连接相对来说，自连接好一些，因为子查询是通过未知表进行查询的条件判断，而自连接是通过已知的自身数据进行条件判断。因此大部分 DBMS 在自连接处理了优化</h2><hr>
<h2 id="mysql-创建表没指明-charset-就用数据库的charset。数据库是可以charset的哦-charset-是-character-set-的简写"><a href="#mysql-创建表没指明-charset-就用数据库的charset。数据库是可以charset的哦-charset-是-character-set-的简写" class="headerlink" title="mysql 创建表没指明 charset 就用数据库的charset。数据库是可以charset的哦(charset 是 character set 的简写)"></a>mysql 创建表没指明 charset 就用数据库的charset。数据库是可以charset的哦(charset 是 character set 的简写)</h2><hr>
<h2 id="mysql-创建表有两种方式"><a href="#mysql-创建表有两种方式" class="headerlink" title="mysql 创建表有两种方式"></a>mysql 创建表有两种方式</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 一个一个创建</span></span><br><span class="line"><span class="keyword">create table</span> t1</span><br><span class="line">(</span><br><span class="line">    id   <span class="type">int</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> t1</span><br><span class="line"><span class="keyword">values</span> (<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>),</span><br><span class="line">       (<span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create table</span> t2 <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> t1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="DDL-DML-DCL-TCL"><a href="#DDL-DML-DCL-TCL" class="headerlink" title="DDL,DML,DCL,TCL"></a>DDL,DML,DCL,TCL</h2><ul>
<li><p>DDL:Data Definition Language (DDL)数据库定义语句</p>
<blockquote>
<p>用来创建数据库中的表、索引、视图、存储过程、触发器等<br>CREATE,ALTER,DROP,TRUNCATE,COMMENT,RENAME</p>
</blockquote>
</li>
<li><p>DML:Data Manipulation Language (DML)数据操纵语句</p>
<blockquote>
<p>用来查询、添加、更新、删除等<br>SELECT,INSERT,UPDATE,DELETE,MERGE,CALL,EXPLAIN PLAN,LOCK TABLE</p>
</blockquote>
</li>
<li><p>DCL:Data Control Language (DCL)数据控制语句</p>
<blockquote>
<p>用于授权&#x2F;撤销数据库及其字段的权限<br>GRANT,REVOKE。</p>
</blockquote>
</li>
<li><p>TCL:Transaction Control Language (TCL)事务控制语句</p>
<blockquote>
<p>用于控制事务<br>COMMIT,ROLLBACK,SAVEPOINT,SET TRANSACTION</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="DROP-表结构和表数据都会删除，释放表空间"><a href="#DROP-表结构和表数据都会删除，释放表空间" class="headerlink" title="DROP 表结构和表数据都会删除，释放表空间"></a>DROP 表结构和表数据都会删除，释放表空间</h2><hr>
<h2 id="TRUNCATE-只会清空表数据，但是保留表结构"><a href="#TRUNCATE-只会清空表数据，但是保留表结构" class="headerlink" title="TRUNCATE 只会清空表数据，但是保留表结构"></a>TRUNCATE 只会清空表数据，但是保留表结构</h2><hr>
<h2 id="TRANCATE-是DDL语句-DDL语句是没有ROLLBACK指令的，"><a href="#TRANCATE-是DDL语句-DDL语句是没有ROLLBACK指令的，" class="headerlink" title="TRANCATE 是DDL语句,DDL语句是没有ROLLBACK指令的，"></a>TRANCATE 是DDL语句,DDL语句是没有ROLLBACK指令的，</h2><hr>
<h2 id="ROLLBACK-只可以回滚到上一次的提交。仅仅是上一次次。DDL-没有ROLLBACK指令，你可以理解为DDL会自带一个commit，他执行完后会立刻马上会自动提交，所以你下面的ROLLBACK就到他下面的commit就打止了。"><a href="#ROLLBACK-只可以回滚到上一次的提交。仅仅是上一次次。DDL-没有ROLLBACK指令，你可以理解为DDL会自带一个commit，他执行完后会立刻马上会自动提交，所以你下面的ROLLBACK就到他下面的commit就打止了。" class="headerlink" title="ROLLBACK 只可以回滚到上一次的提交。仅仅是上一次次。DDL 没有ROLLBACK指令，你可以理解为DDL会自带一个commit，他执行完后会立刻马上会自动提交，所以你下面的ROLLBACK就到他下面的commit就打止了。"></a>ROLLBACK 只可以回滚到上一次的提交。仅仅是上一次次。DDL 没有ROLLBACK指令，你可以理解为DDL会自带一个commit，他执行完后会立刻马上会自动提交，所以你下面的ROLLBACK就到他下面的commit就打止了。</h2><hr>
<h2 id="TRUNCATE-和-DELETE-FROM-异同点"><a href="#TRUNCATE-和-DELETE-FROM-异同点" class="headerlink" title="TRUNCATE 和 DELETE FROM 异同点"></a>TRUNCATE 和 DELETE FROM 异同点</h2><ul>
<li>相同：<ul>
<li>都可以实现对数据的删除，同时保留表结构</li>
</ul>
</li>
<li>不同:<ul>
<li>DELETE FROM 是DML，TRUNCATE是DDL</li>
<li>TRUNCATE TABLE 不能回滚！！！</li>
<li>注意：COMMIT 在DML中是默认开启的，即set autocommit&#x3D;true，这是默认开启的，所以delete默认也不能回滚，只能设置为false才能回滚。</li>
<li>但是TRUNCATE不会触发TRIGGER（日志记录）所以是个危险操作尽量不用，虽然效率高。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="MySQL-8-0-有DDL的原子性，但是5-7没有。即："><a href="#MySQL-8-0-有DDL的原子性，但是5-7没有。即：" class="headerlink" title="MySQL 8.0 有DDL的原子性，但是5.7没有。即："></a>MySQL 8.0 有DDL的原子性，但是5.7没有。即：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- mysql8.0</span><br><span class="line">CREATE TABLE table1();</span><br><span class="line">DROP table1,table2;</span><br><span class="line">-- 因为table2不存在，所以不会成功。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="MyBatis-用-的情况，用到表名做参数的时候就用这个。"><a href="#MyBatis-用-的情况，用到表名做参数的时候就用这个。" class="headerlink" title="MyBatis 用${}的情况，用到表名做参数的时候就用这个。"></a>MyBatis 用${}的情况，用到表名做参数的时候就用这个。</h2><hr>
<h2 id="INSERT-添加可以添加查询结果："><a href="#INSERT-添加可以添加查询结果：" class="headerlink" title="INSERT 添加可以添加查询结果："></a>INSERT 添加可以添加查询结果：</h2><ul>
<li>但是要注意添加的字段要和查询的字段对应。</li>
<li>字段的范围也要对应,对应或者大于。如果里面的数据没有那么长，那可以。但是最好还是大于等于。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT into emp(id,name)</span><br><span class="line">select id,name </span><br><span class="line">from emp2;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="UPDATE-要接条件，不然会更新整个表，DELETE-FROM-TABLE-也是，要注意了。"><a href="#UPDATE-要接条件，不然会更新整个表，DELETE-FROM-TABLE-也是，要注意了。" class="headerlink" title="UPDATE 要接条件，不然会更新整个表，DELETE FROM TABLE 也是，要注意了。"></a>UPDATE 要接条件，不然会更新整个表，DELETE FROM TABLE 也是，要注意了。</h2><hr>
<h2 id="小数类型建议为DECIMAL，如果字段为非负数，建议为UNSIGNED"><a href="#小数类型建议为DECIMAL，如果字段为非负数，建议为UNSIGNED" class="headerlink" title="小数类型建议为DECIMAL，如果字段为非负数，建议为UNSIGNED"></a>小数类型建议为DECIMAL，如果字段为非负数，建议为UNSIGNED</h2><hr>
<h2 id="CHAR-是固定长度的-VARCHAR-是可变长度的。超过varchar最大值，用TEXT，但是TEXT-很大，所以建议独立一张表出来"><a href="#CHAR-是固定长度的-VARCHAR-是可变长度的。超过varchar最大值，用TEXT，但是TEXT-很大，所以建议独立一张表出来" class="headerlink" title="CHAR 是固定长度的,VARCHAR 是可变长度的。超过varchar最大值，用TEXT，但是TEXT 很大，所以建议独立一张表出来"></a>CHAR 是固定长度的,VARCHAR 是可变长度的。超过varchar最大值，用TEXT，但是TEXT 很大，所以建议独立一张表出来</h2><hr>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ul>
<li>not null</li>
<li>unique</li>
<li>check 5.7没有,8.0有，</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table test01(</span><br><span class="line">id int,</span><br><span class="line">last_name varchar(15)，</span><br><span class="line">salary decimal(10,2) check(salary&gt;2000))</span><br></pre></td></tr></table></figure>
<ul>
<li>DEFAULT</li>
</ul>
<hr>
<h2 id="行级约束，表级约束"><a href="#行级约束，表级约束" class="headerlink" title="行级约束，表级约束"></a>行级约束，表级约束</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table test1(</span><br><span class="line">id INT UNIQUE, -- 行级约束</span><br><span class="line">last_name VARCHAR(15),</span><br><span class="line">email VARCHAR(15),</span><br><span class="line">CONSTRAINT uk_test1_email UNIQUE(emial) -- 表级约束</span><br><span class="line">-- NOT NULL 没有表级约束</span><br><span class="line">)</span><br><span class="line">-- 这里给约束命名了，默认不给的话是和列名相同的</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="UNIQUE-可以有null，但是可以有多个null，"><a href="#UNIQUE-可以有null，但是可以有多个null，" class="headerlink" title="UNIQUE 可以有null，但是可以有多个null，"></a>UNIQUE 可以有null，但是可以有多个null，</h2><hr>
<h2 id="mysql-可以对表指定不同的存储引擎，你可以在show-create-table-XXX-看到后面，engin-XXX；外键约束不能跨引擎，btw，基本不用外键约束。在代码应用层解决"><a href="#mysql-可以对表指定不同的存储引擎，你可以在show-create-table-XXX-看到后面，engin-XXX；外键约束不能跨引擎，btw，基本不用外键约束。在代码应用层解决" class="headerlink" title="mysql 可以对表指定不同的存储引擎，你可以在show create table XXX 看到后面，engin&#x3D;XXX；外键约束不能跨引擎，btw，基本不用外键约束。在代码应用层解决"></a>mysql 可以对表指定不同的存储引擎，你可以在show create table XXX 看到后面，engin&#x3D;XXX；外键约束不能跨引擎，btw，基本不用外键约束。在代码应用层解决</h2><hr>
<h2 id="UTF8mb4和UTF8mb3"><a href="#UTF8mb4和UTF8mb3" class="headerlink" title="UTF8mb4和UTF8mb3"></a>UTF8mb4和UTF8mb3</h2><ul>
<li>utf8mb3:1~3个字节表示字符</li>
<li>utf8mb4:1~4个字节表示字符<br>mysql utf8 默认是utf8mb3。utf8mb4用于emoji表情一般；</li>
</ul>
<hr>
<h2 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h2><ul>
<li>SQL语句-&gt;查询缓存-&gt;解析器-&gt;优化器-&gt;执行器-&gt;找存储引擎API看用的哪个engine</li>
</ul>
<hr>
<h2 id="InnoDB-的好处"><a href="#InnoDB-的好处" class="headerlink" title="InnoDB 的好处"></a>InnoDB 的好处</h2><ul>
<li>你可以<code>show engines</code>看到，支持事物和分布式</li>
</ul>
<hr>
<h2 id="MyISAM-和-InnoDB"><a href="#MyISAM-和-InnoDB" class="headerlink" title="MyISAM 和 InnoDB"></a>MyISAM 和 InnoDB</h2><table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>外键</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>事物</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>行表锁</td>
<td>表锁，即使操作一条记录会锁住整个表，不适合高并发</td>
<td>行锁</td>
</tr>
<tr>
<td>缓存</td>
<td>只缓存索引，不缓存真实数据,增加查询很多优选选</td>
<td>缓存和数据都是真实数据，都是 .idb 结尾的文件,使用的时候会更占据内存 ,</td>
</tr>
<tr>
<td>关注点</td>
<td>性能：节省资源，消耗少，简单业务</td>
<td>事物：并发写，事物，更大资源</td>
</tr>
<tr>
<td>默认安装</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>默认使用</td>
<td>No(MySQL 5.5 之前 Yes)</td>
<td>Yes</td>
</tr>
<tr>
<td>选择</td>
<td>增加查询多用MyISAM</td>
<td>更新删除多优选选InnoDB</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>Oracle 中 substr 和 instr 函数简单用法</title>
    <url>/2021/08/07/Oracle-%E4%B8%AD-substr-%E5%92%8C-instr-%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<!-- vim-markdown-toc Marked -->

<ul>
<li><a href="#oracle-%E7%9A%84-substr-%E5%92%8C-instr-%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95">Oracle 的 substr 和 instr 函数简单用法</a><ul>
<li><a href="#substr-%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95">substr 函数简单用法</a><ul>
<li><a href="#substr-%E4%BB%8B%E7%BB%8D">substr 介绍</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">测试代码</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87">测试图片</a></li>
</ul>
</li>
<li><a href="#instr-%E5%87%BD%E6%95%B0%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95">instr 函数的简单用法</a><ul>
<li><a href="#instr-%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D%EF%BC%9A">instr 函数介绍：</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">测试代码</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87">测试图片</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a><ul>
<li><a href="#%E5%AE%9E%E4%BE%8B%E5%9B%BE%E7%89%87">实例图片</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- vim-markdown-toc -->

<h1 id="Oracle-的-substr-和-instr-函数简单用法"><a href="#Oracle-的-substr-和-instr-函数简单用法" class="headerlink" title="Oracle 的 substr 和 instr 函数简单用法"></a>Oracle 的 substr 和 instr 函数简单用法</h1><h2 id="substr-函数简单用法"><a href="#substr-函数简单用法" class="headerlink" title="substr 函数简单用法"></a>substr 函数简单用法</h2><h3 id="substr-介绍"><a href="#substr-介绍" class="headerlink" title="substr 介绍"></a>substr 介绍</h3><blockquote>
<p>/*</p>
<p>* 截取字符串（字符串位置从 1 开始，而不是从 0 开始）</p>
<p>* @param string 源字符串</p>
<p>* @param position 检索位置，参数为正时，从左向右检索，参数为负时，从右向左检索</p>
<p>* @param substring_length 要截取的长度，可省略（默认从 position 位开始截取全部）, 值小于 1 时返回空字符串</p>
<p>* @return 返回截取的字符串</p>
<p>*/</p>
</blockquote>
<p><strong><code>substr(string, position, substring_length);</code></strong></p>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> substr(<span class="string">&#x27;Hello World&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>)  c1<span class="comment">-- 返回结果为 &#x27;H&#x27;  * 从字符串第一个字符开始截取长度为 1 的字符串</span></span><br><span class="line">     , substr(<span class="string">&#x27;Hello World&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>)  c2<span class="comment">-- 返回结果为 &#x27;H&#x27;  *0 和 1 都是表示截取的开始位置为第一个字符</span></span><br><span class="line">     , substr(<span class="string">&#x27;Hello World&#x27;</span>, <span class="number">2</span>, <span class="number">4</span>)  c3<span class="comment">-- 返回结果为 &#x27;ello&#x27;</span></span><br><span class="line">     , substr(<span class="string">&#x27;Hello World&#x27;</span>, <span class="number">-3</span>, <span class="number">3</span>) c4<span class="comment">-- 返回结果为 &#x27;rld&#x27; * 负数 (-i) 表示截取的开始位置为字符串右端向左数第 i 个</span></span><br><span class="line"><span class="keyword">from</span> PRPDKIND;</span><br></pre></td></tr></table></figure>

<h3 id="测试图片"><a href="#测试图片" class="headerlink" title="测试图片"></a>测试图片</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/08/07/Oracle-%E4%B8%AD-substr-%E5%92%8C-instr-%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/Snipaste_2021-09-07_15-28-28.jpg"
                        alt="PANGU_DISABLE"
                 ></p>
<hr>
<h2 id="instr-函数的简单用法"><a href="#instr-函数的简单用法" class="headerlink" title="instr 函数的简单用法"></a>instr 函数的简单用法</h2><h3 id="instr-函数介绍："><a href="#instr-函数介绍：" class="headerlink" title="instr 函数介绍："></a>instr 函数介绍：</h3><blockquote>
<p>/*</p>
<p>* 返回子字符串在源字符串中的位置（字符串位置从 1 开始，而不是从 0 开始）</p>
<p>* @param string 源字符串</p>
<p>* @param substring 子字符串</p>
<p>* @param position 检索位置，可省略（默认为 1), 参数为正时，从左向右检索，参数为负时，从右向左检索</p>
<p>* @param occurrence 检索子字符串出现的次数，可省略（默认为 1), 值只能为正整数，否则会报错</p>
<p>* @return 返回子字符串在源字符串中出现的位置（没找到返回 0）</p>
<p>*/</p>
</blockquote>
<p><strong><code>instr(string, substring, position, occurrence)</code></strong></p>
<h3 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> INSTR(<span class="string">&#x27;hello world&#x27;</span>, <span class="string">&#x27;l&#x27;</span>) <span class="keyword">FROM</span> DUAL;           <span class="comment">-- 结果：3</span></span><br><span class="line"><span class="keyword">SELECT</span> INSTR(<span class="string">&#x27;hello world&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="number">5</span>) <span class="keyword">FROM</span> DUAL;        <span class="comment">-- 结果：10</span></span><br><span class="line"><span class="keyword">SELECT</span> INSTR(<span class="string">&#x27;hello world&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="number">-1</span>) <span class="keyword">FROM</span> DUAL;       <span class="comment">-- 结果：10</span></span><br><span class="line"><span class="keyword">SELECT</span> INSTR(<span class="string">&#x27;hello world&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="number">2</span>, <span class="number">2</span>) <span class="keyword">FROM</span> DUAL;     <span class="comment">-- 结果：4</span></span><br><span class="line"><span class="keyword">SELECT</span> INSTR(<span class="string">&#x27;hello world&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="number">-3</span>, <span class="number">3</span>) <span class="keyword">FROM</span> DUAL;    <span class="comment">-- 结果：0</span></span><br></pre></td></tr></table></figure>

<h3 id="测试图片-1"><a href="#测试图片-1" class="headerlink" title="测试图片"></a>测试图片</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/08/07/Oracle-%E4%B8%AD-substr-%E5%92%8C-instr-%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/Snipaste_2021-09-07_21-16-28.jpg"
                       
                 ></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>可以将 SUBSTR 和 INSTR 结合使用来实现截取字符串中特定字符前后的字符串</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 截取“hello,world”字符串中“,”分隔符之前的字符串</span></span><br><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;hello,world&#x27;</span>, <span class="number">1</span>, INSTR(<span class="string">&#x27;hello,world&#x27;</span>, <span class="string">&#x27;,&#x27;</span>)<span class="number">-1</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;hello,world&#x27;</span>, <span class="number">0</span>, INSTR(<span class="string">&#x27;hello,world&#x27;</span>, <span class="string">&#x27;,&#x27;</span>)<span class="number">-1</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="comment">-- 结果：hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 截取“hello,world”字符串中“,”分隔符之后的字符串</span></span><br><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;hello,world&#x27;</span>, INSTR(<span class="string">&#x27;hello,world&#x27;</span>, <span class="string">&#x27;,&#x27;</span>)<span class="operator">+</span><span class="number">1</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="comment">-- 结果：world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 截取“hello,world,HH”字符串中第 1 次出现的“,”字符和第 2 次出现的“,”字符之间的字符串</span></span><br><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;hello,world,HH&#x27;</span>, INSTR(<span class="string">&#x27;hello,world,HH&#x27;</span>, <span class="string">&#x27;,&#x27;</span>,<span class="number">1</span>)<span class="operator">+</span><span class="number">1</span>, INSTR(<span class="string">&#x27;hello,world,HH&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="number">2</span>)<span class="number">-1</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="comment">-- 结果：world</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;hello,world&#x27;</span>, <span class="number">1</span>, INSTR(<span class="string">&#x27;hello,world&#x27;</span>, <span class="string">&#x27;,&#x27;</span>) <span class="operator">-</span> <span class="number">1</span>) C1,<span class="comment">-- 结果：hello</span></span><br><span class="line">       SUBSTR(<span class="string">&#x27;hello,world&#x27;</span>, <span class="number">0</span>, INSTR(<span class="string">&#x27;hello,world&#x27;</span>, <span class="string">&#x27;,&#x27;</span>) <span class="operator">-</span> <span class="number">1</span>) C2,<span class="comment">-- 结果：hello</span></span><br><span class="line">       SUBSTR(<span class="string">&#x27;hello,world&#x27;</span>, INSTR(<span class="string">&#x27;hello,world&#x27;</span>, <span class="string">&#x27;,&#x27;</span>) <span class="operator">+</span> <span class="number">1</span>)    C3,<span class="comment">-- 结果：world</span></span><br><span class="line">       SUBSTR(<span class="string">&#x27;hello,world,HH&#x27;</span>, INSTR(<span class="string">&#x27;hello,world,HH&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="number">1</span>) <span class="operator">+</span> <span class="number">1</span>, INSTR(<span class="string">&#x27;hello,world,HH&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="number">2</span>) <span class="operator">-</span> <span class="number">1</span>) C4</span><br><span class="line">       <span class="comment">-- 截取“hello,world,HH”字符串中第 1 次出现的“,”字符和第 2 次出现的“,”字符之间的字符串 -- 结果：world</span></span><br><span class="line"><span class="keyword">FROM</span> DUAL;</span><br></pre></td></tr></table></figure>

<h3 id="实例图片"><a href="#实例图片" class="headerlink" title="实例图片"></a>实例图片</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/08/07/Oracle-%E4%B8%AD-substr-%E5%92%8C-instr-%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/Snipaste_2021-09-07_21-30-19.jpg"
                       
                 ></p>
]]></content>
  </entry>
  <entry>
    <title>lombok 注解，绝中绝，顶上顶！</title>
    <url>/2021/12/20/lombok-%E6%B3%A8%E8%A7%A3%EF%BC%8C%E7%BB%9D%E4%B8%AD%E7%BB%9D%EF%BC%8C%E9%A1%B6%E4%B8%8A%E9%A1%B6%EF%BC%81/</url>
    <content><![CDATA[<h1 id="lombok-注解，绝中绝，顶上顶！"><a href="#lombok-注解，绝中绝，顶上顶！" class="headerlink" title="lombok 注解，绝中绝，顶上顶！"></a>lombok 注解，绝中绝，顶上顶！</h1><blockquote>
<p>可以在编译后的 class 文件来看出不同。不过有时候修改注解后，项目并不会自动编译，此时在 maven 手动编译即可看出效果。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/12/20/lombok-%E6%B3%A8%E8%A7%A3%EF%BC%8C%E7%BB%9D%E4%B8%AD%E7%BB%9D%EF%BC%8C%E9%A1%B6%E4%B8%8A%E9%A1%B6%EF%BC%81/Snipaste_2021-12-20_10-24-14.jpg"
                        alt="PANGU_DISABLE"
                 ></p>
<ul>
<li>本文主要记录 lombok 可能会遇到的一些坑和一些注解解释</li>
</ul>
</blockquote>
<h2 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h2><p>@Data</p>
<p> &#x3D; @Getter + @Setter + @ToString + @EqualsAndHashCode</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>@Data 里面没有构造函数。即如果没有写自定义的构造函数那就是 Java 自带的无参构造函数。如果有自定义的构造函数那就是只有写了的构造函数，没有无参的了</li>
<li>由上一点，所以一般如果加了 @AllArgsConstructor, 那应该加个 @NoArgsConstructor.</li>
</ul>
<h2 id="EqualsAndHashCode"><a href="#EqualsAndHashCode" class="headerlink" title="@EqualsAndHashCode"></a>@EqualsAndHashCode</h2><p>@EqualsAndHashCode , 该注解是按照整个对象去重写 Equals 和 HashCode. 有时候业务场景是根据 ID 去判断是否重复，所以可以使用 @EqualsAndHashCode(of &#x3D; {“id”})</p>
<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><blockquote>
<ul>
<li>没加 @EqualsAndHashCode(of &#x3D; {“id”})<br><img  
                       lazyload
                       alt="image"
                       data-src="/2021/12/20/lombok-%E6%B3%A8%E8%A7%A3%EF%BC%8C%E7%BB%9D%E4%B8%AD%E7%BB%9D%EF%BC%8C%E9%A1%B6%E4%B8%8A%E9%A1%B6%EF%BC%81/Snipaste_2021-12-20_10-52-03.jpg"
                        alt="PANGU_DISABLE"
                 ></li>
<li>加了 @EqualsAndHashCode(of &#x3D; {“id”})<br><img  
                       lazyload
                       alt="image"
                       data-src="/2021/12/20/lombok-%E6%B3%A8%E8%A7%A3%EF%BC%8C%E7%BB%9D%E4%B8%AD%E7%BB%9D%EF%BC%8C%E9%A1%B6%E4%B8%8A%E9%A1%B6%EF%BC%81/Snipaste_2021-12-20_10-50-59.jpg"
                        alt="PANGU_DISABLE"
                 ></li>
</ul>
</blockquote>
<h2 id="Accessors"><a href="#Accessors" class="headerlink" title="@Accessors"></a>@Accessors</h2><blockquote>
<p>@Accessors 有两个属性</p>
</blockquote>
<h3 id="Accessors-chain-true"><a href="#Accessors-chain-true" class="headerlink" title="@Accessors(chain &#x3D; true)"></a>@Accessors(chain &#x3D; true)</h3><ul>
<li>chain : 链</li>
</ul>
<p>现在链式编程很酷也很方便，å<br> 上该注解后，所有的 set 命令返回的都是 this 即调用对象本身。不加 @Accessors 默认 setXxx() 返回是 void</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/12/20/lombok-%E6%B3%A8%E8%A7%A3%EF%BC%8C%E7%BB%9D%E4%B8%AD%E7%BB%9D%EF%BC%8C%E9%A1%B6%E4%B8%8A%E9%A1%B6%EF%BC%81/Snipaste_2021-12-20_11-00-45.jpg"
                        alt="PANGU_DISABLE"
                 ></p>
<p>因此你可以像这样创建对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>().setId(<span class="number">1</span>).setName(<span class="string">&quot;lucy&quot;</span>).setAge(<span class="number">18</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Accessors-fluent-true"><a href="#Accessors-fluent-true" class="headerlink" title="@Accessors(fluent &#x3D; true)"></a>@Accessors(fluent &#x3D; true)</h3><ul>
<li>fluent : 流利的</li>
</ul>
<p>这个命令更牛逼，set get 都给你整没了。直接就是首字母小写的变量名。有参数的就是 set，没参数的就是 get</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/12/20/lombok-%E6%B3%A8%E8%A7%A3%EF%BC%8C%E7%BB%9D%E4%B8%AD%E7%BB%9D%EF%BC%8C%E9%A1%B6%E4%B8%8A%E9%A1%B6%EF%BC%81/Snipaste_2021-12-20_11-12-55.jpg"
                        alt="PANGU_DISABLE"
                 ><br>因此你可以像这样使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>().id(<span class="number">1</span>).name(<span class="string">&quot;lucy&quot;</span>).age(<span class="number">18</span>);</span><br><span class="line">System.out.println(student.id() + student.name() + student.age());</span><br></pre></td></tr></table></figure>

<h2 id="Builder"><a href="#Builder" class="headerlink" title="@Builder"></a>@Builder</h2><blockquote>
<p>一种设计模式：建造者模式</p>
</blockquote>
<h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><ul>
<li>@Builder 会增加全参构造函数，那他就没有默认的无参构造了，得注意。所以得加上 @NoArgsConstructor，但是加上后 @Builder 默认的全参构造就没了，会报错，所以都得加上 @NoArgsConstructor,@AllArgsConstructor.</li>
<li>并且内部类那个成员变量会覆盖掉他父类的成员变量的默认值，所以默认值会失效。<br><img  
                       lazyload
                       alt="image"
                       data-src="/2021/12/20/lombok-%E6%B3%A8%E8%A7%A3%EF%BC%8C%E7%BB%9D%E4%B8%AD%E7%BB%9D%EF%BC%8C%E9%A1%B6%E4%B8%8A%E9%A1%B6%EF%BC%81/Snipaste_2021-12-20_15-11-14.jpg"
                        alt="PANGU_DISABLE"
                 ></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前在 <a class="link"   href="https://okhttps.ejlchina.com/v3/getstart.html#%E6%9E%84%E5%BB%BA-http" >OkHttps<i class="fas fa-external-link-alt"></i></a> 里面看到过 builder() 这玩意，现在知道了是一种设计模式。lombok 也有用到。但是 @Builder 会更消耗内存吧，静态内部类还没用就直接整上内存里了，好处应该是更直观一点。还是推荐如果喜欢流式的就用 <code>@Accessors(fluent = true)</code> , 喜欢链式编程 setXxx() 就用 <code>@Accessors(chain = true)</code></p>
]]></content>
  </entry>
  <entry>
    <title>nginx 代理妙用</title>
    <url>/2023/06/23/nginx-%E4%BB%A3%E7%90%86%E5%A6%99%E7%94%A8/</url>
    <content><![CDATA[<p>工作时测试环境和本地环境不相通，得发布或者同步代码到本地启动服务才能调试。<br>我主要是为了调试表单接口，一些请求的数据的保存、查询。我可不想自己塞或者复制链接弄到API工具里去调试本地。</p>
<p>于是有了这篇文章：</p>
]]></content>
  </entry>
  <entry>
    <title>ssh 能秘钥登录，但是 git 却不能</title>
    <url>/2024/06/23/ssh%20%E8%83%BD%E7%A7%98%E9%92%A5%E7%99%BB%E5%BD%95%EF%BC%8C%E4%BD%86%E6%98%AF%20git%20%E5%8D%B4%E4%B8%8D%E8%83%BD/</url>
    <content><![CDATA[<p>ssh 配置了且能秘钥登录，但是git提交代码要密码</p>
<h1 id="排查问题流程"><a href="#排查问题流程" class="headerlink" title="排查问题流程"></a>排查问题流程</h1><ol>
<li>重新配置公钥私钥</li>
<li>ssh-agent 管理</li>
</ol>
<p><code>1. 2.</code> 都试过了，有没有可能是命令本身的问题？</p>
<p>找到这篇文章：<a class="link"   href="https://github.com/orgs/community/discussions/28961#discussioncomment-3363250" >https://github.com/orgs/community/discussions/28961#discussioncomment-3363250<i class="fas fa-external-link-alt"></i></a></p>
<p>大致是说：git 命令可能不是用的 windows 的 ssh，git 命令需要指定 windows 的 ssh 才会去用里面的私钥</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">git config --global core.sshCommand C:/Windows/System32/OpenSSH/ssh.exe </span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>个人简历</title>
    <url>/2025/02/26/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/</url>
    <content><![CDATA[<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>简历</title>
</head>
<body>
<div class="markdown-body indigo square">
<img   align="right" width="180" height="225"  
                       lazyload
                       alt="image"
                       data-src="https://i.postimg.cc/jdXpMshG/20250101.jpg"
                         class="medium-zoom-image" title="" style=""
                 >
    <h2 class="do_not_show_underline">联系方式</h2>
    <ul>
        <li>手机：19176966686</li>
        <li>Email：<a class="link"   href="mailto:m18390923477@gmail.com" >m18390923477@gmail.com<i class="fas fa-external-link-alt"></i></a></li>
        <li>QQ/ 微信号：798953052</li>
    </ul>
    <h2> 个人信息 </h2>
    <ul>
        <li><strong>于磊</strong> / 男 / 26 岁</li>
        <li><strong>本科</strong> / 湖南理工学院</li>
        <li>博客：<a class="link"   href="https://leijiba.cn" >https://leijiba.cn<i class="fas fa-external-link-alt"></i></a></li>
        <li>期望职位：Java 后端工程师</li>
        <li>工作经验： <strong>三年</strong>
        <ul>
            <li>万达信息股份有限公司   (2022 年 5 月 - 2024 年 6 月)</li>
            <li>中科软科技股份有限公司 (2021 年 6 月 - 2022 年 4 月)</li>
        </ul>
        </li>
    </ul>
    <hr>
    <h2>专业技能</h2>
    <ul>
        <li>掌握 Java 基础，集合，stream 流等</li>
        <li>掌握 Vim、Git、IDEA 等工具使用</li>
        <li>能够使用 Spring，SpringMVC，MyBatis-Plus 等开源框架进行开发</li>
        <li>能够使用 SpringBoot + SpringCloud 进行微服务开发</li>
        <li>熟悉主流关系型数据库 Mysql，oracle， 掌握 sql 语法</li>
        <li>熟练 Linux 系统，熟悉项目的搭建和常用命令，熟悉 Nginx 反向代理、负载均衡配置</li>
        <li>熟悉 Jenkins ，docker CI/CD 流程</li>
        <li>熟悉微服务架构体系：Eureka，Nacos 服务注册，Feign API 不同模块间调用方式，以及项目设计模式</li>
    </ul>
    <hr>
    <h2>项目经验</h2>
    <h3>深圳数字人社 - 深圳公共就业项目 (2023 年 1 月 - 2024 年 6 月)</h3>
    <strong>项目介绍：</strong>
    <blockquote>
           <p>项目提供平台来帮助深圳工作的人员或者单位，根据一些政府的激励政策满足一定要求可享受对应的补贴。</p>
        <p>本项目是一个重构项目，原来是独立的项目，现需要迁移到一体化平台作为入口进行统一管理全称为深圳数字人社。采用新的架构设计，数据库等国产化。我主要负责深圳市的工作就业相关的补助。例如：家政企业备案、家政企业社保补贴、高校毕业生、困难人员求职创业补贴、港澳台实习青年补贴、吸纳脱贫人员、吸纳退役军人、等等一系列补贴</p>
    </blockquote>
    <p><strong>开发技术：</strong> SpringBoot + MyBatis-Plus + Nacos + Redis</p>
    <p><strong>责任描述：</strong> 第三方接口统一对接(工商局、教育部、公安户籍、脱贫人员信息等等)，家政企业备案、家政企业社保补贴、困难人员求职创业补贴、港澳台实习青年补贴、吸纳脱贫人员等等一系列补贴、以及处理部分旧系统的工单。</p>
    <ul>
        <li>对接第三方接口，提供切面日志记录调用状态，配置秘钥以区分生产测试环境。</li>
        <li>缓存调用频繁的接口，提高测试通过率。对接第三方接口经常性出现超时现象，设计兼容性强，可动态配置的注解，容错性强，方便不同环境下调试。</li>
        <li>补贴续发功能：社保补贴续发要求是只需一次申请后续根据社保是否缴纳自动发放补贴。需求社保补贴一次性能申请 6 个月，后续由系统判断逻辑满足要求的情况下系统自动申报给与补贴。设计续发日志表，设置待续发，续发失败，续发终止标识区分不同业务数据办理情况。</li>
        <li>枚举策略模式：因业务现由经办一体化平台办理，故由对方传入流水号以及类型编码至我方系统接口进行保存。设计类枚举，类中有对应业务编码以及接口类型。因此省去大量 if else 判断，只需遍历枚举，业务类型编码走不同业务的的保存、更新逻辑。增强代码健壮性，减少出错概率。</li>
        <li>一些网络环境问题(本地环境不能和中台前端环境联调)，使用 nginx 代理处理，提高团队开发和效率。</li>
    </ul>
    <hr>
    <h3>深圳社保 - 深圳待遇项目（失业养老工伤待遇）(2022 年 5 月- 2023 年 1 月)</h3>
    <strong>项目介绍：</strong>
    <blockquote>
        <p>深圳社保项目分为征收缴纳社保和享受社保待遇。该项目属于后者又称为：深圳待遇项目。</p>
        <p>留工培训补贴是疫情期间，为了留住工人降低企业压力而根据其为员工缴纳的社保记录给与每人 500 元的企业补助。该项目主要实现对每个企业社保缴纳人数计算补贴。其中调用到很多第三方接口：社保缴纳情况、公安、企业信用办、工商局企业信息等接口。该项目为内部项目也提供了对外查询接口，最开始为自动给符合要求的单位申报，后续对接经办平台接口供个人来办事大厅办理。具体可搜索深圳人社公众号，留工补贴查看公示发放信息。</p>
    </blockquote>
    <p><strong>开发技术：</strong> Spring + MyBatis + RabbitMQ + JSP</p>
    <p><strong>责任描述：</strong> 为深圳市 80 万家中小微企业匹配条件，符合要求的进行自动申报，不符合要求的进行归档供下次继续申报。该项目执行期间每月社保归档后跑一次数据，并配合需求员导出数据进行抽样比对，最后进行公示，汇总，推送银行发放。配合业务员对比数据准确无误。</p>
    <ul>
        <li>根据项目设计进行数据库结构设计消息队列日志表，业务流程表，业务办结表，归档表，推送银行信息汇总表等；</li>
        <li>代码实现方面把校验和入库操作做成一个消费接口，单位信息作为参数传入接口中。发送给消息队列，减少服务器压力。</li>
        <li>使用 Nginx 反向代理并且实现负载均衡。</li>
        <li>设计单例模式优化公共的校验逻辑。</li>
    </ul>
    <hr>
</div>
</body>
</html>
]]></content>
  </entry>
  <entry>
    <title>五笔</title>
    <url>/2021/09/10/%E4%BA%94%E7%AC%94/</url>
    <content><![CDATA[<h1 id="五笔"><a href="#五笔" class="headerlink" title="五笔"></a>五笔</h1><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/09/10/%E4%BA%94%E7%AC%94/Snipaste_2021-09-10_09-43-31.jpg"
                        alt="PANGU_DISABLE"
                 ></p>
<h1 id="口诀"><a href="#口诀" class="headerlink" title="口诀"></a>口诀</h1><h2 id="字根"><a href="#字根" class="headerlink" title="字根"></a>字根</h2><ul>
<li>横区 </li>
<li><ul>
<li>11(G) 王旁青头戋（兼）五一，</li>
</ul>
</li>
<li><ul>
<li>12(F) 土士二干十寸雨。二一还有革字底</li>
</ul>
</li>
<li><ul>
<li>13(D) 大犬三羊古石厂，</li>
</ul>
</li>
<li><ul>
<li>14(S) 木丁西，</li>
</ul>
</li>
<li><ul>
<li>15(A) 工戈草头右框七。（“右框”即“匚”）o</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>五笔学习之路</title>
    <url>/2021/09/01/%E4%BA%94%E7%AC%94%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="五笔学习之路"><a href="#五笔学习之路" class="headerlink" title="五笔学习之路"></a>五笔学习之路</h1><h2 id="缘故"><a href="#缘故" class="headerlink" title="缘故"></a>缘故</h2><ul>
<li><strong>起因</strong>：最开始由于全拼的击键次数过多，以后工作上经常会用到电脑，遂学习双拼（小鹤双拼）只由声母和韵母组成，任何一个字只需要击键两次，上手容易，熟悉后输入速度上有所提升。但是无法避免的拼音的重码率很高，还是要去候选框去选字。</li>
<li><strong>本质</strong>：由于本人在拼音中 in ing 分不清，而且拼音重码率高，五笔基本上四个键确定一个字，选字的情况比较少，空格就完事，为提高 <del>聊天摸鱼</del> 工作效率，故克服重重困难学习五笔 86 版本。</li>
<li><strong>情感升华</strong>：了解过五笔，对于中国汉字的结构以及五笔的渊源，其博大精深，被五笔输入的魅力所折服。<blockquote>
<p>这篇文章是用双拼打的</p>
</blockquote>
</li>
</ul>
<h2 id="五笔易错集合"><a href="#五笔易错集合" class="headerlink" title="五笔易错集合"></a>五笔易错集合</h2><ul>
<li>女<br>vvvv 键名汉子</li>
</ul>
<p>最后一笔为 横</p>
]]></content>
  </entry>
  <entry>
    <title>免费添加SSL证书</title>
    <url>/2024/06/21/%E5%85%8D%E8%B4%B9%E6%B7%BB%E5%8A%A0SSL%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<p>好久没折腾博客，域名过期了，以前都是照着网上视频走步骤的，现在有了自己的理解</p>
<hr>
<h2 id="为什么要有ssl证书？"><a href="#为什么要有ssl证书？" class="headerlink" title="为什么要有ssl证书？"></a>为什么要有ssl证书？</h2><p>不妨说如果没有证书，浏览器会报不可信任，会弹出这是不安全链接让你是否继续访问。<br>因为你的数据不经过证书加密，会容易被篡改。<br>所以证书就是为了加密，保证发送消息和接收消息的安全。</p>
<h2 id="谁有说服力去管理这么多网站对应的证书？"><a href="#谁有说服力去管理这么多网站对应的证书？" class="headerlink" title="谁有说服力去管理这么多网站对应的证书？"></a>谁有说服力去管理这么多网站对应的证书？</h2><blockquote>
<p>我怎么知道你的证书就是属于你的网站的，得有一个有公信的机构盖章我才相信</p>
</blockquote>
<p>于是乎就有这种机构，好像是要交多少钱类似于保证金的东西，用钱证明实力。<br>这个机构来维护一个证书对应关系类似于 Java 的 Map，比如某某网站对应某个证书。<br>用户请求这个网站就拿这个证书去加密请求，对应的服务端也需要配置私钥去解密，于是加密请求就完成了。<br>用户信任机构的证书，服务端拿私钥也解密成功了，这个世界没有人受伤害。</p>
<h2 id="道理懂了，那证书怎么申请？"><a href="#道理懂了，那证书怎么申请？" class="headerlink" title="道理懂了，那证书怎么申请？"></a>道理懂了，那证书怎么申请？</h2><p>拿钱买或者搞免费的，我的需求只是为了让用户信任我，当你访问 <a class="link"   href="https://leijiba.cn/" >leijiba.cn<i class="fas fa-external-link-alt"></i></a> 的时候,为了让浏览器不弹出这是一个不安全的链接。</p>
<p>我用的是这家 <a class="link"   href="https://freessl.cn/" >freessl.cn<i class="fas fa-external-link-alt"></i></a> 免费的。</p>
<p>流程是：</p>
<ol>
<li>freessl 给你一个特定的<code>主机记录</code>还有<code>记录值</code> ，让你放到域名提供商解析那里解析，需要点时间同步到dns去。</li>
<li>域名提供商那里解析成功了，freessl这边也读到了，证明这就是属于你的域名。</li>
<li>1.2. 这两步就是为了验证这是你的域名，然后 freessl 就会给你公钥私钥。</li>
<li>公钥和私钥放服务器里配置就行了（有特定路径的，不用去死记没用）。客户端浏览器不需要做任何操作，因为别人请求你的域名的时候会从证书机构拿公钥。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>学习&amp;延伸 用 Collections.unmodifiableList</title>
    <url>/2022/02/08/%E5%AD%A6%E4%B9%A0&amp;%E5%BB%B6%E4%BC%B8-%E7%94%A8-Collections-unmodifiableList/</url>
    <content><![CDATA[<h1 id="用-final-修饰的变量，对象属性可以修改的"><a href="#用-final-修饰的变量，对象属性可以修改的" class="headerlink" title="用 final 修饰的变量，对象属性可以修改的"></a>用 final 修饰的变量，对象属性可以修改的</h1><p>我在想有什么方法可以限制修改吗？</p>
<p>于是搜索后了解到有一个 <code>Collections</code> 里有一个内部类 <code>UnmodifiableCollection</code> ;</p>
<ul>
<li><p>UnmodifiableCollection 这个类重写了 Collection 的添加和修改方法，使其调用这个方法会抛 UnsupportedOperationException（不支持的操作异常）</p>
</li>
<li><p>可以用 Collections.unmodifiableList(yourList) 来让你的类不能用添加修改方法</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>当我们不想这个类调用某些方法时，可以重写这个类的方法。</li>
</ul>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ul>
<li>自己照抄思路实现了一下，哈哈，其是就是多态的体现。</li>
<li>为什么不用继承做呢？我觉得效果是一样的.但是是继承只能继承一个，接口能实现多个。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FeatureHaveMouth</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 吃粑粑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eatShit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">FeatureHaveMouth</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eatShit</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog 吃粑粑，Dog 喜欢吃粑粑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainDog</span> <span class="keyword">implements</span> <span class="title class_">FeatureHaveMouth</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eatShit</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog 吃粑粑，Dog 喜欢吃粑粑，但是我是 TrainDog 就算我喜欢吃我也不吃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FeatureHaveMouth <span class="title function_">train</span><span class="params">(FeatureHaveMouth featureHaveMouth)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====Training====&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TrainDog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Test</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFeatHaveMouth</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FeatureHaveMouth</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog.eatShit();</span><br><span class="line">        <span class="type">FeatureHaveMouth</span> <span class="variable">trainDog</span> <span class="operator">=</span> TrainDog.train(dog);</span><br><span class="line">        trainDog.eatShit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试结果</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2022/02/08/%E5%AD%A6%E4%B9%A0&%E5%BB%B6%E4%BC%B8-%E7%94%A8-Collections-unmodifiableList/Snipaste_2022-10-26_17-13-12.png"
                       
                 ></p>
]]></content>
  </entry>
  <entry>
    <title>Java实现天气预报</title>
    <url>/2021/11/10/%E5%AE%9E%E7%8E%B0%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5/</url>
    <content><![CDATA[<h1 id="用-Java-实现天气预报"><a href="#用-Java-实现天气预报" class="headerlink" title="用 Java 实现天气预报"></a>用 Java 实现天气预报</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><ul>
<li>因每次去上班都不知道今天下不下雨。要是下雨鞋子就会湿的。</li>
<li>然后逛 github 发现有一个 QQ 机器人。可以用 Java 调用。遂想到实时预报下雨的天气。</li>
<li>所以设置每天早上 6 点发消息提醒今天的降水概率。</li>
</ul>
<h2 id="Step"><a href="#Step" class="headerlink" title="Step"></a>Step</h2><ol>
<li>使用 <a class="link"   href="https://github.com/ForteScarlet/simpler-robot" >simbot QQ 机器人<i class="fas fa-external-link-alt"></i></a>  (github 开源的）</li>
<li>使用和风天气和阿里云的易源数据作为天气 API</li>
</ol>
<h2 id="核心代码图片："><a href="#核心代码图片：" class="headerlink" title="核心代码图片："></a>核心代码图片：</h2><ul>
<li><p>RestFul 风格调用，接口见名知意<br><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/10/%E5%AE%9E%E7%8E%B0%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5/Snipaste_2021-11-10_18-29-11.jpg"
                       
                 ></p>
</li>
<li><p>OKHttps 访问 API 获取实时数据<br><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/10/%E5%AE%9E%E7%8E%B0%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5/Snipaste_2021-11-10_18-32-31.jpg"
                       
                 ></p>
</li>
<li><p>QQ 机器人代码参考<br><a class="link"   href="https://github.com/ForteScarlet/simpler-robot" >github<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<h2 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/10/%E5%AE%9E%E7%8E%B0%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5/Snipaste_2021-11-10_18-23-50.jpg"
                        alt="PANGU_DISABLE"
                 ></p>
]]></content>
  </entry>
  <entry>
    <title>害怕用`rm -rf`? 不如试试这个</title>
    <url>/2024/06/25/%E5%AE%B3%E6%80%95%E7%94%A8-rm-rf-%E4%B8%8D%E5%A6%82%E8%AF%95%E8%AF%95%E8%BF%99%E4%B8%AA/</url>
    <content><![CDATA[<p>Linux 中 <code>rm -rf /</code> 这个命令大家应该不熟悉</p>
<h1 id="为了减少误操作，网上有很多方案"><a href="#为了减少误操作，网上有很多方案" class="headerlink" title="为了减少误操作，网上有很多方案"></a>为了减少误操作，网上有很多方案</h1><h2 id="方案-1-不推荐"><a href="#方案-1-不推荐" class="headerlink" title="方案 1 (不推荐)"></a>方案 1 (不推荐)</h2><ul>
<li>起别名 <code>alias rm=&#39;rm -i&#39;</code> 删除都需要确认</li>
</ul>
<p>这种方式治标不治本，因为主动权还是在我手中</p>
<h2 id="方案-2-不推荐"><a href="#方案-2-不推荐" class="headerlink" title="方案 2 (不推荐)"></a>方案 2 (不推荐)</h2><ul>
<li>用 <code>mv</code> 替换 <code>rm</code> 这个也行，</li>
</ul>
<p>但是遇到目录或者相同文件没办法处理历史文件，且脚本太复杂，本人水平有限难以找到优雅处理方式</p>
<h2 id="方案-3-强烈推荐"><a href="#方案-3-强烈推荐" class="headerlink" title="方案 3 (强烈推荐)"></a>方案 3 (强烈推荐)</h2><p>使用 <code>trash-cli</code> 命令代替 <code>rm</code></p>
<p><a class="link"   href="https://github.com/andreafrancia/trash-cli" >trash-cli<i class="fas fa-external-link-alt"></i></a> 的基本命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trash-put           把文件或目录移动到回收站</span><br><span class="line">trash-empty         清空回收站</span><br><span class="line">trash-list          列出回收站文件</span><br><span class="line">trash-restore       恢复回收站文件</span><br><span class="line">trash-rm            删除回收站文件</span><br></pre></td></tr></table></figure>

<p>在你的shell 添加 <code>alias rm=&quot;trash-put&quot;</code><br>删除东西别怕正常rm就行，</p>
<p>使用方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/opt/test # touch testFile                                                                         root@Sparrow</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">/opt/test # ll                                                                                     root@Sparrow</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Feb 23 22:40 testFile</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">/opt/test # rm testFile                                                                            root@Sparrow</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">/opt/test # ll                                                                                     root@Sparrow</span><br><span class="line">total 0</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">/opt/test # trash-list                                                                             root@Sparrow</span><br><span class="line">2025-02-23 22:40:25 /opt/test/testFile</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">/opt/test # tree ~/.local/share/Trash                                                              root@Sparrow</span><br><span class="line">/root/.local/share/Trash</span><br><span class="line">├── files</span><br><span class="line">│   └── testFile</span><br><span class="line">└── info</span><br><span class="line">    └── testFile.trashinfo</span><br><span class="line"></span><br><span class="line">2 directories, 2 files</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">/opt/test # trash-restore                                                                          root@Sparrow</span><br><span class="line">   0 2025-02-23 22:40:25 /opt/test/testFile</span><br><span class="line">What file to restore [0..0]: 0</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">/opt/test # trash-list                                                                             root@Sparrow</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">/opt/test # tree ~/.local/share/Trash                                                              root@Sparrow</span><br><span class="line">/root/.local/share/Trash</span><br><span class="line">├── files</span><br><span class="line">└── info</span><br><span class="line"></span><br><span class="line">2 directories, 0 files</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">/opt/test # ll                                                                                     root@Sparrow</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 Feb 23 22:40 testFile</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">/opt/test #                                                                                        root@Sparrow</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>摸鱼神器 scrcpy</title>
    <url>/2021/11/01/%E6%91%B8%E9%B1%BC%E7%A5%9E%E5%99%A8scrcpy/</url>
    <content><![CDATA[<h1 id="电脑操作手机的摸鱼神器-scrcpy"><a href="#电脑操作手机的摸鱼神器-scrcpy" class="headerlink" title="电脑操作手机的摸鱼神器 scrcpy"></a>电脑操作手机的摸鱼神器 <a class="link"   href="https://github.com/Genymobile/scrcpy" >scrcpy<i class="fas fa-external-link-alt"></i></a></h1><blockquote>
<p>无线控制需要在同一局域网下，并获取手机静态 IP</p>
</blockquote>
<ol>
<li>下载 <a class="link"   href="https://github.com/Genymobile/scrcpy/releases" >scrcpy<i class="fas fa-external-link-alt"></i></a>.</li>
<li>多次点击版本号，把手机的 usb 调试打开。usb 连接上电脑。</li>
<li>查看手机在当前 wifi 的 ip 地址。如果是 DHCP 模式，应当切换到静态模式</li>
<li>电脑命令行输入<code>adb tcpip 6666</code></li>
<li>电脑输入<code> adb connect IP:6666</code></li>
<li>现在可以拔掉数据线，输入命令<code>scrcpy</code>即可进行连接</li>
</ol>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ul>
<li>在手机熄屏下操作手机<ul>
<li><code>scrcpy -S</code></li>
<li><code>scrcpy --turn-screen-off</code></li>
</ul>
</li>
<li>操作屏幕点击鼠标右键即可解锁，也可以执行返回操作</li>
</ul>
<h1 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h1><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/01/%E6%91%B8%E9%B1%BC%E7%A5%9E%E5%99%A8scrcpy/Snipaste_2021-11-01_15-55-45.jpg"
                        alt="PANGU_DISABLE"
                 ></p>
]]></content>
  </entry>
  <entry>
    <title>连表查询时未指定表别名导致的查询错误</title>
    <url>/2024/03/24/%E8%BF%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E6%97%B6%E6%9C%AA%E6%8C%87%E5%AE%9A%E8%A1%A8%E5%88%AB%E5%90%8D%E5%AF%BC%E8%87%B4%E7%9A%84%E6%9F%A5%E8%AF%A2%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>在给数据库新增字段后，自己的的功能测试没问题，拍拍屁股走人了。然后就这么上了生产。<br>然后用户发现其他功能模块出问题，去看日志是sql报错：<code>Column &#39;name&#39; in field list is ambiguous。</code>。<br>奇怪：我的功能没问题，并且我都没改代码怎么其他地方会报这个错误呢？</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>比如我加入的是 table1 表的 name 字段。</p>
<p><strong>因为出问题的地方是别人代码中使用了连表操作而且并没有给字段别名，<br>然后用正好 select 用到了这个字段，且现在两个表都有这个字段 MySQL 不知道取哪个表的 name 于是导致报错。</strong></p>
<ul>
<li>问题sql：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> table1,table2  <span class="keyword">where</span> table1.id<span class="operator">=</span>table2.id;</span><br></pre></td></tr></table></figure>

<ul>
<li>正例：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.name <span class="keyword">from</span> table1 <span class="keyword">as</span> t1 , table2 <span class="keyword">as</span> t2 <span class="keyword">where</span> t1.id<span class="operator">=</span>t2.id;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>为了避免这种问题。</p>
<ul>
<li>对于数据库中表记录的查询和变更，只要涉及多个表，都需要在列名前加表的别名（或 表名）进行限定。</li>
<li>对多表进行查询记录、更新记录、删除记录时，如果对操作列没有限定表的别名（或表名），并且操作列在多个表中存在时，就会抛异常。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>通过反射获取泛型</title>
    <url>/2022/11/21/%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p>这是怎么做到的？反射不是运行时吗？运行时不是没有泛型吗？</p>
<p><a class="link"   href="https://www.zhihu.com/question/346911525" >网上看了一大堆<i class="fas fa-external-link-alt"></i></a> </p>
<p>发现虽然泛型是被擦除了，存储的还是Object。</p>
<p>但是当类(Class)作为某个对象的时候，成员变量、方法返回值等位置的具体泛型类型的时候，Javac 会编译进class字节码。</p>
<p>JVM加载字节码的时候，JVM将解析到字节码的泛型信息保存下来的，所以反射可以获取。</p>
<h2 id="通过反射获取泛型"><a href="#通过反射获取泛型" class="headerlink" title="通过反射获取泛型"></a>通过反射获取泛型</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; field;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoMethod</span><span class="params">(Map&lt;Character, Integer&gt; args)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 根据子类获取父类泛型</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;() &#123;&#125;;</span><br><span class="line">        <span class="type">Type</span> <span class="variable">superClass</span> <span class="operator">=</span> map.getClass().getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (superClass <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            <span class="type">ParameterizedType</span> <span class="variable">pt</span> <span class="operator">=</span> (ParameterizedType) superClass;</span><br><span class="line">            Type[] typeArgs = pt.getActualTypeArguments();</span><br><span class="line">            System.out.println(<span class="string">&quot;变量第一个泛型为:&quot;</span> + typeArgs[<span class="number">0</span>].getTypeName());</span><br><span class="line">            System.out.println(<span class="string">&quot;变量第二个泛型为:&quot;</span> + typeArgs[<span class="number">1</span>].getTypeName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 成员变量泛型获取</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Demo.class.getDeclaredField(<span class="string">&quot;field&quot;</span>);</span><br><span class="line">        <span class="type">Type</span> <span class="variable">genericType</span> <span class="operator">=</span> field.getGenericType();</span><br><span class="line">        <span class="keyword">if</span> (genericType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            <span class="type">ParameterizedType</span> <span class="variable">pt</span> <span class="operator">=</span> (ParameterizedType) genericType;</span><br><span class="line">            Type[] typeArgs = pt.getActualTypeArguments();</span><br><span class="line">            System.out.println(<span class="string">&quot;成员变量第1个，泛型为:&quot;</span>+typeArgs[<span class="number">0</span>].getTypeName());</span><br><span class="line">            System.out.println(<span class="string">&quot;成员变量第2个，泛型为:&quot;</span>+typeArgs[<span class="number">1</span>].getTypeName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法参数泛型</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> Demo.class.getMethod(<span class="string">&quot;demoMethod&quot;</span>,Map.class);</span><br><span class="line">        Type[] genericTypes = method.getGenericParameterTypes();</span><br><span class="line">        <span class="type">Type</span> <span class="variable">oneParam</span> <span class="operator">=</span> genericTypes[<span class="number">0</span>];</span><br><span class="line">        <span class="type">ParameterizedType</span> <span class="variable">pt</span> <span class="operator">=</span> (ParameterizedType) oneParam;</span><br><span class="line">        Type[] typeArgs = pt.getActualTypeArguments();</span><br><span class="line">        System.out.println(<span class="string">&quot;方法第1个，泛型为:&quot;</span>+typeArgs[<span class="number">0</span>].getTypeName());</span><br><span class="line">        System.out.println(<span class="string">&quot;方法第2个，泛型为:&quot;</span>+typeArgs[<span class="number">1</span>].getTypeName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
</search>
