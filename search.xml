<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Centos基本的云服务器配置</title>
    <url>/2025/02/20/Centos%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>玩云服务器时想装一个 neovim 的插件，因为 Centos 8 已经不维护了，然而我要用的 neovim 一直在更新用到了glibc,不能直接安装，然而他又是linux一个底层的玩意,只能编译安装，<br>然后就把系统搞崩了，命令全部用不了，我看了网上的 <a class="link"   href="https://blog.csdn.net/qq_56776641/article/details/134027044" >恢复教程<i class="fas fa-external-link-alt"></i></a> 有点困难，直接重置得了。</p>
<p>于是乎顺手记录一下安装基本插件的过程</p>
</blockquote>
<h2 id="提前总结一下"><a href="#提前总结一下" class="headerlink" title="提前总结一下"></a>提前总结一下</h2><p>基本上能用yum就用yum，不行就去官方找对应操作系统的安装方式，实在不行再自己编译安装（最好提前拍个快照）。</p>
<h2 id="一些常用的脚本、命令、工具："><a href="#一些常用的脚本、命令、工具：" class="headerlink" title="一些常用的脚本、命令、工具："></a>一些常用的脚本、命令、工具：</h2><h3 id="yum-源更换"><a href="#yum-源更换" class="headerlink" title="yum 源更换"></a>yum 源更换</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/yum.repos.d      //进入/etc/yum.repos.d目录</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo</span><br><span class="line">yum -y clean all   //清除所有文件</span><br><span class="line">yum -y makecache   //建立缓存</span><br></pre></td></tr></table></figure>

<h3 id="nvm-（node版本管理"><a href="#nvm-（node版本管理" class="headerlink" title="nvm （node版本管理)"></a>nvm （node版本管理)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -o- https://ghfast.top/https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash</span><br></pre></td></tr></table></figure>

<h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install zsh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># ohmyzsh</span></span></span><br><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure>

<h3 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install tmux</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># ohmytmux</span></span></span><br></pre></td></tr></table></figure>

<h3 id="zsh-plugin"><a href="#zsh-plugin" class="headerlink" title="zsh-plugin"></a>zsh-plugin</h3><ul>
<li>zsh-syntax-highlighting</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>

<ul>
<li>zsh-autosuggestions</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Github Action 自动部署博客</title>
    <url>/2025/02/23/Github-Action-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>我是用的是 hexo 静态博客，该博客原理是解析 markdown 成 HTML 文件。</p>
<hr>
<p>命令 <code>hexo generate</code>会把原始的博客转换成一个可以访问的 public 文件夹（类似于前端工程的 dist 文件夹）。 把这个文件夹放服务器上 nginx 代理就是你的博客了。 我是用 github 仓库管理博客，<code>hexo generate</code> 生成文件夹要部署到服务器上，得把它打包到服务器上 <code>/www/wwwroot/leijiba.cn</code> 解压才行。</p>
<p>为了写完博客提交到github的后自动执行部署操作，于是有了这篇文章</p>
<p>其实有网上有很多方案，我采用的是 Github Action</p>
<h2 id="Github-Action"><a href="#Github-Action" class="headerlink" title="Github Action"></a>Github Action</h2><p>原理是推送代码到仓库后，github 会给你一个虚拟机，配置好配置文件虚拟机就会按照yaml文件执行命令。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">Hexo</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span> <span class="comment"># 或你使用的默认分支名称</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">blog</span> <span class="string">source</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">blog</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;18&quot;</span> <span class="comment"># 设置 Node.js 版本</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">        <span class="attr">working-directory:</span> <span class="string">./blog</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Hexo</span> <span class="string">CLI</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span></span><br><span class="line">        <span class="attr">working-directory:</span> <span class="string">./blog</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Generate</span> <span class="string">static</span> <span class="string">pages</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line">        <span class="attr">working-directory:</span> <span class="string">./blog</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">peaceiris/actions-gh-pages@v3</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">personal_token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PERSONAL_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">publish_dir:</span> <span class="string">./blog/public</span></span><br><span class="line">          <span class="attr">external_repository:</span> <span class="string">notfornothing/notfornothing.github.io</span> <span class="comment"># 更改为你的 GitHub Pages 仓库, username 是你的用户名</span></span><br><span class="line">          <span class="attr">publish_branch:</span> <span class="string">main</span> <span class="comment"># GitHub Pages 分支</span></span><br><span class="line">          </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">JD_Server</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">easingthemes/ssh-deploy@v2.1.1</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="comment"># 本地.ssh文件下的私钥id_rsa，存在secrets的PRIVATE_KEY中</span></span><br><span class="line">          <span class="attr">SSH_PRIVATE_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.JD_SSH_PRIVATE_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="comment"># 复制操作的参数。&quot;-avzr --delete&quot;意味部署时清空服务器目标目录下的文件</span></span><br><span class="line">          <span class="attr">ARGS:</span> <span class="string">&quot;-avzr --delete&quot;</span></span><br><span class="line">          <span class="comment"># 源目录，相对于$GITHUB_WORKSPACE根目录的路径</span></span><br><span class="line">          <span class="attr">SOURCE:</span> <span class="string">&quot;./blog/public/&quot;</span></span><br><span class="line">          <span class="comment"># 服务器域名/IP</span></span><br><span class="line">          <span class="attr">REMOTE_HOST:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.JD_REMOTE_HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="comment"># 服务器默认用户名为root</span></span><br><span class="line">          <span class="attr">REMOTE_USER:</span> <span class="string">&quot;root&quot;</span></span><br><span class="line">          <span class="comment"># 目标目录</span></span><br><span class="line">          <span class="attr">TARGET:</span> <span class="string">&#x27;/opt/hexo&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Git冲突处理</title>
    <url>/2021/09/15/Git%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="Git-冲突处理"><a href="#Git-冲突处理" class="headerlink" title="Git 冲突处理"></a>Git 冲突处理</h1><h2 id="缘故"><a href="#缘故" class="headerlink" title="缘故"></a>缘故</h2><ul>
<li>最开始经历过学 Git，玩着玩着把代码弄丢了的事情。然后当时也没深究。也知道一些大概：遇事别急，只要你 commit 了，代码就不会跑，所以没事就 <code>git add ./</code> , <code>git commit -m &quot;like a shit&quot;</code>。</li>
<li>以前也是一个人玩，很少遇到冲突基本上没有，也只是了解过冲突的部分概念。后面了解到 gitflow 工作流。也逐渐明白：别在主分支上乱搞，自己拉的分支随便你怎么处理。体会到了 git 的魅力，C 语言指针思想深入人心。Linus 看起来很酷。</li>
</ul>
<blockquote>
<p>gitlab 叫 merge request</p>
<p>github 叫 pull request</p>
</blockquote>
<ul>
<li><p>在此之前，我所知道的就是：</p>
<p><strong>拉分支 &#x3D;&#x3D;&gt; 做需求 &#x3D;&#x3D;&gt; 本地自测没问题 &#x3D;&#x3D;&gt; 把本地推到远程分支 &#x3D;&#x3D;&gt; 提交发起合并请求</strong></p>
</li>
</ul>
<h2 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h2><p>一次在和长沙的技术组长：黄哥！在一起写一个项目的代码的时候。因为我们都是修改的同一个文件。然后过来问我进度怎么样了。</p>
<p>由于我采用最保守的方式。从本地拉分支再进行修改。BTW，我知道 commit 很多会在 git 历史上很丑，一条线几个节点，巨丑无比。因为刚入手这个项目组，然后他过来看我改了哪些地方。我说我还没 commit（我怕还要改，因为 commit 太多了很丑）。</p>
<ul>
<li>然后他让我切到主分支上去。然后我就跟他争论说，我担心 checkout 后代码会丢了。</li>
<li>他说不会：<strong>不 commit 的话，切换分支你修改的是会跟着你走的，commit 相当于绑定上这个分支了。</strong></li>
</ul>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>经过组长的讲解，我觉得他这种方法特别的好。</p>
<ol>
<li>先在主分支上做代码开发<blockquote>
<p>（如果有急事要到另一个分支可以 git stash 存储修改的代码快照到当前分支，git pop 弹出修改的代码）</p>
</blockquote>
</li>
<li>假如需求自测没问题了。拉一下主分支的最新代码，如果有冲突会在本地解决掉。</li>
<li>解决冲突后，按照提交规范，新建需求分支并 checkout.</li>
<li>commit，推送远程仓库。</li>
<li>最后在远程合并。</li>
</ol>
<hr>
<p>通过上述步骤，冲突基本上能在本地解决。</p>
<p>但是聪明的我脑洞大开：<br>如果我在上述第四步：</p>
<ol start="4">
<li><p>新建分支 commit 后，别人同一时间也 commit 了同一文件并比我早一步合并远程分支。那我推送远程的代码照样会冲突禁止合并。</p>
</li>
<li><p>接下来我们可以在本地主分支拉取最新的代码，就是导致你冲突的代码。</p>
</li>
<li><p>然后在 checkout 到当前需求分支</p>
</li>
<li><p>在需求分支 <code>git merge --on-ff 主分支</code> 。把最新的主分支合并到开发分支。此时会提示冲突，就可以在本地解决冲突了。</p>
<blockquote>
<p>git merge –on-ff 是 no fast-forward，即禁止快速合并<br>关闭 fast-forward 模式，在提交的时候，会创建一个 merge 的 commit 信息，能更清晰显示冲突的问题。</p>
</blockquote>
</li>
<li><p>解决冲突后推送代码</p>
</li>
</ol>
<h1 id="活到老学到老！奥利给！"><a href="#活到老学到老！奥利给！" class="headerlink" title="活到老学到老！奥利给！"></a>活到老学到老！奥利给！</h1>]]></content>
  </entry>
  <entry>
    <title>Java 泛型详解汇总</title>
    <url>/2022/11/01/Java%20%E6%B3%9B%E5%9E%8B%E8%AF%A6%E8%A7%A3%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="Java-泛型"><a href="#Java-泛型" class="headerlink" title="Java 泛型"></a>Java 泛型</h1><blockquote>
<p>看了 Java 的 Collection 等源码，发现泛型用处很多，不知道为什么要这样设计如<code>（extends 和 super）</code>于是有了这篇文章。</p>
</blockquote>
<h2 id="阅读顺序"><a href="#阅读顺序" class="headerlink" title="阅读顺序"></a>阅读顺序</h2><ol start="0">
<li><p>Java 泛型擦除小实验</p>
</li>
<li><p>Java 为什么要使用泛型（从Java的发展历史来了解泛型）</p>
</li>
</ol>
<blockquote>
<p>使用泛型目的是要在编译阶段就找出类型的错误来，而不是运行时。所以我们应该带着能在解决运行抛错的问题来了解泛型。</p>
</blockquote>
<ol start="2">
<li>PECS(Producer Extends, Consumer Super) 规范原则</li>
</ol>
<blockquote>
<p>Producer Extends 设置上边界（协变）用来获取值<br>Consumer Super 设置下边界（逆变）用来操作值<br>如果你想都支持获取修改操作则设置 T 任意类型。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Java 为什么要使用泛型</title>
    <url>/2022/11/01/Java-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Java-历史"><a href="#Java-历史" class="headerlink" title="Java 历史"></a>Java 历史</h1><p>泛型是从 Java 1.5 出现的。</p>
<h1 id="为什么要使用泛型"><a href="#为什么要使用泛型" class="headerlink" title="为什么要使用泛型"></a>为什么要使用泛型</h1><h2 id="提高代码复用性"><a href="#提高代码复用性" class="headerlink" title="提高代码复用性"></a>提高代码复用性</h2><ul>
<li><p>需求：遍历集合</p>
<p>Java1.5 之前的代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCase</span> &#123;</span><br><span class="line">  <span class="meta">@org</span>.junit.Test</span><br><span class="line">  <span class="meta">@SuppressWarnings(value = &#123;&quot;rawtypes&quot;, &quot;unchecked&quot;&#125;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="string">&quot;Sparrow&quot;</span>);</span><br><span class="line">    list.add(<span class="number">23</span>);</span><br><span class="line">    <span class="keyword">for</span> (Object obj : list) &#123;</span><br><span class="line">      <span class="comment">//多态，查找父类的 toString 方法，打印出结果，</span></span><br><span class="line">      System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果我们遍历的时候就想得到自己想要的数据类型</span></span><br><span class="line">    <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">      <span class="comment">//在取 Integer 的时候会报类型转换错误</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">obj</span> <span class="operator">=</span> (String) o;</span><br><span class="line">      System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sparrow</span><br><span class="line">23</span><br><span class="line">Sparrow</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br><span class="line">	at cn.leijiba.config.MyConfig.Test.main(Test.java:20)</span><br></pre></td></tr></table></figure>

<p>图例</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2022/11/01/Java-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B/Snipaste_2024-03-26_15-21-17.png"
                       
                 ></p>
<ul>
<li><p>问题</p>
<p>如图抛错所示，List 存和取元素都是 Object 类型。所以存在运行时异常，编译不会报错有安全隐患，不方便写代码。</p>
<p>如果我们遍历的时候就想得到自己想要的数据类型有以下解决办法</p>
</li>
<li><p>解决办法 1：</p>
<p>在遍历集合的时候用 instance of 去判断属于哪个类，再进行强转</p>
</li>
</ul>
<blockquote>
<p>但是这样不合理，类很多，而且只能处理逻辑已知的类型，不知情的类型还是会报错。</p>
</blockquote>
<ul>
<li><p>解决办法 2:</p>
<p>限定存入的类型，也限制取出的类型。所以会有如下代码出现：</p>
</li>
</ul>
<blockquote>
<p>但是这样对于未知的类型还是没法判断。而且太过于繁琐。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringArrayList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StringArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = <span class="keyword">new</span> <span class="title class_">StringList</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (String) list.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        list.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>引入泛型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>源代码：</p>
<p><code>System.out.println(list.get(i));</code></p>
</li>
<li><p>class 字节码：</p>
<p><code>System.out.println((String)list.get(i));</code></p>
</li>
</ul>
<p>可以知道编译器会自动转换</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>  1.减少 Java5 以往代码的冗余，提高代码复用性</p>
<p>  2.返回泛型类型时，会自动强转，强转后的变量必须要当前泛型类或者其父类（Object 之类）接收，省时省力</p>
<blockquote>
<p>Java 执行顺序：*.java 文件 （编译） -&gt; *.class 字节码 （运行）-&gt;  jvm</p>
</blockquote>
<p>  3.由 2 知：把运行时报错转成了编译就报错，编译没过自然没法运行，减少试错成本</p>
]]></content>
  </entry>
  <entry>
    <title>Java 泛型擦除小实验</title>
    <url>/2022/08/16/Java-%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4%E5%B0%8F%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>很多人看到泛型就害怕，其实你只要想象成人为的一个约束。</li>
<li>泛型是编译期间的行为，下面会通过程序运行时的反射案例校验。</li>
<li>泛型是防止错误输入的，本质上就是 <code>Object</code>,存在的意义是方便编码确认类型。只在编译阶段有效 – 绕过编译无效</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>  Test.Java 文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"><span class="comment">//        编译报错，类型不同不能转换</span></span><br><span class="line"><span class="comment">//        list.add(1);</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">List</span>&gt; aClass = list.getClass();</span><br><span class="line">    aClass.getMethod(<span class="string">&quot;add&quot;</span>, Object.class).invoke(list, <span class="number">666</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    System.out.println((String) list.get(<span class="number">0</span>));</span><br><span class="line">    System.out.println((String) list.get(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  Test.class 字节码文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = new ArrayList();</span><br><span class="line">    list.add(&quot;A&quot;);</span><br><span class="line">    Class&lt;? extends List&gt; aClass = list.getClass();</span><br><span class="line">    aClass.getMethod(&quot;add&quot;, Object.class).invoke(list, 666);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">    System.out.println((String)list.get(0));</span><br><span class="line">    System.out.println((String)list.get(1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/./Java-%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4/Snipaste_2024-03-26_15-12-36.png"
                       
                 ></p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ul>
<li><p>通过反射（运行时执行方法）,把 <code>Integer</code> 类型 666 放入 list 中。</p>
</li>
<li><p>可知道程序运行时 <code>List&lt;String&gt;</code> 并没有被约束（即放入时就报错）。</p>
</li>
<li><p>所以 <code>List&lt;String&gt;</code> 就相当于 <code>List&lt;Object&gt;</code> 所以可以取出来。</p>
</li>
<li><p>由于是泛型返回值类型自动强转（可以看 class 文件结果），强转会会报运行时异常。</p>
</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li>所以 Java 的泛型只是编译期的约束行为。</li>
</ul>
<h2 id="进一步结论"><a href="#进一步结论" class="headerlink" title="进一步结论"></a>进一步结论</h2><ul>
<li><p>所以 Java 应该尽量避免这种运行时能赋值非泛型类型值的行为，不然会导致后面自动强转报运行错误，你知道重启一次服务是很久的嘛~</p>
</li>
<li><p>但是由于历史遗留原因，Java5 之前没有泛型，为了方便集合的存储转换.规定 Java 数组是支持协变的.即用父类数组接受所有子类数组，这样会导致集合里面值类型不一致的问题.So?Java 改不了但又要向下兼容古老代码就禁止这种行为嘛，所以 Java 禁止数组泛型。</p>
</li>
</ul>
<blockquote>
<p>Tips:不过这也是迫不得已的方法，因为当时没有泛型，当时开发人员只能用这中方式存储。所以你会发现很多代码里有(Object[],Object[])做为参数</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>JavaSE 总结</title>
    <url>/2021/06/20/JavaSE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="面试总结："><a href="#面试总结：" class="headerlink" title="面试总结："></a>面试总结：</h1><h2 id="Java-内存分区"><a href="#Java-内存分区" class="headerlink" title="Java 内存分区"></a>Java 内存分区</h2><details><summary>图解（点击展开）</summary>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/06/20/JavaSE%E6%80%BB%E7%BB%93/Snipaste_2022-03-20_19-44-14.jpg"
                        alt="PANGU_DISABLE"
                 ></p>
</details>

<ul>
<li><a class="link"   href="https://www.bilibili.com/video/BV12t411u726" >java jvm 内存模型<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<h2 id="JVM-分区？"><a href="#JVM-分区？" class="headerlink" title="JVM 分区？"></a>JVM 分区？</h2><h3 id="根据上一个问题得，堆区是用来存放创建对象的地方，堆区的清理需要-JVM-的垃圾收集器清理。"><a href="#根据上一个问题得，堆区是用来存放创建对象的地方，堆区的清理需要-JVM-的垃圾收集器清理。" class="headerlink" title="根据上一个问题得，堆区是用来存放创建对象的地方，堆区的清理需要 JVM 的垃圾收集器清理。"></a>根据上一个问题得，堆区是用来存放创建对象的地方，堆区的清理需要 JVM 的垃圾收集器清理。</h3><ul>
<li>GCRoot– 栈 &#x2F; 本地方法栈 &#x2F; 方法区域<ul>
<li>被 GCRoot 直接或者间接引用的对象是不能被删除的</li>
</ul>
</li>
<li>孤立存在的对象，没有和 GCRoot 有直接的关系。这些对象可以被删除</li>
</ul>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ul>
<li>标记清理 – 标记存活的对象，清理未被标记的对象<ul>
<li>缺点：会产生内存碎片，如果你删除了两个连续的 1KB 的对象。来一个 2KB 的对象放不下那个地方，所以会有内存碎片。</li>
</ul>
</li>
<li>标记整理 – 在上面基础上把清理之后。后面的对象补上来，紧凑。<ul>
<li>缺点：代价大，所有对象会前移，补空缺的内存碎片。</li>
</ul>
</li>
<li>复制算法 – 将整个内存一分为二，不需要删除的复制到另一边。<ul>
<li>缺点：需要内存空间大。</li>
</ul>
</li>
</ul>
<h3 id="JVM-分区"><a href="#JVM-分区" class="headerlink" title="JVM 分区"></a>JVM 分区</h3><h4 id="young-区-–-也叫新生代"><a href="#young-区-–-也叫新生代" class="headerlink" title="young 区 – 也叫新生代"></a>young 区 – 也叫新生代</h4><ul>
<li>内部又分为 Eden 区域，作为对象初始分配的区域还有两个 Survivor（也叫幸存区），有时候也叫 from、to 区域，被用来放置从 young GC（也叫 Minor GC ,Eden 区满了就会触发） 中保留下来的对象。young GC 采用的是复制算法。</li>
</ul>
<p><strong>每一次 young GC 后，对象的年龄就会加一，然后超过 6 次。就会到 old 区 , 然后大的对象 (Integer.maxValue) 也会直接存到 old 区，因为前面不容易啊！</strong></p>
<h4 id="old-区-–-也叫老年代"><a href="#old-区-–-也叫老年代" class="headerlink" title="old 区 – 也叫老年代"></a>old 区 – 也叫老年代</h4><ul>
<li>标记清理和标记整理主要用于 old GC .</li>
<li>old GC 一般会同时伴随 young GC. 称为 Full GC.</li>
<li>Full GC 会引起 Java 程序暂停，应该尽量减少次数。</li>
</ul>
<h4 id="Permanent-区-–-永久代？"><a href="#Permanent-区-–-永久代？" class="headerlink" title="Permanent 区 – 永久代？"></a><del>Permanent 区 – 永久代？</del></h4><ul>
<li>永久代在 JDK 7 中逐渐变化，到 JDK 8 之后完全消失，合并到了 Native 堆中</li>
</ul>
<details><summary>图解（点击展开）</summary>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/06/20/JavaSE%E6%80%BB%E7%BB%93/Snipaste_2022-03-20_19-43-36.jpg"
                        alt="PANGU_DISABLE"
                 ></p>
</details>


<p><a class="link"   href="https://www.bilibili.com/video/BV1dt411u7wi/" >GC 过程<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="Java-中的-equals-与-hashCode-的区别与联系"><a href="#Java-中的-equals-与-hashCode-的区别与联系" class="headerlink" title="Java 中的 &#x3D;&#x3D;, equals 与 hashCode 的区别与联系"></a><a class="link"   href="https://blog.csdn.net/justloveyou_/article/details/52464440" >Java 中的 &#x3D;&#x3D;, equals 与 hashCode 的区别与联系<i class="fas fa-external-link-alt"></i></a></h2><hr>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p>一般把常量写 前面 即 “常量”.equals() 防止空指针异常</p>
<ul>
<li>初衷：就是判断两个对象的 content 是否相同。</li>
</ul>
<hr>
<p>Objects 类：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></blockquote>
<blockquote>
<p>Objects 的意思是判断两个对象是否相同</p>
<p>很显然，在 Object 类中，equals 方法是用来比较两个对象的引用是否相等，即是否指向同一个对象。</p>
</blockquote>
<blockquote>
<p>但是我们知道：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);<span class="comment">// 这里指向不同的 hello</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);<span class="comment">// 这里指向不同的 hello 却是 true</span></span><br><span class="line">System.out.println(str1.equals(str2));<span class="comment">//ture</span></span><br></pre></td></tr></table></figure>

<p>这是因为 String 重写了 equals() 方法：</p>
</blockquote>
<p>String 类：（重写了 equals 方法） 不需要看懂</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码：</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;<span class="comment">// 先比较引用类型是否相同（即是佛为同一对象）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;<span class="comment">// 在判断类型是否一致</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="type">char</span> v1[] = value;</span><br><span class="line">                <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])<span class="comment">// 最后比较内容是否一致</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Java 中所有内置的类的 equals 方法的实现步骤均是如此，特别是诸如 Integer，Double 等包装器类。</strong></p>
<ul>
<li>一般分为三个步骤：<ul>
<li>先比较引用类型是否相同（即是佛为同一对象）</li>
<li>在判断类型是否一致</li>
<li>最后比较内容是否一致</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
</blockquote>
<h3 id="判断数组是不是对象"><a href="#判断数组是不是对象" class="headerlink" title="判断数组是不是对象"></a>判断数组是不是对象</h3><hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;判断数组是否是对象？&quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] chars = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line">    System.out.println(chars);<span class="comment">// 这是字符数组的特性</span></span><br><span class="line">    <span class="comment">// 可以理解为指向的第一个数组的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] ints = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    System.out.println(ints);<span class="comment">// 这样就不行了，没有重写 toString 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chars <span class="keyword">instanceof</span> Object) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数组是对象&quot;</span>);<span class="comment">// 输出为这个</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数组不是对象&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于-toString-方法"><a href="#关于-toString-方法" class="headerlink" title="关于 toString() 方法"></a>关于 toString() 方法</h3><hr>
<p>Object 类：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这样比较 hashCode() 没有意义。因为我们要的是比较里面的 String 或者说是实质性的东西</p>
</blockquote>
<p>String 类：</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String 类重写了 toString 方法</p>
</blockquote>
<p>数组类：</p>
<p>int[] ints &#x3D;new int[10]</p>
<p>char[] chars&#x3D;new char[10]</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] chars = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line">System.out.println(chars);<span class="comment">//abcdefg</span></span><br><span class="line"><span class="comment">// 这是字符数组的特性</span></span><br><span class="line"><span class="comment">// 可以理解为指向的第一个数组的地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] ints = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">System.out.println(ints);<span class="comment">// 这样就不行了，没有重写 toString 方法</span></span><br></pre></td></tr></table></figure>

<p>数组类没有重写 toString( )  chars 数组可以打印是因为 chars 指向第一个数组的地址</p>
</blockquote>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><hr>
<p><strong>Integer</strong> 的两种构造方法：</p>
<ul>
<li><ul>
<li><table>
<thead>
<tr>
<th>Constructor and Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>Integer(int value)</code>  构造一个新分配的 <code>Integer</code>对象，该对象表示指定的 <code>int</code>值。</td>
</tr>
<tr>
<td><code>Integer(String s)</code>  构造一个新分配 <code>Integer</code>对象，表示 <code>int</code>由指示值  <code>String</code>参数。</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Integer 在给 -128 到 127 用高效的效果 相同的数据存一次</p>
<p>但是在其他范围内存的是两个对象 (<strong>只要 Integer 有这个高效</strong>)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i=<span class="number">1</span>;</span><br><span class="line">等价于</span><br><span class="line">Integer i=Integer.valueOf(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><a class="link"   href="https://github.com/notfornothing/JavaSE/blob/main/JavaSE_Basic_Basic/src/cn/leijiba/day11/Test6_Integer.java" >关于 Integer 的高效：了解即可 &#x3D;&#x3D;&gt;由此去源代码<i class="fas fa-external-link-alt"></i></a></p>
<ul>
<li><pre><code class="language-java">    private static void integerTest2() &#123;
        Integer i1 = Integer.valueOf((int)666);
        Integer i2 = Integer.valueOf((int)666);
        Integer i3 = new Integer((int) 666);
        Integer i4 = new Integer((int) 666);
        System.out.println(i1==i2);//false
        System.out.println(i3==i4);//false
    &#125;

    private static void integerTestEqual() &#123;
        Integer i1 = Integer.valueOf((int)6);
        Integer i2 = Integer.valueOf((int)6);
        Integer i3 = new Integer((int) 6);
        Integer i4 = new Integer((int) 6);
        System.out.println(i1==i2);//true
        System.out.println(i3==i4);//false
    &#125;

    public static void integerTest() &#123;
        Integer i1=  6;
        Integer i2 = 6;
        Integer i3 = new Integer(6);
        Integer i4 = new Integer(6);
        System.out.println(i1 == i2);//true
        System.out.println(i3 == i4);//false
    &#125;

   public static void main(String[] args) &#123;
        integerTest();
        integerTest2();
        System.out.println(&quot;=========|&quot;);
        // 为什么会输出 true  false
        // 下面的是反编译，这是
        integerTestEqual();
        // 可以看到 i1 i2 以自动装箱的方式创建
        //i3  i4 以构造方法的方式创建

        // 那为啥会有 true 返回呢？
        // 因为 Integer 在 valueOf() 第一次 调用时。会创建 -128~127 直接的实例
        // 加到缓存，后续调用 valueOf 方法时，会返回缓存中的实例。
        // 所以指向同一内存地址 为 true.
        // 所以 integerTest2 超过了 127 的最大值。你自己可以进 valueOf 方法里看。
    &#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### String</span><br><span class="line"></span><br><span class="line">重写了 equals 方法和 toString 方法</span><br><span class="line"></span><br><span class="line">sout 默认打印的是他的 toString 方法</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">String =&quot; &quot;  和 String str=new String(&quot; &quot;) 的区别 ==&gt;[StringTest.java](https://github.com/notfornothing/JavaSE/blob/main/JavaSE_Basic_Basic/src/cn/leijiba/day11/StringTest.java)</span><br><span class="line"></span><br><span class="line">&gt; [基于 == 判断的，因为 == 是比较的地址值.](https://blog.csdn.net/justloveyou_/article/details/52464440)</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    /** String=&quot;&quot;  和 String s=new String(&quot;string&quot;) 的区别*/</span><br><span class="line"></span><br><span class="line">    String str1 = &quot;abcd&quot;;</span><br><span class="line">    String str2 = &quot;abcd&quot;;</span><br><span class="line">    System.out.println(str1==str2);//true</span><br><span class="line">    // 因为 String str1 = &quot;abcd&quot;的实现过程：</span><br><span class="line">    // 首先栈区创建 str 引用，然后在 String 池（独立于栈和堆而存在，存储不可变量）</span><br><span class="line">    // 中寻找其指向的内容为&quot;abcd&quot;的对象，如果 String 池中没有，则创建一个，</span><br><span class="line">    // 然后 str 指向 String 池中的对象，如果有，则直接将 str1 指向&quot;abcd&quot;&quot;；</span><br><span class="line">   // 如果后来又定义了字符串变量 str2 = &quot;abcd&quot;,</span><br><span class="line">    // 则直接将 str2 引用指向 String 池中已经存在的“abcd”，不再重新创建对象；</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;============&quot;);</span><br><span class="line">    str1 = &quot;abc&quot;;</span><br><span class="line">    String str3 = &quot;abc&quot;;</span><br><span class="line">    System.out.println(str1 == str3);//true</span><br><span class="line">    // 当 str1 进行了赋值（str1=“abc”），则 str1 将不再指向&quot;abcd&quot;，</span><br><span class="line">    // 而是重新指 String 池中的&quot;abc&quot;，此时如果定义 String str3 = &quot;abc&quot;,</span><br><span class="line">    // 进行 str1 == str3 操作，返回值为 true，因为他们的值一样，地址一样</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;============&quot;);</span><br><span class="line">    str1 = str3 + &quot;d&quot;;</span><br><span class="line">    System.out.println(str2 == str1);//false</span><br><span class="line">    System.out.println(str2.equals(str1));//true</span><br><span class="line">    // 内容为&quot;abc&quot;的 str1 进行了字符串的 + 连接 str1 = str1+&quot;d&quot;；</span><br><span class="line">    // 此时 str1 指向的是在堆中新建的内容为&quot;abcd&quot;的对象，*************这是重点</span><br><span class="line">    // 即此时进行 str1==str2，返回值 false，因为地址不一样。但是值一样</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;=================&quot;);</span><br><span class="line">    System.out.println(&quot;以下是区别&quot;);</span><br><span class="line"></span><br><span class="line">    String str4 = new String(&quot;abcd&quot;);</span><br><span class="line">    String str5 = new String(&quot;abcd&quot;);</span><br><span class="line">    System.out.println(str4 == str5);//false</span><br><span class="line">    System.out.println(str4.equals(str5));//true</span><br><span class="line">    //String str4 = new String(&quot;abcd&quot;) 的实现过程：</span><br><span class="line">    // 直接在堆中创建对象。如果后来又有 String str5 = new String(&quot;abcd&quot;)，</span><br><span class="line">    // str5 不会指向之前的对象，而是重新创建一个对象并指向它，</span><br><span class="line">    // 所以如果此时进行 str3==str4 返回值是 false，因为两个对象的地址不一样，</span><br><span class="line">    // 如果是 str3.equals(str4)，返回 true, 因为内容相同。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="String-常用-API"><a href="#String-常用-API" class="headerlink" title="String 常用 API"></a><strong>String 常用 API</strong></h3><p>—————– 不用记下来，有印象就行</p>
<hr>
<ul>
<li>charAt</li>
<li><strong>concat</strong> – 拼接，但不改变原字符串</li>
<li>endsWith</li>
<li>startsWith</li>
<li>equals</li>
<li><strong>indexOf</strong></li>
<li>lastIndexOf</li>
<li>length</li>
<li>toUpperCase</li>
<li>toLowerCase</li>
<li><strong>split</strong> – 切割</li>
<li><strong>valueOf</strong> – int 转 String</li>
<li>trim – 去掉头尾空格</li>
<li>getBytes – 转成 byte[]</li>
<li><strong>subString</strong> – 截取子串 左闭右开 [)</li>
</ul>
<p>对于 String 的这些方法：</p>
<p>可以用字符串常量来解释：所以他返回的值是变的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;abcdefg&quot;</span>.substring(<span class="number">2</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<h3 id="String-和-StringBuffer-和-String"><a href="#String-和-StringBuffer-和-String" class="headerlink" title="String 和 StringBuffer 和 String"></a>String 和 StringBuffer 和 String</h3><hr>
<p>目前只知道 String 拼接字符串 比其他两个很耗时间和内存</p>
<p>用 System.currentTimeMillis() 两个相减得到的</p>
<h3 id="思考-成员变量为自定义的类型，那么-equals-是否调用该成员变量的-equals-方法呢？toString-呢？"><a href="#思考-成员变量为自定义的类型，那么-equals-是否调用该成员变量的-equals-方法呢？toString-呢？" class="headerlink" title="思考 成员变量为自定义的类型，那么 equals 是否调用该成员变量的 equals 方法呢？toString 呢？"></a>思考 成员变量为自定义的类型，那么 equals 是否调用该成员变量的 equals 方法呢？toString 呢？</h3><hr>
<p>是的，所以应该重写 equals 和 toString</p>
<ul>
<li><p>其中 toString 调用的是 hashCode 的默认。所以应该重写才好</p>
</li>
<li><p>重写的 equals 调用的是基本数据类型的是用 &#x3D;&#x3D;. 引用数据类型调用的是 Objects.equals(a,b)</p>
<blockquote>
<p>我看了一下他的实现，就是去调用 a 的 equals 方法。所以说要重写才好。免得到时候 equals 判断半天还不等于。免得踩坑</p>
</blockquote>
</li>
</ul>
<p>下面有关于 Objects 的 quals 方法</p>
<h3 id="Stringbuffer-是线程安全的："><a href="#Stringbuffer-是线程安全的：" class="headerlink" title="Stringbuffer 是线程安全的："></a>Stringbuffer 是线程安全的：</h3><blockquote>
<p><strong>他是从 JDK1.0 版本就有的，他是线程安全</strong><br><strong>StringBuffer 源码有</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity &gt; value.length) &#123;</span><br><span class="line">        expandCapacity(minimumCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="Stringbuilder-不是线程安全的"><a href="#Stringbuilder-不是线程安全的" class="headerlink" title="Stringbuilder 不是线程安全的"></a>Stringbuilder 不是线程安全的</h3><blockquote>
<ul>
<li><strong>从版本 JDK 5 开始，这个类别已经被一个等级类补充了，这个类被设计为使用一个线程 Stringbuilder 类，Stringbuilder 应该使用 Stringbuilder 类，因为它支持所有相同的操作，但它更快，因为它不执行同步。</strong></li>
</ul>
<p><strong>Stringbuilder 没有 synchronized 锁</strong> ,<strong>所以他不是线程安全的.</strong></p>
</blockquote>
<h3 id="好像还有一个-Objects-类"><a href="#好像还有一个-Objects-类" class="headerlink" title="好像还有一个 Objects 类"></a>好像还有一个 Objects 类</h3><hr>
<p>主要用到的是 Objects 类的 Objects.equals</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="literal">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
















<h2 id="Spring-AOP-几种通知？"><a href="#Spring-AOP-几种通知？" class="headerlink" title="Spring AOP 几种通知？"></a>Spring AOP 几种通知？</h2><h2 id="MySQL-四种特性？"><a href="#MySQL-四种特性？" class="headerlink" title="MySQL 四种特性？"></a>MySQL 四种特性？</h2><h2 id="MySQL-赃读，幻读那些"><a href="#MySQL-赃读，幻读那些" class="headerlink" title="MySQL 赃读，幻读那些"></a>MySQL 赃读，幻读那些</h2><h2 id="Spring-的注解有哪些（注意不是-SpringBoot-的）"><a href="#Spring-的注解有哪些（注意不是-SpringBoot-的）" class="headerlink" title="Spring 的注解有哪些（注意不是 SpringBoot 的）"></a>Spring 的注解有哪些（注意不是 SpringBoot 的）</h2><h2 id="业务：SpringBoot-中返回一个-JSON-和重定向应该怎么使用？"><a href="#业务：SpringBoot-中返回一个-JSON-和重定向应该怎么使用？" class="headerlink" title="业务：SpringBoot 中返回一个 JSON, 和重定向应该怎么使用？"></a>业务：SpringBoot 中返回一个 JSON, 和重定向应该怎么使用？</h2><h2 id="String-StringBuffer-StringBuilder-区别"><a href="#String-StringBuffer-StringBuilder-区别" class="headerlink" title="String , StringBuffer , StringBuilder 区别"></a>String , StringBuffer , StringBuilder 区别</h2><h2 id="SpringMVC-流程"><a href="#SpringMVC-流程" class="headerlink" title="SpringMVC 流程"></a>SpringMVC 流程</h2><h2 id="多线程状态"><a href="#多线程状态" class="headerlink" title="多线程状态"></a>多线程状态</h2><details><summary>图解（点击展开）</summary>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/06/20/JavaSE%E6%80%BB%E7%BB%93/Snipaste_2022-03-20_19-42-06.jpg"
                       
                 ></p>
</details>

<h2 id="hashMap-底层原理"><a href="#hashMap-底层原理" class="headerlink" title="hashMap 底层原理"></a>hashMap 底层原理</h2><details><summary>DEBUG 代码探究其原理（点击展开） </summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DEBUG 代码探究其原理：</span></span><br><span class="line"><span class="keyword">package</span> cn.leijiba.hashTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;SimpleBO, String&gt; stringMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">7</span>) &#123;</span><br><span class="line">                stringMap.put(<span class="keyword">new</span> <span class="title class_">SimpleBO</span>(<span class="string">&quot;test&quot;</span> + i), <span class="string">&quot;test&quot;</span> + i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt;= <span class="number">45</span>) &#123;</span><br><span class="line">                stringMap.put(<span class="keyword">new</span> <span class="title class_">SimpleBO</span>(<span class="string">&quot;test&quot;</span> + i), <span class="string">&quot;test&quot;</span> + i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stringMap.put(<span class="keyword">new</span> <span class="title class_">SimpleBO</span>(<span class="string">&quot;test&quot;</span> + i), <span class="string">&quot;test&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleBO</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleBO</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">replace</span> <span class="operator">=</span> UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">char</span>[] chars = replace.toCharArray();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> aChar : chars) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aChar &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; aChar &lt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                stringBuilder.append(aChar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringBuilder.toString();</span><br><span class="line">        <span class="keyword">if</span> (s.length() &gt; <span class="number">6</span>) &#123;</span><br><span class="line">            s = s.substring(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<hr>
<ul>
<li><p>hashMap 树化得同时满足：</p>
<ul>
<li>链接长度 &gt; 8</li>
<li>数组长度为 64</li>
</ul>
</li>
<li><p>hashMap  当总元素个数 &gt; 数组长度*0.75 会扩容 rehash(), 但是下面还有一种情况。</p>
</li>
<li><p>hashMap 当总元素没有达到 <code>当前数组长度*0.75</code> 且 <code>数组长度 &lt; 64</code> 时 ，有一个数组地址哈希冲突了，形成<strong>链表</strong>。在这前提下如果哈希冲突的元素达到 8，在插入第 9 个哈希冲突的元素时。数组会扩容到两倍（即长度向左移一位），而且不会形成红黑树，而是扩容 rehash(). 当第一种情况满足才会红黑树。</p>
</li>
<li><p><a class="link"   href="https://www.bilibili.com/video/BV1YA411T76k?p=40&t=514" >hashMap 扩容源码讲解<i class="fas fa-external-link-alt"></i></a></p>
</li>
<li><p><a class="link"   href="https://www.bilibili.com/video/BV1YA411T76k?p=23" >hashMap 变红黑树必须同时满足链表》8 和数组 &#x3D;&#x3D;64 才会变红黑树<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Map 中引用遇到的问题</title>
    <url>/2021/12/08/Map-%E4%B8%AD%E5%BC%95%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Map-中引用遇到的问题"><a href="#Map-中引用遇到的问题" class="headerlink" title="Map 中引用遇到的问题"></a>Map 中引用遇到的问题</h1><h2 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、有 List&lt;String&gt; nameList 值为『张三，李四，王五』</span><br><span class="line">2、把 nameList 的每个值都存到 key 为&quot;name&quot; 的 map&lt;String,Object&gt; 中</span><br><span class="line">3、并把 map 放到 List&lt;Map&lt;String, Object&gt;&gt; 里面</span><br></pre></td></tr></table></figure>
<p>等于说是：</p>
<p>『张三，李四，王五』&#x3D;&#x3D;&gt; 『{name&#x3D; 张三}, {name&#x3D; 李四}, {name&#x3D; 王五}』</p>
<h2 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h2><ul>
<li><p>BUG : 一直都是最后一个人的姓名</p>
</li>
<li><p>BUG 代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[PANGU_DISABLE] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; nameList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>));</span><br><span class="line">    System.out.println(nameList);</span><br><span class="line">    System.out.println(<span class="string">&quot;================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BUG 一直都是最后一个人的姓名</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">for</span> (String name : nameList) &#123;</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">        list.add(map);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/12/08/Map-%E4%B8%AD%E5%BC%95%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/Snipaste_2021-12-08_19-27-47.jpg"
                        alt="PANGU_DISABLE"
                 ></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ol>
<li>由输出可见：存进 list 的值都是最后一个的 name.</li>
<li>因为 list 存的都是这个 map 的同一个引用。类似于 C 语言的指针。也就是<strong>list  存的都是同一个地址</strong>，这个地址所指向的东西改变，其他存这个地址的里面的值也会改变。所以该 list 下面的值都会变，也就是 name 都是一样的。</li>
<li>然后 map 的 put 有去重的效果，以最后一个 key 所 put 进去的值为准。所以存的是最后一个 name.</li>
</ol>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ul>
<li>由<a href="#%E5%8E%9F%E5%9B%A0">原因</a>的第 2 点，我们只需不让 list 存同一个地址。即让 map 重新指向新的地址。即重新 new 一个 HashMap.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; nameList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>));</span><br><span class="line">    System.out.println(nameList);</span><br><span class="line">    System.out.println(<span class="string">&quot;================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 map 放到循环里面，避免重复引用</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String name : nameList) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">        list.add(map);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/12/08/Map-%E4%B8%AD%E5%BC%95%E7%94%A8%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/Snipaste_2021-12-08_19-58-14.jpg"
                       
                 ></p>
]]></content>
  </entry>
  <entry>
    <title>MySQL 总结 (一)</title>
    <url>/2021/04/25/MySQL%E6%80%BB%E7%BB%931/</url>
    <content><![CDATA[<h1 id="MySQL-相关"><a href="#MySQL-相关" class="headerlink" title="MySQL 相关"></a>MySQL 相关</h1><h2 id="desc-表名"><a href="#desc-表名" class="headerlink" title="desc 表名"></a>desc 表名</h2><p>describe– 描述</p>
<p>descend– 下降</p>
<hr>
<blockquote>
<p>descibe 是查看表的结构，例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">describe tablename;</span><br></pre></td></tr></table></figure>

<p>desc 是 describe 的简写，例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">desc tablename;</span><br></pre></td></tr></table></figure>

</blockquote>
<p>另外 desc 在排序中的意义是降续排列（和 describe 的简写不是同一个），例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">order</span> <span class="keyword">by</span> id  <span class="keyword">desc</span> ;</span><br></pre></td></tr></table></figure>

<h1 id="关于-where"><a href="#关于-where" class="headerlink" title="关于 where"></a>关于 where</h1><hr>
<blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> stu <span class="keyword">set</span> score<span class="operator">=</span><span class="number">22</span> [<span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>如果不加 where 那么修改的是全局的</p>
</blockquote>
<blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> stu [<span class="keyword">where</span> id <span class="operator">=</span><span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>如果不加 where 那么删除的是全部的 所以要注意</p>
</blockquote>
<h1 id="select-中的-distinct"><a href="#select-中的-distinct" class="headerlink" title="select 中的 distinct"></a>select 中的 distinct</h1><p>–distinct  adj.  清晰的；清楚的；明白的；明显的；截然不同的；有区别的；不同种类的；确定无疑的；确实的；确切的；</p>
<hr>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span>  gender <span class="keyword">from</span> emp</span><br></pre></td></tr></table></figure>



<h1 id="Null-和仍和数据运算结果都是-null-以及有关-null-的运算"><a href="#Null-和仍和数据运算结果都是-null-以及有关-null-的运算" class="headerlink" title="Null 和仍和数据运算结果都是 null, 以及有关 null 的运算"></a>Null 和仍和数据运算结果都是 null, 以及有关 null 的运算</h1><hr>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> NAME</span><br><span class="line">	,</span><br><span class="line">	sal <span class="operator">+</span> bonus</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	sal <span class="operator">+</span> bonus <span class="operator">&gt;</span> <span class="number">3500</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>问题</strong>: 其中有一条数据 A 的 bonus 为 null, 但是他的 sal &gt;3500 了已经。<br>我们要求能把 null&#x3D;0 最好，而且查出来。</p>
<blockquote>
<p>方法 1: 将所有的奖金为 null 的列更新为 0</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> bonus <span class="operator">=</span><span class="number">0</span> <span class="keyword">where</span> bonus <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> bonus <span class="operator">=</span><span class="number">0</span> <span class="keyword">where</span> bonus <span class="keyword">is</span> <span class="keyword">not null</span>;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<blockquote>
<p>SELECT * from emp WHERE dept is not null<br>SELECT * from emp WHERE not (dept is  null)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></blockquote>
<blockquote>
<p>方法 2: 在查询时将 null 值 看做 0 来处理（这种方式不会对表中的数据产生仍和影响）</p>
<p><strong>ifnull（列名，值）</strong> 函数：判断指定的列是否包含 null, 若果有 null 就用第二个<strong>值</strong> 替换。<br>ifnull(bonus,0)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> NAME</span><br><span class="line">	,</span><br><span class="line">	IFNULL(bonus,<span class="number">0</span>) <span class="operator">+</span> sal</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">IFNULL(bonus,<span class="number">0</span>) <span class="operator">+</span> sal <span class="operator">&gt;</span> <span class="number">3500</span></span><br></pre></td></tr></table></figure></blockquote>
<h1 id="取别名的问题"><a href="#取别名的问题" class="headerlink" title="取别名的问题"></a>取别名的问题</h1><hr>
<h1 id="模糊查询-LIKE"><a href="#模糊查询-LIKE" class="headerlink" title="模糊查询 LIKE"></a>模糊查询 LIKE</h1><hr>
<p>like 操作符 用在 WHERE 子句中搜索列中的指定模式。</p>
<blockquote>
<p>可以和 % _ 使用。</p>
<p>其中 % 代表<strong>0 个或者多个</strong>任意字符，_代表<strong>一个</strong>任意字符。</p>
</blockquote>
<h1 id="多行函数查询"><a href="#多行函数查询" class="headerlink" title="多行函数查询"></a>多行函数查询</h1><p>– 多行函数也叫聚合函数，也叫聚集函数</p>
<p><strong>多行函数会默认过滤 null 值</strong> , 即不统计 null 值</p>
<hr>
<p>count（列名 | *):                  | 是或的意思</p>
<blockquote>
<p>count（列名）: 表示统计当前列有多少个值<br>count(*): 以行为单位，统计查询结果中有多少行记录</p>
</blockquote>
<p>max（列名）:<br>min（列名）:<br>sum（列名）: 统计这一列中所有值的和 (<strong>会过滤 null 值</strong>) 参考上面的<br>avg（列名）: 会过滤 null 值（所有值的和 &#x2F; 不是 null 值的个数）</p>
<ul>
<li><strong>在统计时，不要加格外的列，因为没有任何意义</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="built_in">COUNT</span>( <span class="operator">*</span> ),</span><br><span class="line">	`name`</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	EMP</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	EMP.sal <span class="operator">&gt;</span> <span class="number">3000</span></span><br><span class="line"><span class="comment">-- 如果没有分组 在进行统计时，不要添加格外的列，因为没有任何意义（这里的 name 只会将第一行的 name 显示出来）</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="built_in">max</span>( sal ),</span><br><span class="line">	`name`</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	EMP</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	EMP.sal <span class="operator">&gt;</span> <span class="number">3000</span></span><br><span class="line"><span class="comment">-- 所以这里的 name 不能认为是最高薪资的那一个人，</span></span><br><span class="line"><span class="comment">-- 如果没有分组，那么最高薪资和姓名没有任何关系，薪资是所有薪资的最大值，但是 name 就是结果中的第一行的 name</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="built_in">sum</span>( bonus )</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	emp</span><br><span class="line"><span class="comment">-- 如果 bonus 是里面有 null 的话会过滤掉。前面说了的。不会参与统计</span></span><br></pre></td></tr></table></figure>

<ul>
<li>avg 是剔除了为 null 的 count 的那条记录的平均值，那一行不算在内</li>
</ul>
<h1 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h1><p>group by</p>
<hr>
<p>select count(*) from emp;<br>– 如果没有分组，</p>
<h1 id="升序和降序"><a href="#升序和降序" class="headerlink" title="升序和降序"></a>升序和降序</h1><hr>
<p>DESC 是 descend 降序意思<br>ASC 是 ascend 升序的意思 <strong>默认是 ASC</strong></p>
<h1 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h1><p><strong>limit</strong></p>
<hr>
<h1 id="删除的区别"><a href="#删除的区别" class="headerlink" title="删除的区别"></a>删除的区别</h1><hr>
<p>delete，drop，truncate 都有删除表的作用，区别在于：</p>
<ul>
<li>delete 和 truncate 仅仅删除表数据，所以会保存字段名，drop 连表数据和表结构一起删除，打个比方，delete 是单杀，truncate 是团灭，drop 是把电脑摔了。</li>
<li>delete 是 DML 语句，操作完以后如果没有不想提交事务还可以回滚，truncate 和 drop 是 DDL 语句，操作完马上生效，不能回滚，打个比方，delete 是发微信说分手，后悔还可以撤回，truncate 和 drop 是直接扇耳光说滚，不能反悔。</li>
<li>执行的速度上，<strong>drop&gt;truncate&gt;delete</strong>，打个比方，drop 是神舟火箭，truncate 是和谐号动车，delete 是自行车。</li>
</ul>
<h1 id="varchar-和-char"><a href="#varchar-和-char" class="headerlink" title="varchar 和 char"></a>varchar 和 char</h1><hr>
<p>区别一，定长和变长</p>
<blockquote>
<p>char 表示定长，长度固定，varch ar 表示变长，即长度可变。char 如果插入的长度小于定义长度时，则用空格填充；varchar 小于定义长度时，还是按实际长度存储，插入多长就存多长。</p>
</blockquote>
<blockquote>
<p> 因为其长度固定，char 的存取速度还是要比 varchar 要快得多，方便程序的存储与查找；但是 char 也为此付出的是空间的代价，因为其长度固定，所以会占据多余的空间，可谓是以空间换取时间效率。varchar 则刚好相反，以时间换空间。</p>
</blockquote>
<p>区别之二，存储的容量不同</p>
<blockquote>
<p>对 char 来说，最多能存放的字符个数 255，和 编码无关。<br>而 varchar 呢，最多能存放 65532 个字符。varchar 的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是 65,532 字节。</p>
</blockquote>
<p>区别之三，空格</p>
<p>char 在存储的时候会将右侧空格进行剔除，保留左侧空格。<br>varchar 在存储的时候保留所有空格，不进行任何删除</p>
<p>varchar 和 char 在查询的时候都只会根据 where 条件中的左侧空格进行判断，右侧末尾的空格会忽略</p>
<h1 id="自增"><a href="#自增" class="headerlink" title="自增"></a>自增</h1><p>auto_increment</p>
<hr>
<p>可以用 show create  table emp</p>
<blockquote>
<p> 设置完主键自增后，表中会维护一个 AUTO_INCREMENT 的值，这个值从<strong>1</strong>开始。如果插入的那一列没有给主键赋值。那就是从 AUTO_INCREMENT 获取值。用完后自加 1.<br>  所以查看具体的最下面有一个 auto_increment&#x3D; 多少；</p>
</blockquote>
<p>注意：</p>
<blockquote>
<p>auto_increment 会安照 <strong>最大</strong> 的去自增。</p>
</blockquote>
<h1 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h1><hr>
<p>唯一，非空。一般和 auto_increment 一起用</p>
<h1 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h1><hr>
<p>非空，但是可以重复</p>
<h1 id="唯一约束-–unique"><a href="#唯一约束-–unique" class="headerlink" title="唯一约束 –unique"></a>唯一约束 –unique</h1><hr>
<p>不能重复，可以为 null</p>
<h1 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h1><hr>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>  <span class="keyword">from</span> emp,dept</span><br></pre></td></tr></table></figure>

<p>以上有笛卡尔积。</p>
<p>消除笛卡尔积 用<strong>inner join 内连接</strong>. 把逗号，改成 inner join where 改成 on</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">INNER</span> <span class="keyword">JOIN</span> dept <span class="keyword">on</span> emp.dept_id<span class="operator">=</span>dept.id</span><br><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">INNER</span> <span class="keyword">JOIN</span> emp <span class="keyword">on</span> emp.dept_id<span class="operator">=</span>dept.id</span><br></pre></td></tr></table></figure>

<p>以上两种都可以。但是 null 值不会显示出来</p>
<p>可以用左外连接和右外连接：</p>
<blockquote>
<p>左外连接。查询左边的所以值</p>
<p>右外连接：查询右边所有的值</p>
</blockquote>
<p>显示所有部门对应的员工值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">left</span> <span class="keyword">JOIN</span> emp <span class="keyword">on</span> emp.dept_id<span class="operator">=</span>dept.id</span><br><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">right</span> <span class="keyword">JOIN</span> dept <span class="keyword">on</span> emp.dept_id<span class="operator">=</span>dept.id</span><br></pre></td></tr></table></figure>

<p>显示所有员工对应的部门值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">right</span> <span class="keyword">JOIN</span> emp <span class="keyword">on</span> emp.dept_id<span class="operator">=</span>dept.id</span><br><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">LEFT</span>  <span class="keyword">JOIN</span> dept <span class="keyword">on</span> emp.dept_id<span class="operator">=</span>dept.id</span><br></pre></td></tr></table></figure>

<p>这样不能查询所以的对应的 null 值</p>
<p>而且 mysql 没有全外连接查询。</p>
<p>可以通过 union 模拟这种查询</p>
<h1 id="where-比-having-先执行"><a href="#where-比-having-先执行" class="headerlink" title="where 比 having 先执行"></a>where 比 having 先执行</h1><hr>
<p>having 和 where 区别：</p>
<blockquote>
<ul>
<li>where 放在 from 之后，group by 之前</li>
<li>where 不能使用多行函数（聚集函数）, 列别名也不能用在 where 中</li>
<li>where 是在分组之前之前。先过滤一些记录，再基于剩余的记录进行返祖。</li>
<li>要先分组再过滤，基于剩下的记录进行分组，就用 having</li>
</ul>
</blockquote>
<p>where 和 having 的区别：</p>
<blockquote>
<ul>
<li><p>where 和 having 都是对于表记录中的记录进行过滤筛选</p>
</li>
<li><p>where 用于在分组之前对记录进行过滤筛选，而 having 是对分组之后的记录进行过滤筛选</p>
</li>
<li><p>where 子句中不能使用多行函数（聚集函数）, 和列别名。但是可以用表别名</p>
<blockquote>
<p>select name as 姓名，sal as 薪资 from emp e;</p>
<p>– 其中上面的’姓名’,’薪资’都是列别名，而 e 是表别名</p>
</blockquote>
</li>
<li><p>having 子句中可以使用多行函数（聚集函数）, 列别名，表别名</p>
</li>
</ul>
</blockquote>
<h2 id="插入数据时，数值类型的数据可以用单引号括起来这样也会识别成数值，一般来说。没人这么闲。不过导出的-sql-一般会自带-‘"><a href="#插入数据时，数值类型的数据可以用单引号括起来这样也会识别成数值，一般来说。没人这么闲。不过导出的-sql-一般会自带-‘" class="headerlink" title="插入数据时，数值类型的数据可以用单引号括起来这样也会识别成数值，一般来说。没人这么闲。不过导出的 sql 一般会自带  ‘"></a>插入数据时，数值类型的数据可以用单引号括起来这样也会识别成数值，一般来说。没人这么闲。不过导出的 sql 一般会自带  ‘</h2><h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><hr>
<h2 id="写-sql-片段时-小于号会被识别为-xml-的标签，大于不会，因为大于没开始的标志"><a href="#写-sql-片段时-小于号会被识别为-xml-的标签，大于不会，因为大于没开始的标志" class="headerlink" title="写 sql 片段时 小于号会被识别为 xml 的标签，大于不会，因为大于没开始的标志"></a>写 sql 片段时 小于号会被识别为 xml 的标签，大于不会，因为大于没开始的标志</h2><hr>
<p>大于：&gt;</p>
<blockquote>
<p>可以用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&amp;gt;</span> // 记得加分号 great than</span><br></pre></td></tr></table></figure></blockquote>
<p>小于：&lt;</p>
<blockquote>
<p> <strong>必须用</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&amp;lt;</span> // 记得加分号 less than</span><br></pre></td></tr></table></figure></blockquote>
<h1 id="好像有一个万能的转义字符"><a href="#好像有一个万能的转义字符" class="headerlink" title="好像有一个万能的转义字符"></a>好像有一个万能的转义字符</h1><hr>
<![CDATA[hello]]>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;![CDATA『这里输入你要展示的仍何内容』]&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Mybatis-1"><a href="#Mybatis-1" class="headerlink" title="Mybatis"></a>Mybatis</h1><hr>
<h1 id="写-sql-片段时-小于号会被识别为-xml-的标签，大于不会，因为大于没开始的标志-1"><a href="#写-sql-片段时-小于号会被识别为-xml-的标签，大于不会，因为大于没开始的标志-1" class="headerlink" title="写 sql 片段时 小于号会被识别为 xml 的标签，大于不会，因为大于没开始的标志"></a>写 sql 片段时 小于号会被识别为 xml 的标签，大于不会，因为大于没开始的标志</h1><hr>
<p>大于：&gt;</p>
<blockquote>
<p>可以用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&amp;gt;</span> // 记得加分号 great than</span><br></pre></td></tr></table></figure></blockquote>
<p>小于：&lt;</p>
<blockquote>
<p> <strong>必须用</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="symbol">&amp;lt;</span> // 记得加分号 less than</span><br></pre></td></tr></table></figure></blockquote>
<h1 id="好像有一个万能的转义字符-1"><a href="#好像有一个万能的转义字符-1" class="headerlink" title="好像有一个万能的转义字符"></a>好像有一个万能的转义字符</h1><hr>
<![CDATA[hello]]>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;![CDATA『这里输入你要展示的仍何内容』]&gt;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>MySQL 总结（二）</title>
    <url>/2021/11/25/MySQL%E6%80%BB%E7%BB%932/</url>
    <content><![CDATA[<h1 id="MySQL-注意的点："><a href="#MySQL-注意的点：" class="headerlink" title="MySQL 注意的点："></a>MySQL 注意的点：</h1><blockquote>
<p>写代码的时候突然觉得自己 SQL 方面有点弱，于是有了这篇文章</p>
</blockquote>
<hr>
<h2 id="为什么-where-不能用字段别名。因为-mysql-执行顺序："><a href="#为什么-where-不能用字段别名。因为-mysql-执行顺序：" class="headerlink" title="为什么 where 不能用字段别名。因为 mysql 执行顺序："></a>为什么 where 不能用<code>字段</code>别名。因为 mysql <strong>执行顺序</strong>：</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 错误：</span></span><br><span class="line"><span class="keyword">select</span> last_name <span class="keyword">as</span> name</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%shit%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正确：</span></span><br><span class="line"><span class="keyword">select</span> last_name <span class="keyword">as</span> name        <span class="comment">-- 最后再 select 生成字段</span></span><br><span class="line"><span class="keyword">from</span> employees                  <span class="comment">-- 先执行 from 哪个表</span></span><br><span class="line"><span class="keyword">where</span> last_name <span class="keyword">like</span> <span class="string">&#x27;%shit%&#x27;</span>;  <span class="comment">-- 再执行 where 条件</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="limit-使用方法"><a href="#limit-使用方法" class="headerlink" title="limit 使用方法"></a>limit 使用方法</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 这条语句意思是 从第 51 条数据（包括 51) 开始数，数 10 条数据出来</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line">limit <span class="number">50</span>,<span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 前端传第几页可以这样给：</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line">limit (currentPage<span class="number">-1</span>)<span class="operator">*</span>pageSize,pageSize;</span><br><span class="line"><span class="comment">---------------------------------</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line">limit <span class="number">0</span>,<span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line">limit <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="从-sql-优化来说，多表查询的字段最好都指明表名。减少-sql-找字段的时间。当然如果有同样的字段那肯定得指定的。"><a href="#从-sql-优化来说，多表查询的字段最好都指明表名。减少-sql-找字段的时间。当然如果有同样的字段那肯定得指定的。" class="headerlink" title="从 sql 优化来说，多表查询的字段最好都指明表名。减少 sql 找字段的时间。当然如果有同样的字段那肯定得指定的。"></a>从 sql 优化来说，多表查询的字段最好都指明表名。减少 sql 找字段的时间。当然如果有同样的字段那肯定得指定的。</h2><blockquote>
<p>E-R 图<br><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/25/MySQL%E6%80%BB%E7%BB%932/Snipaste_2022-03-17_17-35-04.jpg"
                        alt="PANGU_DISABLE"
                 ></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 正确：</span><br><span class="line">select employees.department_id, departments.department_id, employees.employee_id</span><br><span class="line">from employees,</span><br><span class="line">     departments</span><br><span class="line">where employees.department_id = departments.department_id;</span><br><span class="line"></span><br><span class="line">-- 正确（但是不高效）：</span><br><span class="line">select employees.department_id, departments.department_id, employee_id</span><br><span class="line">from employees,</span><br><span class="line">     departments</span><br><span class="line">where employees.department_id = departments.department_id;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="如果给表起了别名，在-select-或者-where-中使用表名的话，必须用别名，否则报错。因为-mysql-的执行顺序，表的别名会覆盖表名"><a href="#如果给表起了别名，在-select-或者-where-中使用表名的话，必须用别名，否则报错。因为-mysql-的执行顺序，表的别名会覆盖表名" class="headerlink" title="如果给表起了别名，在 select 或者 where 中使用表名的话，必须用别名，否则报错。因为 mysql 的执行顺序，表的别名会覆盖表名"></a>如果给表起了别名，在 select 或者 where 中使用表名的话，必须用别名，否则报错。因为 mysql 的执行顺序，表的别名会覆盖表名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 正确</span><br><span class="line">select employee_id, dept.department_id, employee_id</span><br><span class="line">from employees emp,</span><br><span class="line">     departments dept</span><br><span class="line">where emp.department_id = dept.department_id;</span><br><span class="line"></span><br><span class="line">-- 错误</span><br><span class="line">select employee_id, departments.department_id, employee_id</span><br><span class="line">from employees emp,</span><br><span class="line">     departments dept</span><br><span class="line">where employees.department_id = departments.department_id;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="UNION-操作会返回两个查询结果的并集，会去除相同的记录，而-UNION-ALL-不会去重，可以不去重就不去重的写法，去重是-mysql-去重的，所以-UNION-ALL-效率高。"><a href="#UNION-操作会返回两个查询结果的并集，会去除相同的记录，而-UNION-ALL-不会去重，可以不去重就不去重的写法，去重是-mysql-去重的，所以-UNION-ALL-效率高。" class="headerlink" title="UNION 操作会返回两个查询结果的并集，会去除相同的记录，而 UNION ALL 不会去重，可以不去重就不去重的写法，去重是 mysql 去重的，所以 UNION  ALL 效率高。"></a>UNION 操作会返回两个查询结果的并集，会去除相同的记录，而 UNION ALL 不会去重，可以不去重就不去重的写法，去重是 mysql 去重的，所以 UNION  ALL 效率高。</h2><hr>
<h2 id="COUNT-是计算不包括-null-的个数"><a href="#COUNT-是计算不包括-null-的个数" class="headerlink" title="COUNT() 是计算不包括 null 的个数"></a>COUNT() 是计算不包括 null 的个数</h2><hr>
<h2 id="酷COUNT-COUNT-1-COUNT（字段）哪个效率更高？"><a href="#酷COUNT-COUNT-1-COUNT（字段）哪个效率更高？" class="headerlink" title="酷COUNT(*),COUNT(1),COUNT（字段）哪个效率更高？"></a>酷<code>COUNT(*)</code>,<code>COUNT(1)</code>,<code>COUNT（字段）</code>哪个效率更高？</h2><p>如果是 MyISAM 存储引擎，三者效率都一样，因为这个引擎有一个字段专门存多少行的。<br>如果是 InnoDB 存储引擎，则效率：<code>COUNT(1)</code>&#x3D;<code>COUNT(*)</code>&gt;<code>COUNT（字段）</code>, 因为这个引擎会自动找 len 最短的去 count, 指定了字段没法优化。</p>
<hr>
<h2 id="这是结论：GROUP-BY-语句中，select-字段中只能存在除聚合函数的-GROUP-BY-字段。否则查出来的数据没有意义。"><a href="#这是结论：GROUP-BY-语句中，select-字段中只能存在除聚合函数的-GROUP-BY-字段。否则查出来的数据没有意义。" class="headerlink" title="这是结论：GROUP BY 语句中，select 字段中只能存在除聚合函数的 GROUP BY 字段。否则查出来的数据没有意义。"></a>这是结论：GROUP BY 语句中，select 字段中只能存在除聚合函数的 GROUP BY 字段。否则查出来的数据没有意义。</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">正确</span><br><span class="line"><span class="keyword">select</span> job_id j,<span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> j;</span><br><span class="line"></span><br><span class="line">也正确</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> job_id;</span><br><span class="line"></span><br><span class="line">错误：</span><br><span class="line"><span class="keyword">select</span> employee_id,<span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> job_id;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="HAVING-必须在-GROUP-BY-的后面，使用-HAVING-的前提是有-GROUP-BY"><a href="#HAVING-必须在-GROUP-BY-的后面，使用-HAVING-的前提是有-GROUP-BY" class="headerlink" title="HAVING 必须在 GROUP BY 的后面，使用 HAVING 的前提是有 GROUP BY"></a>HAVING 必须在 GROUP BY 的后面，使用 HAVING 的前提是有 GROUP BY</h2><hr>
<h2 id="where-和-having-效率区别，以及使用区别"><a href="#where-和-having-效率区别，以及使用区别" class="headerlink" title="where 和 having 效率区别，以及使用区别"></a>where 和 having 效率区别，以及使用区别</h2><p>没有聚合函数的情况下最好用 where 先判断条件。然后再分组再用 having 去操作条件，不然会 把没用的数据也给分组，浪费性能。<br>where 后面不能跟聚合函数，因为你就一组你没分组聚合按照条件没有意义啊。但是 HAVING 可以因为你分了很多个组所以就可以筛选。</p>
<hr>
<h2 id="mysql-执行顺序"><a href="#mysql-执行顺序" class="headerlink" title="mysql 执行顺序"></a>mysql 执行顺序</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> 这里后执行</span><br><span class="line"><span class="comment">------------</span></span><br><span class="line"><span class="keyword">JOIN</span>        这里先执行，且按顺序执行</span><br><span class="line"><span class="keyword">ON</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>    很奇怪的是这里可以用 <span class="keyword">SELECT</span> 字段的别名</span><br><span class="line"><span class="keyword">HAVING</span>      <span class="keyword">HAVING</span> 也能用，按道理执行顺序是不可以的</span><br><span class="line">            这是 MYSQL 可以的，特例这是。</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>    这里最后执行</span><br><span class="line">LIMIT</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="GROUP-BY-和-HAVING-可以使用-select-字段的别名，这是-MySQL-特殊的，按道理来说也就是执行顺序来说是不可以使用别名的。这是-MySQL-为了偷懒，我认为。"><a href="#GROUP-BY-和-HAVING-可以使用-select-字段的别名，这是-MySQL-特殊的，按道理来说也就是执行顺序来说是不可以使用别名的。这是-MySQL-为了偷懒，我认为。" class="headerlink" title="GROUP BY 和 HAVING 可以使用 select 字段的别名，这是 MySQL 特殊的，按道理来说也就是执行顺序来说是不可以使用别名的。这是 MySQL 为了偷懒，我认为。"></a>GROUP BY 和 HAVING 可以使用 select 字段的别名，这是 MySQL 特殊的，按道理来说也就是执行顺序来说是不可以使用别名的。这是 MySQL 为了偷懒，我认为。</h2><hr>
<h2 id="MYSQL-中不能聚合套聚合，这是他的缺陷，但是-ORACLE-可以"><a href="#MYSQL-中不能聚合套聚合，这是他的缺陷，但是-ORACLE-可以" class="headerlink" title="MYSQL 中不能聚合套聚合，这是他的缺陷，但是 ORACLE 可以"></a>MYSQL 中不能聚合套聚合，这是他的缺陷，但是 ORACLE 可以</h2><hr>
<h2 id="子查询和自连接相对来说，自连接好一些，因为子查询是通过未知表进行查询的条件判断，而自连接是通过已知的自身数据进行条件判断。因此大部分-DBMS-在自连接处理了优化"><a href="#子查询和自连接相对来说，自连接好一些，因为子查询是通过未知表进行查询的条件判断，而自连接是通过已知的自身数据进行条件判断。因此大部分-DBMS-在自连接处理了优化" class="headerlink" title="子查询和自连接相对来说，自连接好一些，因为子查询是通过未知表进行查询的条件判断，而自连接是通过已知的自身数据进行条件判断。因此大部分 DBMS 在自连接处理了优化"></a>子查询和自连接相对来说，自连接好一些，因为子查询是通过未知表进行查询的条件判断，而自连接是通过已知的自身数据进行条件判断。因此大部分 DBMS 在自连接处理了优化</h2><hr>
<h2 id="mysql-创建表没指明-charset-就用数据库的charset。数据库是可以charset的哦-charset-是-character-set-的简写"><a href="#mysql-创建表没指明-charset-就用数据库的charset。数据库是可以charset的哦-charset-是-character-set-的简写" class="headerlink" title="mysql 创建表没指明 charset 就用数据库的charset。数据库是可以charset的哦(charset 是 character set 的简写)"></a>mysql 创建表没指明 charset 就用数据库的charset。数据库是可以charset的哦(charset 是 character set 的简写)</h2><hr>
<h2 id="mysql-创建表有两种方式"><a href="#mysql-创建表有两种方式" class="headerlink" title="mysql 创建表有两种方式"></a>mysql 创建表有两种方式</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 一个一个创建</span></span><br><span class="line"><span class="keyword">create table</span> t1</span><br><span class="line">(</span><br><span class="line">    id   <span class="type">int</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> t1</span><br><span class="line"><span class="keyword">values</span> (<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>),</span><br><span class="line">       (<span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create table</span> t2 <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> t1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="DDL-DML-DCL-TCL"><a href="#DDL-DML-DCL-TCL" class="headerlink" title="DDL,DML,DCL,TCL"></a>DDL,DML,DCL,TCL</h2><ul>
<li><p>DDL:Data Definition Language (DDL)数据库定义语句</p>
<blockquote>
<p>用来创建数据库中的表、索引、视图、存储过程、触发器等<br>CREATE,ALTER,DROP,TRUNCATE,COMMENT,RENAME</p>
</blockquote>
</li>
<li><p>DML:Data Manipulation Language (DML)数据操纵语句</p>
<blockquote>
<p>用来查询、添加、更新、删除等<br>SELECT,INSERT,UPDATE,DELETE,MERGE,CALL,EXPLAIN PLAN,LOCK TABLE</p>
</blockquote>
</li>
<li><p>DCL:Data Control Language (DCL)数据控制语句</p>
<blockquote>
<p>用于授权&#x2F;撤销数据库及其字段的权限<br>GRANT,REVOKE。</p>
</blockquote>
</li>
<li><p>TCL:Transaction Control Language (TCL)事务控制语句</p>
<blockquote>
<p>用于控制事务<br>COMMIT,ROLLBACK,SAVEPOINT,SET TRANSACTION</p>
</blockquote>
</li>
</ul>
<hr>
<h2 id="DROP-表结构和表数据都会删除，释放表空间"><a href="#DROP-表结构和表数据都会删除，释放表空间" class="headerlink" title="DROP 表结构和表数据都会删除，释放表空间"></a>DROP 表结构和表数据都会删除，释放表空间</h2><hr>
<h2 id="TRUNCATE-只会清空表数据，但是保留表结构"><a href="#TRUNCATE-只会清空表数据，但是保留表结构" class="headerlink" title="TRUNCATE 只会清空表数据，但是保留表结构"></a>TRUNCATE 只会清空表数据，但是保留表结构</h2><hr>
<h2 id="TRANCATE-是DDL语句-DDL语句是没有ROLLBACK指令的，"><a href="#TRANCATE-是DDL语句-DDL语句是没有ROLLBACK指令的，" class="headerlink" title="TRANCATE 是DDL语句,DDL语句是没有ROLLBACK指令的，"></a>TRANCATE 是DDL语句,DDL语句是没有ROLLBACK指令的，</h2><hr>
<h2 id="ROLLBACK-只可以回滚到上一次的提交。仅仅是上一次次。DDL-没有ROLLBACK指令，你可以理解为DDL会自带一个commit，他执行完后会立刻马上会自动提交，所以你下面的ROLLBACK就到他下面的commit就打止了。"><a href="#ROLLBACK-只可以回滚到上一次的提交。仅仅是上一次次。DDL-没有ROLLBACK指令，你可以理解为DDL会自带一个commit，他执行完后会立刻马上会自动提交，所以你下面的ROLLBACK就到他下面的commit就打止了。" class="headerlink" title="ROLLBACK 只可以回滚到上一次的提交。仅仅是上一次次。DDL 没有ROLLBACK指令，你可以理解为DDL会自带一个commit，他执行完后会立刻马上会自动提交，所以你下面的ROLLBACK就到他下面的commit就打止了。"></a>ROLLBACK 只可以回滚到上一次的提交。仅仅是上一次次。DDL 没有ROLLBACK指令，你可以理解为DDL会自带一个commit，他执行完后会立刻马上会自动提交，所以你下面的ROLLBACK就到他下面的commit就打止了。</h2><hr>
<h2 id="TRUNCATE-和-DELETE-FROM-异同点"><a href="#TRUNCATE-和-DELETE-FROM-异同点" class="headerlink" title="TRUNCATE 和 DELETE FROM 异同点"></a>TRUNCATE 和 DELETE FROM 异同点</h2><ul>
<li>相同：<ul>
<li>都可以实现对数据的删除，同时保留表结构</li>
</ul>
</li>
<li>不同:<ul>
<li>DELETE FROM 是DML，TRUNCATE是DDL</li>
<li>TRUNCATE TABLE 不能回滚！！！</li>
<li>注意：COMMIT 在DML中是默认开启的，即set autocommit&#x3D;true，这是默认开启的，所以delete默认也不能回滚，只能设置为false才能回滚。</li>
<li>但是TRUNCATE不会触发TRIGGER（日志记录）所以是个危险操作尽量不用，虽然效率高。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="MySQL-8-0-有DDL的原子性，但是5-7没有。即："><a href="#MySQL-8-0-有DDL的原子性，但是5-7没有。即：" class="headerlink" title="MySQL 8.0 有DDL的原子性，但是5.7没有。即："></a>MySQL 8.0 有DDL的原子性，但是5.7没有。即：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- mysql8.0</span><br><span class="line">CREATE TABLE table1();</span><br><span class="line">DROP table1,table2;</span><br><span class="line">-- 因为table2不存在，所以不会成功。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="MyBatis-用-的情况，用到表名做参数的时候就用这个。"><a href="#MyBatis-用-的情况，用到表名做参数的时候就用这个。" class="headerlink" title="MyBatis 用${}的情况，用到表名做参数的时候就用这个。"></a>MyBatis 用${}的情况，用到表名做参数的时候就用这个。</h2><hr>
<h2 id="INSERT-添加可以添加查询结果："><a href="#INSERT-添加可以添加查询结果：" class="headerlink" title="INSERT 添加可以添加查询结果："></a>INSERT 添加可以添加查询结果：</h2><ul>
<li>但是要注意添加的字段要和查询的字段对应。</li>
<li>字段的范围也要对应,对应或者大于。如果里面的数据没有那么长，那可以。但是最好还是大于等于。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT into emp(id,name)</span><br><span class="line">select id,name </span><br><span class="line">from emp2;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="UPDATE-要接条件，不然会更新整个表，DELETE-FROM-TABLE-也是，要注意了。"><a href="#UPDATE-要接条件，不然会更新整个表，DELETE-FROM-TABLE-也是，要注意了。" class="headerlink" title="UPDATE 要接条件，不然会更新整个表，DELETE FROM TABLE 也是，要注意了。"></a>UPDATE 要接条件，不然会更新整个表，DELETE FROM TABLE 也是，要注意了。</h2><hr>
<h2 id="小数类型建议为DECIMAL，如果字段为非负数，建议为UNSIGNED"><a href="#小数类型建议为DECIMAL，如果字段为非负数，建议为UNSIGNED" class="headerlink" title="小数类型建议为DECIMAL，如果字段为非负数，建议为UNSIGNED"></a>小数类型建议为DECIMAL，如果字段为非负数，建议为UNSIGNED</h2><hr>
<h2 id="CHAR-是固定长度的-VARCHAR-是可变长度的。超过varchar最大值，用TEXT，但是TEXT-很大，所以建议独立一张表出来"><a href="#CHAR-是固定长度的-VARCHAR-是可变长度的。超过varchar最大值，用TEXT，但是TEXT-很大，所以建议独立一张表出来" class="headerlink" title="CHAR 是固定长度的,VARCHAR 是可变长度的。超过varchar最大值，用TEXT，但是TEXT 很大，所以建议独立一张表出来"></a>CHAR 是固定长度的,VARCHAR 是可变长度的。超过varchar最大值，用TEXT，但是TEXT 很大，所以建议独立一张表出来</h2><hr>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ul>
<li>not null</li>
<li>unique</li>
<li>check 5.7没有,8.0有，</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table test01(</span><br><span class="line">id int,</span><br><span class="line">last_name varchar(15)，</span><br><span class="line">salary decimal(10,2) check(salary&gt;2000))</span><br></pre></td></tr></table></figure>
<ul>
<li>DEFAULT</li>
</ul>
<hr>
<h2 id="行级约束，表级约束"><a href="#行级约束，表级约束" class="headerlink" title="行级约束，表级约束"></a>行级约束，表级约束</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table test1(</span><br><span class="line">id INT UNIQUE, -- 行级约束</span><br><span class="line">last_name VARCHAR(15),</span><br><span class="line">email VARCHAR(15),</span><br><span class="line">CONSTRAINT uk_test1_email UNIQUE(emial) -- 表级约束</span><br><span class="line">-- NOT NULL 没有表级约束</span><br><span class="line">)</span><br><span class="line">-- 这里给约束命名了，默认不给的话是和列名相同的</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="UNIQUE-可以有null，但是可以有多个null，"><a href="#UNIQUE-可以有null，但是可以有多个null，" class="headerlink" title="UNIQUE 可以有null，但是可以有多个null，"></a>UNIQUE 可以有null，但是可以有多个null，</h2><hr>
<h2 id="mysql-可以对表指定不同的存储引擎，你可以在show-create-table-XXX-看到后面，engin-XXX；外键约束不能跨引擎，btw，基本不用外键约束。在代码应用层解决"><a href="#mysql-可以对表指定不同的存储引擎，你可以在show-create-table-XXX-看到后面，engin-XXX；外键约束不能跨引擎，btw，基本不用外键约束。在代码应用层解决" class="headerlink" title="mysql 可以对表指定不同的存储引擎，你可以在show create table XXX 看到后面，engin&#x3D;XXX；外键约束不能跨引擎，btw，基本不用外键约束。在代码应用层解决"></a>mysql 可以对表指定不同的存储引擎，你可以在show create table XXX 看到后面，engin&#x3D;XXX；外键约束不能跨引擎，btw，基本不用外键约束。在代码应用层解决</h2><hr>
<h2 id="UTF8mb4和UTF8mb3"><a href="#UTF8mb4和UTF8mb3" class="headerlink" title="UTF8mb4和UTF8mb3"></a>UTF8mb4和UTF8mb3</h2><ul>
<li>utf8mb3:1~3个字节表示字符</li>
<li>utf8mb4:1~4个字节表示字符<br>mysql utf8 默认是utf8mb3。utf8mb4用于emoji表情一般；</li>
</ul>
<hr>
<h2 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h2><ul>
<li>SQL语句-&gt;查询缓存-&gt;解析器-&gt;优化器-&gt;执行器-&gt;找存储引擎API看用的哪个engine</li>
</ul>
<hr>
<h2 id="InnoDB-的好处"><a href="#InnoDB-的好处" class="headerlink" title="InnoDB 的好处"></a>InnoDB 的好处</h2><ul>
<li>你可以<code>show engines</code>看到，支持事物和分布式</li>
</ul>
<hr>
<h2 id="MyISAM-和-InnoDB"><a href="#MyISAM-和-InnoDB" class="headerlink" title="MyISAM 和 InnoDB"></a>MyISAM 和 InnoDB</h2><table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>外键</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>事物</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>行表锁</td>
<td>表锁，即使操作一条记录会锁住整个表，不适合高并发</td>
<td>行锁</td>
</tr>
<tr>
<td>缓存</td>
<td>只缓存索引，不缓存真实数据,增加查询很多优选选</td>
<td>缓存和数据都是真实数据，都是 .idb 结尾的文件,使用的时候会更占据内存 ,</td>
</tr>
<tr>
<td>关注点</td>
<td>性能：节省资源，消耗少，简单业务</td>
<td>事物：并发写，事物，更大资源</td>
</tr>
<tr>
<td>默认安装</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>默认使用</td>
<td>No(MySQL 5.5 之前 Yes)</td>
<td>Yes</td>
</tr>
<tr>
<td>选择</td>
<td>增加查询多用MyISAM</td>
<td>更新删除多优选选InnoDB</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>Oracle 中 substr 和 instr 函数简单用法</title>
    <url>/2021/08/07/Oracle-%E4%B8%AD-substr-%E5%92%8C-instr-%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<!-- vim-markdown-toc Marked -->

<ul>
<li><a href="#oracle-%E7%9A%84-substr-%E5%92%8C-instr-%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95">Oracle 的 substr 和 instr 函数简单用法</a><ul>
<li><a href="#substr-%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95">substr 函数简单用法</a><ul>
<li><a href="#substr-%E4%BB%8B%E7%BB%8D">substr 介绍</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">测试代码</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87">测试图片</a></li>
</ul>
</li>
<li><a href="#instr-%E5%87%BD%E6%95%B0%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95">instr 函数的简单用法</a><ul>
<li><a href="#instr-%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D%EF%BC%9A">instr 函数介绍：</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">测试代码</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87">测试图片</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a><ul>
<li><a href="#%E5%AE%9E%E4%BE%8B%E5%9B%BE%E7%89%87">实例图片</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- vim-markdown-toc -->

<h1 id="Oracle-的-substr-和-instr-函数简单用法"><a href="#Oracle-的-substr-和-instr-函数简单用法" class="headerlink" title="Oracle 的 substr 和 instr 函数简单用法"></a>Oracle 的 substr 和 instr 函数简单用法</h1><h2 id="substr-函数简单用法"><a href="#substr-函数简单用法" class="headerlink" title="substr 函数简单用法"></a>substr 函数简单用法</h2><h3 id="substr-介绍"><a href="#substr-介绍" class="headerlink" title="substr 介绍"></a>substr 介绍</h3><blockquote>
<p>/*</p>
<p>* 截取字符串（字符串位置从 1 开始，而不是从 0 开始）</p>
<p>* @param string 源字符串</p>
<p>* @param position 检索位置，参数为正时，从左向右检索，参数为负时，从右向左检索</p>
<p>* @param substring_length 要截取的长度，可省略（默认从 position 位开始截取全部）, 值小于 1 时返回空字符串</p>
<p>* @return 返回截取的字符串</p>
<p>*/</p>
</blockquote>
<p><strong><code>substr(string, position, substring_length);</code></strong></p>
<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> substr(<span class="string">&#x27;Hello World&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>)  c1<span class="comment">-- 返回结果为 &#x27;H&#x27;  * 从字符串第一个字符开始截取长度为 1 的字符串</span></span><br><span class="line">     , substr(<span class="string">&#x27;Hello World&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>)  c2<span class="comment">-- 返回结果为 &#x27;H&#x27;  *0 和 1 都是表示截取的开始位置为第一个字符</span></span><br><span class="line">     , substr(<span class="string">&#x27;Hello World&#x27;</span>, <span class="number">2</span>, <span class="number">4</span>)  c3<span class="comment">-- 返回结果为 &#x27;ello&#x27;</span></span><br><span class="line">     , substr(<span class="string">&#x27;Hello World&#x27;</span>, <span class="number">-3</span>, <span class="number">3</span>) c4<span class="comment">-- 返回结果为 &#x27;rld&#x27; * 负数 (-i) 表示截取的开始位置为字符串右端向左数第 i 个</span></span><br><span class="line"><span class="keyword">from</span> PRPDKIND;</span><br></pre></td></tr></table></figure>

<h3 id="测试图片"><a href="#测试图片" class="headerlink" title="测试图片"></a>测试图片</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/08/07/Oracle-%E4%B8%AD-substr-%E5%92%8C-instr-%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/Snipaste_2021-09-07_15-28-28.jpg"
                        alt="PANGU_DISABLE"
                 ></p>
<hr>
<h2 id="instr-函数的简单用法"><a href="#instr-函数的简单用法" class="headerlink" title="instr 函数的简单用法"></a>instr 函数的简单用法</h2><h3 id="instr-函数介绍："><a href="#instr-函数介绍：" class="headerlink" title="instr 函数介绍："></a>instr 函数介绍：</h3><blockquote>
<p>/*</p>
<p>* 返回子字符串在源字符串中的位置（字符串位置从 1 开始，而不是从 0 开始）</p>
<p>* @param string 源字符串</p>
<p>* @param substring 子字符串</p>
<p>* @param position 检索位置，可省略（默认为 1), 参数为正时，从左向右检索，参数为负时，从右向左检索</p>
<p>* @param occurrence 检索子字符串出现的次数，可省略（默认为 1), 值只能为正整数，否则会报错</p>
<p>* @return 返回子字符串在源字符串中出现的位置（没找到返回 0）</p>
<p>*/</p>
</blockquote>
<p><strong><code>instr(string, substring, position, occurrence)</code></strong></p>
<h3 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> INSTR(<span class="string">&#x27;hello world&#x27;</span>, <span class="string">&#x27;l&#x27;</span>) <span class="keyword">FROM</span> DUAL;           <span class="comment">-- 结果：3</span></span><br><span class="line"><span class="keyword">SELECT</span> INSTR(<span class="string">&#x27;hello world&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="number">5</span>) <span class="keyword">FROM</span> DUAL;        <span class="comment">-- 结果：10</span></span><br><span class="line"><span class="keyword">SELECT</span> INSTR(<span class="string">&#x27;hello world&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="number">-1</span>) <span class="keyword">FROM</span> DUAL;       <span class="comment">-- 结果：10</span></span><br><span class="line"><span class="keyword">SELECT</span> INSTR(<span class="string">&#x27;hello world&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="number">2</span>, <span class="number">2</span>) <span class="keyword">FROM</span> DUAL;     <span class="comment">-- 结果：4</span></span><br><span class="line"><span class="keyword">SELECT</span> INSTR(<span class="string">&#x27;hello world&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="number">-3</span>, <span class="number">3</span>) <span class="keyword">FROM</span> DUAL;    <span class="comment">-- 结果：0</span></span><br></pre></td></tr></table></figure>

<h3 id="测试图片-1"><a href="#测试图片-1" class="headerlink" title="测试图片"></a>测试图片</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/08/07/Oracle-%E4%B8%AD-substr-%E5%92%8C-instr-%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/Snipaste_2021-09-07_21-16-28.jpg"
                       
                 ></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>可以将 SUBSTR 和 INSTR 结合使用来实现截取字符串中特定字符前后的字符串</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 截取“hello,world”字符串中“,”分隔符之前的字符串</span></span><br><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;hello,world&#x27;</span>, <span class="number">1</span>, INSTR(<span class="string">&#x27;hello,world&#x27;</span>, <span class="string">&#x27;,&#x27;</span>)<span class="number">-1</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;hello,world&#x27;</span>, <span class="number">0</span>, INSTR(<span class="string">&#x27;hello,world&#x27;</span>, <span class="string">&#x27;,&#x27;</span>)<span class="number">-1</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="comment">-- 结果：hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 截取“hello,world”字符串中“,”分隔符之后的字符串</span></span><br><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;hello,world&#x27;</span>, INSTR(<span class="string">&#x27;hello,world&#x27;</span>, <span class="string">&#x27;,&#x27;</span>)<span class="operator">+</span><span class="number">1</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="comment">-- 结果：world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 截取“hello,world,HH”字符串中第 1 次出现的“,”字符和第 2 次出现的“,”字符之间的字符串</span></span><br><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;hello,world,HH&#x27;</span>, INSTR(<span class="string">&#x27;hello,world,HH&#x27;</span>, <span class="string">&#x27;,&#x27;</span>,<span class="number">1</span>)<span class="operator">+</span><span class="number">1</span>, INSTR(<span class="string">&#x27;hello,world,HH&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="number">2</span>)<span class="number">-1</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="comment">-- 结果：world</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;hello,world&#x27;</span>, <span class="number">1</span>, INSTR(<span class="string">&#x27;hello,world&#x27;</span>, <span class="string">&#x27;,&#x27;</span>) <span class="operator">-</span> <span class="number">1</span>) C1,<span class="comment">-- 结果：hello</span></span><br><span class="line">       SUBSTR(<span class="string">&#x27;hello,world&#x27;</span>, <span class="number">0</span>, INSTR(<span class="string">&#x27;hello,world&#x27;</span>, <span class="string">&#x27;,&#x27;</span>) <span class="operator">-</span> <span class="number">1</span>) C2,<span class="comment">-- 结果：hello</span></span><br><span class="line">       SUBSTR(<span class="string">&#x27;hello,world&#x27;</span>, INSTR(<span class="string">&#x27;hello,world&#x27;</span>, <span class="string">&#x27;,&#x27;</span>) <span class="operator">+</span> <span class="number">1</span>)    C3,<span class="comment">-- 结果：world</span></span><br><span class="line">       SUBSTR(<span class="string">&#x27;hello,world,HH&#x27;</span>, INSTR(<span class="string">&#x27;hello,world,HH&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="number">1</span>) <span class="operator">+</span> <span class="number">1</span>, INSTR(<span class="string">&#x27;hello,world,HH&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="number">2</span>) <span class="operator">-</span> <span class="number">1</span>) C4</span><br><span class="line">       <span class="comment">-- 截取“hello,world,HH”字符串中第 1 次出现的“,”字符和第 2 次出现的“,”字符之间的字符串 -- 结果：world</span></span><br><span class="line"><span class="keyword">FROM</span> DUAL;</span><br></pre></td></tr></table></figure>

<h3 id="实例图片"><a href="#实例图片" class="headerlink" title="实例图片"></a>实例图片</h3><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/08/07/Oracle-%E4%B8%AD-substr-%E5%92%8C-instr-%E5%87%BD%E6%95%B0%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/Snipaste_2021-09-07_21-30-19.jpg"
                       
                 ></p>
]]></content>
  </entry>
  <entry>
    <title>lombok 注解，绝中绝，顶上顶！</title>
    <url>/2021/12/20/lombok-%E6%B3%A8%E8%A7%A3%EF%BC%8C%E7%BB%9D%E4%B8%AD%E7%BB%9D%EF%BC%8C%E9%A1%B6%E4%B8%8A%E9%A1%B6%EF%BC%81/</url>
    <content><![CDATA[<h1 id="lombok-注解，绝中绝，顶上顶！"><a href="#lombok-注解，绝中绝，顶上顶！" class="headerlink" title="lombok 注解，绝中绝，顶上顶！"></a>lombok 注解，绝中绝，顶上顶！</h1><blockquote>
<p>可以在编译后的 class 文件来看出不同。不过有时候修改注解后，项目并不会自动编译，此时在 maven 手动编译即可看出效果。</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/12/20/lombok-%E6%B3%A8%E8%A7%A3%EF%BC%8C%E7%BB%9D%E4%B8%AD%E7%BB%9D%EF%BC%8C%E9%A1%B6%E4%B8%8A%E9%A1%B6%EF%BC%81/Snipaste_2021-12-20_10-24-14.jpg"
                        alt="PANGU_DISABLE"
                 ></p>
<ul>
<li>本文主要记录 lombok 可能会遇到的一些坑和一些注解解释</li>
</ul>
</blockquote>
<h2 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h2><p>@Data</p>
<p> &#x3D; @Getter + @Setter + @ToString + @EqualsAndHashCode</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>@Data 里面没有构造函数。即如果没有写自定义的构造函数那就是 Java 自带的无参构造函数。如果有自定义的构造函数那就是只有写了的构造函数，没有无参的了</li>
<li>由上一点，所以一般如果加了 @AllArgsConstructor, 那应该加个 @NoArgsConstructor.</li>
</ul>
<h2 id="EqualsAndHashCode"><a href="#EqualsAndHashCode" class="headerlink" title="@EqualsAndHashCode"></a>@EqualsAndHashCode</h2><p>@EqualsAndHashCode , 该注解是按照整个对象去重写 Equals 和 HashCode. 有时候业务场景是根据 ID 去判断是否重复，所以可以使用 @EqualsAndHashCode(of &#x3D; {“id”})</p>
<h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><blockquote>
<ul>
<li>没加 @EqualsAndHashCode(of &#x3D; {“id”})<br><img  
                       lazyload
                       alt="image"
                       data-src="/2021/12/20/lombok-%E6%B3%A8%E8%A7%A3%EF%BC%8C%E7%BB%9D%E4%B8%AD%E7%BB%9D%EF%BC%8C%E9%A1%B6%E4%B8%8A%E9%A1%B6%EF%BC%81/Snipaste_2021-12-20_10-52-03.jpg"
                        alt="PANGU_DISABLE"
                 ></li>
<li>加了 @EqualsAndHashCode(of &#x3D; {“id”})<br><img  
                       lazyload
                       alt="image"
                       data-src="/2021/12/20/lombok-%E6%B3%A8%E8%A7%A3%EF%BC%8C%E7%BB%9D%E4%B8%AD%E7%BB%9D%EF%BC%8C%E9%A1%B6%E4%B8%8A%E9%A1%B6%EF%BC%81/Snipaste_2021-12-20_10-50-59.jpg"
                        alt="PANGU_DISABLE"
                 ></li>
</ul>
</blockquote>
<h2 id="Accessors"><a href="#Accessors" class="headerlink" title="@Accessors"></a>@Accessors</h2><blockquote>
<p>@Accessors 有两个属性</p>
</blockquote>
<h3 id="Accessors-chain-true"><a href="#Accessors-chain-true" class="headerlink" title="@Accessors(chain &#x3D; true)"></a>@Accessors(chain &#x3D; true)</h3><ul>
<li>chain : 链</li>
</ul>
<p>现在链式编程很酷也很方便，å<br> 上该注解后，所有的 set 命令返回的都是 this 即调用对象本身。不加 @Accessors 默认 setXxx() 返回是 void</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/12/20/lombok-%E6%B3%A8%E8%A7%A3%EF%BC%8C%E7%BB%9D%E4%B8%AD%E7%BB%9D%EF%BC%8C%E9%A1%B6%E4%B8%8A%E9%A1%B6%EF%BC%81/Snipaste_2021-12-20_11-00-45.jpg"
                        alt="PANGU_DISABLE"
                 ></p>
<p>因此你可以像这样创建对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>().setId(<span class="number">1</span>).setName(<span class="string">&quot;lucy&quot;</span>).setAge(<span class="number">18</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Accessors-fluent-true"><a href="#Accessors-fluent-true" class="headerlink" title="@Accessors(fluent &#x3D; true)"></a>@Accessors(fluent &#x3D; true)</h3><ul>
<li>fluent : 流利的</li>
</ul>
<p>这个命令更牛逼，set get 都给你整没了。直接就是首字母小写的变量名。有参数的就是 set，没参数的就是 get</p>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/12/20/lombok-%E6%B3%A8%E8%A7%A3%EF%BC%8C%E7%BB%9D%E4%B8%AD%E7%BB%9D%EF%BC%8C%E9%A1%B6%E4%B8%8A%E9%A1%B6%EF%BC%81/Snipaste_2021-12-20_11-12-55.jpg"
                        alt="PANGU_DISABLE"
                 ><br>因此你可以像这样使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>().id(<span class="number">1</span>).name(<span class="string">&quot;lucy&quot;</span>).age(<span class="number">18</span>);</span><br><span class="line">System.out.println(student.id() + student.name() + student.age());</span><br></pre></td></tr></table></figure>

<h2 id="Builder"><a href="#Builder" class="headerlink" title="@Builder"></a>@Builder</h2><blockquote>
<p>一种设计模式：建造者模式</p>
</blockquote>
<h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h3><ul>
<li>@Builder 会增加全参构造函数，那他就没有默认的无参构造了，得注意。所以得加上 @NoArgsConstructor，但是加上后 @Builder 默认的全参构造就没了，会报错，所以都得加上 @NoArgsConstructor,@AllArgsConstructor.</li>
<li>并且内部类那个成员变量会覆盖掉他父类的成员变量的默认值，所以默认值会失效。<br><img  
                       lazyload
                       alt="image"
                       data-src="/2021/12/20/lombok-%E6%B3%A8%E8%A7%A3%EF%BC%8C%E7%BB%9D%E4%B8%AD%E7%BB%9D%EF%BC%8C%E9%A1%B6%E4%B8%8A%E9%A1%B6%EF%BC%81/Snipaste_2021-12-20_15-11-14.jpg"
                        alt="PANGU_DISABLE"
                 ></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前在 <a class="link"   href="https://okhttps.ejlchina.com/v3/getstart.html#%E6%9E%84%E5%BB%BA-http" >OkHttps<i class="fas fa-external-link-alt"></i></a> 里面看到过 builder() 这玩意，现在知道了是一种设计模式。lombok 也有用到。但是 @Builder 会更消耗内存吧，静态内部类还没用就直接整上内存里了，好处应该是更直观一点。还是推荐如果喜欢流式的就用 <code>@Accessors(fluent = true)</code> , 喜欢链式编程 setXxx() 就用 <code>@Accessors(chain = true)</code></p>
]]></content>
  </entry>
  <entry>
    <title>五笔</title>
    <url>/2021/09/10/%E4%BA%94%E7%AC%94/</url>
    <content><![CDATA[<h1 id="五笔"><a href="#五笔" class="headerlink" title="五笔"></a>五笔</h1><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/09/10/%E4%BA%94%E7%AC%94/Snipaste_2021-09-10_09-43-31.jpg"
                        alt="PANGU_DISABLE"
                 ></p>
<h1 id="口诀"><a href="#口诀" class="headerlink" title="口诀"></a>口诀</h1><h2 id="字根"><a href="#字根" class="headerlink" title="字根"></a>字根</h2><ul>
<li>横区 </li>
<li><ul>
<li>11(G) 王旁青头戋（兼）五一，</li>
</ul>
</li>
<li><ul>
<li>12(F) 土士二干十寸雨。二一还有革字底</li>
</ul>
</li>
<li><ul>
<li>13(D) 大犬三羊古石厂，</li>
</ul>
</li>
<li><ul>
<li>14(S) 木丁西，</li>
</ul>
</li>
<li><ul>
<li>15(A) 工戈草头右框七。（“右框”即“匚”）o</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>五笔学习之路</title>
    <url>/2021/09/01/%E4%BA%94%E7%AC%94%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="五笔学习之路"><a href="#五笔学习之路" class="headerlink" title="五笔学习之路"></a>五笔学习之路</h1><h2 id="缘故"><a href="#缘故" class="headerlink" title="缘故"></a>缘故</h2><ul>
<li><strong>起因</strong>：最开始由于全拼的击键次数过多，以后工作上经常会用到电脑，遂学习双拼（小鹤双拼）只由声母和韵母组成，任何一个字只需要击键两次，上手容易，熟悉后输入速度上有所提升。但是无法避免的拼音的重码率很高，还是要去候选框去选字。</li>
<li><strong>本质</strong>：由于本人在拼音中 in ing 分不清，而且拼音重码率高，五笔基本上四个键确定一个字，选字的情况比较少，空格就完事，为提高 <del>聊天摸鱼</del> 工作效率，故克服重重困难学习五笔 86 版本。</li>
<li><strong>情感升华</strong>：了解过五笔，对于中国汉字的结构以及五笔的渊源，其博大精深，被五笔输入的魅力所折服。<blockquote>
<p>这篇文章是用双拼打的</p>
</blockquote>
</li>
</ul>
<h2 id="五笔易错集合"><a href="#五笔易错集合" class="headerlink" title="五笔易错集合"></a>五笔易错集合</h2><ul>
<li>女<br>vvvv 键名汉子</li>
</ul>
<p>最后一笔为 横</p>
]]></content>
  </entry>
  <entry>
    <title>代码片段</title>
    <url>/2024/04/08/%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/</url>
    <content><![CDATA[<h2 id="通过反射获取参数化类型"><a href="#通过反射获取参数化类型" class="headerlink" title="通过反射获取参数化类型"></a>通过反射获取参数化类型</h2><p><a class="link"   href="https://github.com/second-state/chat-with-chatgpt/issues/306#issuecomment-2041743302" >https://github.com/second-state/chat-with-chatgpt/issues/306#issuecomment-2041743302<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">R&lt;?&gt; result = handle.handle(receive.substring(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Type</span> <span class="variable">returnType</span> <span class="operator">=</span> handle.getClass().getMethod(<span class="string">&quot;handle&quot;</span>, String.class).getGenericReturnType();</span><br><span class="line">    <span class="keyword">if</span> (returnType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">        Type[] actualTypeArguments = ((ParameterizedType) returnType).getActualTypeArguments();</span><br><span class="line">        <span class="keyword">if</span> (actualTypeArguments.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; genericClass = (Class&lt;?&gt;) actualTypeArguments[<span class="number">0</span>];</span><br><span class="line">            System.out.println(<span class="string">&quot;Found generic type: &quot;</span> + genericClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>免费添加SSL证书</title>
    <url>/2025/02/21/%E5%85%8D%E8%B4%B9%E6%B7%BB%E5%8A%A0SSL%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<p>好久没折腾博客，域名过期了，以前都是照着网上视频走步骤的，现在有了自己的理解</p>
<hr>
<h2 id="为什么要有ssl证书？"><a href="#为什么要有ssl证书？" class="headerlink" title="为什么要有ssl证书？"></a>为什么要有ssl证书？</h2><p>不妨说如果没有证书，浏览器会报不可信任，会弹出这是不安全链接让你是否继续访问。<br>因为你的数据不经过证书加密，会容易被篡改。<br>所以证书就是为了加密，保证发送消息和接收消息的安全。</p>
<h2 id="谁有说服力去管理这么多网站对应的证书？"><a href="#谁有说服力去管理这么多网站对应的证书？" class="headerlink" title="谁有说服力去管理这么多网站对应的证书？"></a>谁有说服力去管理这么多网站对应的证书？</h2><blockquote>
<p>我怎么知道你的证书就是属于你的网站的，得有一个有公信的机构盖章我才相信</p>
</blockquote>
<p>于是乎就有这种机构，好像是要交多少钱类似于保证金的东西，用钱证明实力。<br>这个机构来维护一个证书对应关系类似于 Java 的 Map，比如某某网站对应某个证书。<br>用户请求这个网站就拿这个证书去加密请求，对应的服务端也需要配置私钥去解密，于是加密请求就完成了。<br>用户信任机构的证书，服务端拿私钥也解密成功了，这个世界没有人受伤害。</p>
<h2 id="道理懂了，那证书怎么申请？"><a href="#道理懂了，那证书怎么申请？" class="headerlink" title="道理懂了，那证书怎么申请？"></a>道理懂了，那证书怎么申请？</h2><p>拿钱买或者搞免费的，我的需求只是为了让用户信任我，当你访问 <a class="link"   href="https://leijiba.cn/" >leijiba.cn<i class="fas fa-external-link-alt"></i></a> 的时候,为了让浏览器不弹出这是一个不安全的链接。</p>
<p>我用的是这家 <a class="link"   href="https://freessl.cn/" >freessl.cn<i class="fas fa-external-link-alt"></i></a> 免费的。</p>
<p>流程是：</p>
<ol>
<li>freessl 给你一个特定的<code>主机记录</code>还有<code>记录值</code> ，让你放到域名提供商解析那里解析，需要点时间同步到dns去。</li>
<li>域名提供商那里解析成功了，freessl这边也读到了，证明这就是属于你的域名。</li>
<li>1.2. 这两步就是为了验证这是你的域名，然后 freessl 就会给你公钥私钥。</li>
<li>公钥和私钥放服务器里配置就行了（有特定路径的，不用去死记没用）。客户端浏览器不需要做任何操作，因为别人请求你的域名的时候会从证书机构拿公钥。</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>学习&amp;延伸 用 Collections.unmodifiableList</title>
    <url>/2022/08/16/%E5%AD%A6%E4%B9%A0&amp;%E5%BB%B6%E4%BC%B8-%E7%94%A8-Collections-unmodifiableList/</url>
    <content><![CDATA[<h1 id="用-final-修饰的变量，对象属性可以修改的"><a href="#用-final-修饰的变量，对象属性可以修改的" class="headerlink" title="用 final 修饰的变量，对象属性可以修改的"></a>用 final 修饰的变量，对象属性可以修改的</h1><p>我在想有什么方法可以限制修改吗？</p>
<p>于是搜索后了解到有一个 <code>Collections</code> 里有一个内部类 <code>UnmodifiableCollection</code> ;</p>
<ul>
<li><p>UnmodifiableCollection 这个类重写了 Collection 的添加和修改方法，使其调用这个方法会抛 UnsupportedOperationException（不支持的操作异常）</p>
</li>
<li><p>可以用 Collections.unmodifiableList(yourList) 来让你的类不能用添加修改方法</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>当我们不想这个类调用某些方法时，可以重写这个类的方法。</li>
</ul>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ul>
<li>自己照抄思路实现了一下，哈哈，其是就是多态的体现。</li>
<li>为什么不用继承做呢？我觉得效果是一样的.但是是继承只能继承一个，接口能实现多个。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FeatureHaveMouth</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 吃粑粑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eatShit</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">FeatureHaveMouth</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eatShit</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog 吃粑粑，Dog 喜欢吃粑粑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainDog</span> <span class="keyword">implements</span> <span class="title class_">FeatureHaveMouth</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eatShit</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog 吃粑粑，Dog 喜欢吃粑粑，但是我是 TrainDog 就算我喜欢吃我也不吃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FeatureHaveMouth <span class="title function_">train</span><span class="params">(FeatureHaveMouth featureHaveMouth)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====Training====&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TrainDog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Test</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFeatHaveMouth</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FeatureHaveMouth</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog.eatShit();</span><br><span class="line">        <span class="type">FeatureHaveMouth</span> <span class="variable">trainDog</span> <span class="operator">=</span> TrainDog.train(dog);</span><br><span class="line">        trainDog.eatShit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试结果</li>
</ul>
<p><img  
                       lazyload
                       alt="image"
                       data-src="/2022/08/16/%E5%AD%A6%E4%B9%A0&%E5%BB%B6%E4%BC%B8-%E7%94%A8-Collections-unmodifiableList/Snipaste_2022-10-26_17-13-12.png"
                       
                 ></p>
]]></content>
  </entry>
  <entry>
    <title>Java实现天气预报</title>
    <url>/2021/11/10/%E5%AE%9E%E7%8E%B0%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5/</url>
    <content><![CDATA[<h1 id="用-Java-实现天气预报"><a href="#用-Java-实现天气预报" class="headerlink" title="用 Java 实现天气预报"></a>用 Java 实现天气预报</h1><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><ul>
<li>因每次去上班都不知道今天下不下雨。要是下雨鞋子就会湿的。</li>
<li>然后逛 github 发现有一个 QQ 机器人。可以用 Java 调用。遂想到实时预报下雨的天气。</li>
<li>所以设置每天早上 6 点发消息提醒今天的降水概率。</li>
</ul>
<h2 id="Step"><a href="#Step" class="headerlink" title="Step"></a>Step</h2><ol>
<li>使用 <a class="link"   href="https://github.com/ForteScarlet/simpler-robot" >simbot QQ 机器人<i class="fas fa-external-link-alt"></i></a>  (github 开源的）</li>
<li>使用和风天气和阿里云的易源数据作为天气 API</li>
</ol>
<h2 id="核心代码图片："><a href="#核心代码图片：" class="headerlink" title="核心代码图片："></a>核心代码图片：</h2><ul>
<li><p>RestFul 风格调用，接口见名知意<br><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/10/%E5%AE%9E%E7%8E%B0%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5/Snipaste_2021-11-10_18-29-11.jpg"
                       
                 ></p>
</li>
<li><p>OKHttps 访问 API 获取实时数据<br><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/10/%E5%AE%9E%E7%8E%B0%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5/Snipaste_2021-11-10_18-32-31.jpg"
                       
                 ></p>
</li>
<li><p>QQ 机器人代码参考<br><a class="link"   href="https://github.com/ForteScarlet/simpler-robot" >github<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<h2 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h2><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/10/%E5%AE%9E%E7%8E%B0%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5/Snipaste_2021-11-10_18-23-50.jpg"
                        alt="PANGU_DISABLE"
                 ></p>
]]></content>
  </entry>
  <entry>
    <title>摸鱼神器 scrcpy</title>
    <url>/2021/11/01/%E6%91%B8%E9%B1%BC%E7%A5%9E%E5%99%A8scrcpy/</url>
    <content><![CDATA[<h1 id="电脑操作手机的摸鱼神器-scrcpy"><a href="#电脑操作手机的摸鱼神器-scrcpy" class="headerlink" title="电脑操作手机的摸鱼神器 scrcpy"></a>电脑操作手机的摸鱼神器 <a class="link"   href="https://github.com/Genymobile/scrcpy" >scrcpy<i class="fas fa-external-link-alt"></i></a></h1><blockquote>
<p>无线控制需要在同一局域网下，并获取手机静态 IP</p>
</blockquote>
<ol>
<li>下载 <a class="link"   href="https://github.com/Genymobile/scrcpy/releases" >scrcpy<i class="fas fa-external-link-alt"></i></a>.</li>
<li>多次点击版本号，把手机的 usb 调试打开。usb 连接上电脑。</li>
<li>查看手机在当前 wifi 的 ip 地址。如果是 DHCP 模式，应当切换到静态模式</li>
<li>电脑命令行输入<code>adb tcpip 6666</code></li>
<li>电脑输入<code> adb connect IP:6666</code></li>
<li>现在可以拔掉数据线，输入命令<code>scrcpy</code>即可进行连接</li>
</ol>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ul>
<li>在手机熄屏下操作手机<ul>
<li><code>scrcpy -S</code></li>
<li><code>scrcpy --turn-screen-off</code></li>
</ul>
</li>
<li>操作屏幕点击鼠标右键即可解锁，也可以执行返回操作</li>
</ul>
<h1 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h1><p><img  
                       lazyload
                       alt="image"
                       data-src="/2021/11/01/%E6%91%B8%E9%B1%BC%E7%A5%9E%E5%99%A8scrcpy/Snipaste_2021-11-01_15-55-45.jpg"
                        alt="PANGU_DISABLE"
                 ></p>
]]></content>
  </entry>
</search>
